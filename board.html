<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<!-- TODO: set to 0.4 onchangeorientation to landscape -->
<meta name="viewport" content="width=device-width; initial-scale=0.65; maximum-scale=0.65; user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<!-- TODO <base href="http://xyzzy.freeshell.org/chess/"> -->
<title>Chess by Jeff</title>
<!-- Copyright (C) 2009 Jeff Connelly -->
<!-- Created:20090411 -->
<style type="text/css">
body {
    font: medium 'Gill Sans', sans-serif;
    line-height: 1.3;
    word-spacing: 0.1em;
    margin: 0;
    padding: 0;
    border: 0;
}

a { text-decoration: none; }
a:hover { border-bottom: 1px dotted; }

/* Header */
span.players { font-size: large; }
span.player_name { font-weight: bold; }
span.player_elo { font-size: small; }

#status { font-weight: bold; }
#opening_name { font-size: small; }

/* PGN */
span.fullmove_number { font-weight: bold; }
a.active_move { border-bottom: 1px dashed; }
/*a.repeated_move { text-decoration: underline; }*/     /* goes well with dots and dashes */
/*a.repeated_move { background-color: yellow; }*/   /* highlight */

/* Element that can be dragged */
.draggable { position: absolute; cursor: move; }

/* TODO: switch to divs, for flexibility, and use background-image.. or maybe not */
img.piece
{ 
 border: none;
 margin: 0px;

 /* Make captured pieces (smaller) look better on IE7+. See
  * http://www.gabrielweinberg.com/blog/2009/06/things-about-web-images-i-just-learned.html
  */
 -ms-interpolation-mode: bicubic;

 /* TODO: Transition when promote, would be nice to be
  * able to do with a CSS transition, but img src is not
  * a CSS property, but a tag attribute. And even if tried to animate
  * background-image, it wouldn't work until 6806248 is fixed.
  *
  * Or could have two images and change their opacity, see
  * http://www.the-art-of-web.com/css/timing-function/ section 4, but
  * that is even worse. */
 /*-webkit-transition: background 1s linear;*/
}

img.captured
{
 width: 25px;
 height: 25px;
}

img.black {}
img.white {}

/* Would be cool to use CSS3 expressions to make the pattern, but they're not in
 * Firefox 3.0.8, maybe in Firefox 3.1. Safari has them though! 
 * If do this, would need to remember to shift nth-child per ranks. 
 *td:nth-child(2n) { background-color: green } */
table.board
{
 /*border: 2px solid black;*/

/* This is like cellspacing=0 cellpadding=0 */
 border-collapse: collapse;

/* Disable text selection when dragging */
/* http://www.w3.org/TR/1999/WD-css3-userint-19990916#user-select */
 -moz-user-select: none;
 -webkit-user-select: none;
 user-select: none;
}

td.square
{
 border-style: none;
 /* border: 1px solid black; */
 padding: 0em;
 margin: 0em;
 width: 55px; min-width: 55px;
 height: 55px; min-height: 55px;
 text-align: center;

 /* So absolutely positioned images in cell are not misaligned */
 vertical-align: top;
 text-align: left;
}

td.label { text-align: center; }
td.file { border-bottom: 2px solid black; }
td.rank { border-right: 2px solid black; padding-right: 5px; }
td.right-edge { border-right: 2px solid black; }
td.bottom-edge { border-bottom: 2px solid black; }


/* Colors based on http://en.wikipedia.org/wiki/Chessboard
 * Useful site: http://www.cssdrive.com/imagepalette/index.php
 * Colors palette generator, get colors of an arbitrary image.
 *
 * Other colors to consider: http://chessos.com/, higher contrast
 *  http://chessteacher.110mb.com/, much lighter
 * But I like these, gives it a nice wooden feel. Could also
 * use green for a tournament-style board.
 */
td.white { background-color: #ffce9e; }
td.black { background-color: #d18b47; }

/* Highlights */

/* Legal squares to move to on mouseover */
/* different shades of tan
td.legal-move-white { background-color: #cf9e6e; }
td.legal-move-black { background-color: #a15b17; }
*/
td.legal-move-white { background-color: seagreen !important; }
td.legal-move-black { background-color: green !important; }

/* Recent move, shown during mouse operation and also once after */

/* Source square */
/*td.recent-move-white { background-color: #0066ff; }
td.recent-move-black { background-color: #0099ff; }*/

td.recent-move-white { background-color: blue; }
td.recent-move-black { background-color: blue; }

/* Next to last move */
/* TODO
td.penultimate-move-white { background-color: yellow; }
td.penultimate-move-black { background-color: yellow; }*/


/* Destination square */
td.dropping-square { background-color: blue !important; }   /* in progress (overrides legal) */  
td.dropped-square { background-color: blue; }               /* finished (does not) */

/* TODO: if destination square is a capture, make it red, even
 * when hovering. This gives more information on the move but also
 * provides better feedback when dragging to capture your opponent's
 * piece that just moved, because it'll already be colored with
 * dropping-square, giving no visual feedback - but it would if this
 * class was used in that scenario. */
td.dropping-square-capture { background-color: red !important; }
td.dropping-square-capture2 { background-color: red !important; }


/* TODO:
 * yellow - piece to promote
 * green - move just made
 * blue - move opponent just made
 * red - destination square if capture move
 */


#piece-inspector {
    position: absolute; 
    border: 1px solid black; 
    background-color: #d3d3d3;
    /* Need to make this large, so king's movement doesn't extend beyond box. 
     * Would like to have the movement wrap, but I guess ; is not a word-breaking
     * character, so could use &shy;, works on Safari, and supposedly IE7 and Firefox.
     */
    width: 600px;

    -webkit-box-shadow: 0 1px 20px rgba(0, 0, 0, 0.9); 
}

</style>
<!--<script type='text/javascript' src='http://getfirebug.com/releases/lite/1.2/firebug-lite-compressed.js'></script>-->
<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js"></script>
<!--<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js.uncompressed.js"></script>-->
<script src="http://www.google.com/jsapi"></script>
<script type="text/javascript">
/*jslint bitwise: true, browser: true, eqeqeq: true, immed: true, newcap: true, nomen: true, plusplus: true, regexp: true, undef: true*/
/*global window google form_value Hash $break Event*/

if (!window.google) {
    alert("Google was not found. Nothing will work.");
}

/* TODO: why aren't these miniifed? http://code.google.com/apis/ajaxlibs/documentation/index.html#prototype has
 * direct paths but neither prototype nor scriptaculous are minified.. others are though. Maybe just use raw JS. */
/* TODO: http://compressorrater.thruhere.net/ */
google.load("prototype", "1.6.0.3");
google.load("scriptaculous", "1.8.2");

// Chess movement notations, in descending precedence. 
// For more info see http://en.wikipedia.org/wiki/Chess_notation
var AVAILABLE_NOTATIONS = {
    // Acronym: full name                               examples
    SAN:  "Standard Algebraic Notation",//              Bxc6        e5
    LAN:  "Long Algebraic Notation",//                  Bb5xc6      e7-e5
    MAN:  "Minimal Algebraic Notation",//               Bc6         e5
    RAN:  "Reversible Algebraic Notation",//            Bb5xNc6     e7-e5
    CRAN: "Concise Reversible Algebraic Notation",//    Bb5:Nc6     e75
    FAN:  "Figurine Algebraic Notation",//              ♗xc6        ♟e5
    ICCF: "ICCF Numeric Notation",//                    2536        5755
    coord:"Coordinate Notation",//                      B5-C6       E7-E5
    smith:"Smith Notation",//                           b5c6n       e7e5
    descr:"English Descriptive Notation",//             BxN         P-K4
    adesc:"Algebraic Descriptive Notation",//           BxN         P-e4
    raw:  "Fast Raw Notation"//                         /b5/c5/B    /e5/e7/p
};

// Notations to export with save_pgn(). The first notation is stored in
// the PGN move text, others in special tags.
// TODO: export all by default, but then only include these for email?
var EXPORT_NOTATIONS = [
    "SAN",
    "LAN",
    "MAN",
    "CRAN",
    "FAN",
    "ICCF",
    "coord",
    "smith",
    "descr",
    "adesc",
    "raw"
];

// Preferences, not game state.
var PREFS = {
    revert_time: 350,           // ms to take to revert

    input_notation: "SAN",

    // What piece images to use  - TODO: option to change
    image_set: "alfaerieomega",   // See README in that directory
    //image_set: "ariel",    // based on Ariel Unicode MS
    //image_set: "chessos",
    
    engine: "http://jeff.tk:81/chess/crafty.cgi",
    skill: 100,                 // engine strength, 0-100

    flipped: false,             // True if from black's perspective instead of white
    setup_mode: false           // Setup pieces, instead of playing game
};


// Info about the game
var GAME_STATE = {
    // Whose turn it is
    active_color: '',
    
    // Castling privileges
    can_castle: {white: {cshort: true, clong: true}, black: {cshort: true, clong: true}},

    ep_target: null,

    halfmove_clock: 0,          // Ply since last pawn advance / capture
    fullmove_number: 0,         // Increment after black moves

    position_moves: {},         // Board position -> move IDs, for 3n move repetition
    position_after: [],         // Board positions at each move, for quick playback
    made_moves: [],             // Piece, square and each move notation for past moves
    ended: false,               // Game is done (drawn, won)
    captured: {white:[], black:[]}, // Captured pieces

    // Not game state, but other globals
    dragging: false,
    active_in_check: false,
    recent_piece: null,         // Recently moved piece
    recent_square: null,        // Recently moved from square
    last_captured: null,        // export_captured() string _before_ current move 
    piece_under: null,          // Piece under cursor for piece inspector
    shift: false                // Whether shift key is pressed
};    

/// Drag and drop globals
var DRAG = 
{
    start_x: 0,
    start_y: 0,
    offset_x: 0,        
    offset_y: 0,
    element_m: null,    // what is being dragged by the mouse
    element_t: null,    // by the touch interface
    old_zindex: 0,      // z-index of dragging element to restore
    touching: false,    // whether something is being touched
    dragging: false     // whether a drag is in progress
};

var DROP = {
    area: {},           // box to detect drop areas in
    square: null,       // square dropping over 
    offboard: false     // whether dropping offboard or not
};

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;             // Keyed by filerank of source, array of moves, x, y and any flags
var IS_VALID_MOVE = null;           // Keyed by filerank of source, then filerank of dest
var VALID_MOVES_OPP = null;         // Moves opponent could make, if it was their turn (attacking)
var VALID_MOVE_NOTATIONS = null;    // Map SAN, LAN, MAN, RAN, CRAN, FAN, coord, desc, Smith etc. -> [piece, square]
var ALT_MOVE_NOTATIONS = null;      // Same as above, but non-canonical, longer forms (Nb1c3 when Nc3 would do, etc.)

// Board 
var RANK_MAX = 8;
var FILE_MAX = 8;
var SQUARES = null;                 // Get table cell square node by rank and file
var VBOARD = null;                  // Virtual in-memory board

var AMP = String.fromCharCode(38);  // To avoid "not well-formed"

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
    // Keys:
    // parlett: movement of piece in extended Parlett notation
    // letter: uppercase character representing the piece in FEN
    // alg_letter: uppercase character for algebraic notation [defaults to FEN letter]
    // figurines: [white, black] Unicode strings for Figurine Algebraic Notation
    // iccf_number: number for ICCF Numberic Notation
    // royal: if true, if checked, must make move that unthreatens, otherwise checkmate
    // resets_50move: if true, resets the counter for the 50-move rule (pawns)
    // castles_with: piece to move in conjunction with this piece if castling
    // castle: if true, this piece can be moved during castling
    // promote: array of piece names that this piece can promote to, in order of preference

    // Standard international chess piece
    
    // TODO: @ for absolute, @3,0 and @4,0 short, then @7,0 for @6,0, in order to allow
    // Chess960 orthodox castling when rooks &amp; kings are not at known positions.
    //king: {parlett: "1*", /*[@3,0;move_a_castle_to=@4,0], [@7,0;move_h_castle_to=@6,0]",*/
    // TODO: actually pay attention to move_{a,h}_castle_to commands, instead of having the logic in piece moved,
    king: {parlett: "1*, [-2,0;if_can_castle_long;if_unblocked=-1,0;if_unblocked2=-2,0;if_unblocked3=-3,0;move_a_castle_to=3,0], " +
              "[2,0;if_can_castle_short;if_unblocked=1,0;if_unblocked2=2,0;move_h_castle_to=-2,0]",
          royal: true, letter: "K", figurines: ["\u2654", "\u265a"],
          castles_with: "rook", url:"pc:king"},
    queen: {parlett: "n*", letter: "Q", figurines: ["\u2655", "\u265b"], iccf_number: 1, url:"pc:queen"},
    rook: {parlett: "n+", letter: "R", castle: true, figurines: ["\u2656", "\u265c"], iccf_number: 2, url:"pc:rook"},
    bishop: {parlett: "nX", letter: "B", figurines: ["\u2657", "\u265d"], iccf_number: 3, url:"pc:bishop"},
    knight: {parlett: "~1/2", letter: "N", figurines: ["\u2658", "\u265e"], iccf_number: 4, url:"pc:knight"},


    // Pawns
    pawn: {parlett: 
        "o1>, c1X>, " + 
        "oi[0,2;if_unblocked=0,1;mark_ep_target=0,1], " +
        "[-1,1;if_ep_target;capture_at=-1,0], [1,1;if_ep_target;capture_at=-1,0]",

        image: "pawn",
        promote: ["queen", "knight", "rook", "bishop"],
        figurines: ["\u2659", "\u265f"],
        letter: "P",
        alg_letter: "",
        resets_50move: true,     // a pawn move resets the halfmove counter for the 50-move rule
        url: "pc:pawn"
    },
    weakpawn: {parlett: "o1>, c1X>"},   // No double move, no promotion
    superpawn: {parlett: "on>, cnX>", letter: "XP", image:"quickpawn"},
    berolinapawn: {parlett: "o1X>, c1>, io2X>", letter: "XB", image:"berolinapawn", resets_50move: true, url:"pc:berolina"},
    // TODO: http://www.chessvariants.org/piececlopedia.dir/berolina-plus.html
    
    // alt image: dragon, but less descriptive. There is also pawnknight!
    knightpawn: {parlett: "#pawn, #knight", image: ["knightpawn", "pawnknight"], url:"pc:dragon"},   
    // TODO: other dragon, http://www.chessvariants.org/piececlopedia.dir/dragonchess_dragon.html , and rename above pawnknight
    // David's pawn
    pawnattackrook: {parlett: "#pawn, c#rook", image:"pawn135cw", promote: ["dragon", "rookpawn"]},
    // TODO: chinesepawn from Xianqui, http://www.chessvariants.org/piececlopedia.dir/pawn-xiangqi.html
    // 1>, but when crosses "river", can move 1=
    sergeant: {parlett: "#berolinapawn, #pawn", promote:["queen", "knight", "rook", "bishop"], resets_50move:true, url:"pc:sergeant"},  // aka graz pawn

    steward: {parlett: "o1+, c1X"}, // aka fusilier, quadrapawn. o#wazir, c#ferz
    liapawn: {parlett: "o1>, o1=, c1X, io2>"},

    //fiveriderpawn: {parlett: "#pawn", promote: ["rook", "bishop", "nightrider", "camelrider", "zebrarider"], url:"http://www.mayhematics.com/v/v_gm.htm"}, // TODO: image
    ///freeleaperpawn: {parlett: "#pawn", promote: ["wazir", "knight", "zebra", "giraffe", "antelope"], url:"http://www.mayhematics.com/v/v_gm.htm"},

    // Hippogonal leapers
    dummy: {parlett: "~0/0", letter: "O", image:"banner"},
    man: {parlett: "1*", letter: "M", image:["mann2", "man", "guard", "wazirferz"], url:"pc:man"},    // same as king, but not royale (also known as commoner, guard)
    warmachine: {parlett: "~0/2", letter: "D", url:"pc:dabbabah"},  // or ~2+
    alfil: {parlett: "~2/2", letter: "Y", image:["elephant2", "elephantrev2", "elephant"], url:"pc:alfil"},       //  or ~2X
    threeheadmonster: {parlett: "~3/0", letter: "H"},     // aka threeleaper
    bird: {parlett: "~3/3", letter: "XT", image:["bird", "bird2"]},                // aka tripper
    camel: {parlett: "~1/3", letter: "W", image:["camel", "camel2", "camelrev2"], url:"pc:camel"},  // TODO: Timur's game
    zebra: {parlett:"~2/3", letter: "Z", url:"pc:zebra"},
    giraffe: {parlett: "~1/4", letter: "XG", url:"pc:giraffe"},
    //fourleaper: {parlett: "~0/4",url:"http://www.ktn.freeuk.com/9a.htm#(2)"},  // TODO: image
    //lancer: {parlett: "~2/4",url:"http://www.ktn.freeuk.com/9a.htm#(2)"}, // TODO: image
    //antelope: {parlett: "~3/4", url:"pc:antelope"},    // TODO: image
    //commuter: {parlett: "~4/4", url:"http://www.ktn.freeuk.com/9a.htm#(2)"}, // TODO: image
    //flamingo: {parlett: "~1/6", url:"pc:flamingo"},    // TODO: image

    // Amphibians (combined leapers)
    squirrel: {parlett: "~0/2, ~1/2, ~2/2", letter: "S", url:"pc:squirrel"},
    frog: {parlett: "~1/1, ~0/3", letter: "F"},     
    duke: {parlett: "~0/2, ~1/1", url:"http://www.mayhematics.com/v/v_gm.htm"},      // #ferz, #warmachine
    //bison: {parlett: "~1/3, ~2/3", url:"pc:bison"},                     // TODO: image (camel+antelope)
    gnu: {parlett: "~1/2, ~1/3", image:"knightcamel", url:"pc:gnus"},
    //rootfiftyleaper: {parlett: "~5/5, ~7/1", url:"pc:root50"},         // TODO: image
    //fiveleaper: {parlett: "~0/5, ~3/4", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    // TODO: root-65 leaper, bat, see http://members.shaw.ca/quadibloc/chess/ch03.htm
    //buffalo: {parlett: "~1/2, ~1/3, ~2/3", url:"pc:buffalo"},             // TODO: image
    //wazaba: {parlett: "~0/1, ~0/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    //diamond: {parlett: "~1/1, ~0/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    emperor: {parlett: "~0/1, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"knightwazir"}, 
    knightwazir: {parlett: "#knight, #wazir"},
    prince: {parlett: "~1/1, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:["prince", "knightferz"]},
    templar: {parlett: "~0/2, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"templar2"},
    //ferfil: {parlett: "~1/1, ~2/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    alibaba: {parlett: "~2*", letter: "L", image:"elephantwarmachine", url:"pc:alibaba"},   // or: #alfil, #warmachine = ~0/2, ~2/2
    // http://www.ktn.freeuk.com/9a.htm#(3) says caliph is ~0/1, ~2/2 (wazir + alfil), but Piececlopedia says it is camel+bishop
    //hospitaler: {parlett: "~1/2, ~2/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    // http://www.ktn.freeuk.com/9a.htm#(3) says caliph is ~0/1, ~2/2 (wazir + alfil)
    //pterodactyl: {parlett: "~3/3, ~5/5, ~0/15", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image

    // Royal pieces
    royalknight: {parlett: "#knight", letter: "XR", royal: true, image:["royalknight", "kingknight2"]}, 
    royalpawn: {parlett: "#pawn", royal: true},
    royalrook: {parlett: "#rook", royal: true},
    royalbishop: {parlett: "#bishop", royal: true},
    royalqueen: {parlett: "#queen", royal: true},
    maharajah: {parlett: "#amazon", letter: "XJ", royal: true, image:"paladin", url:"http://www.chessvariants.org/unequal.dir/maharaja.html"},   // Q+N+K, Maharajah chess TODO: crown amazon?
    supermaharajah: {parlett: "#amazon, #camel", royal: true, image:"supermaharajaschah"},
    kingpawn: {parlett: "#king, #pawn", royal: true},
    kingrook: {parlett: "#king, #rook", royal: true},

    // Diminished pieces
    b3: {parlett: "nX.3"},
    b4: {parlett: "nX.4"},
    b4wazir: {parlett: "#b4, #wazir"},
    r3: {parlett: "n+.3"},
    r4: {parlett: "n+.4"},
    r4ferz: {parlett: "#r4, #ferz"},
    alfilr4: {parlett: "#alfil, #r4"},
    q3: {parlett: "n*.3"},
    q4: {parlett: "n*.4"},

    // Generals, see http://www.mayhematics.com/v/v_gm.htm
    // soldier: {parlett: "1>"}, // TODO: image
    goose: {parlett: "o1X>", url:"http://www.mayhematics.com/v/v_gm.htm", image:["goose", "ferzf"]},
    //drunk: {parlett: "1="}, // TODO: image
    sailor: {parlett: "1X<", image:"ferzb"}, 
    //backslider: {parlett: "1<"}, // TODO: image
    coppergeneral: {parlett: "1>, 1X>"},     // aka dou-sho
    //drunkensoldier: {parlett: "1>, 1="}, // TODO: image
    //ferzwazirhunter: {parlett: "1>, 1X<"}, // TODO: image
    //adjutant: {parlett: "1>, 1<"}, //  aka tsiu-yin TODO: image
    //sidewinder: {parlett: "1X>, 1="}, // TODO: image
    ferz: {parlett: "1X", letter: "XF", image:["ferz", "ferz2"], url:"pc:ferz"}, // or ~1/1
    //ferzwazirhunter: {parlett: "1X>, 1<"}, // TODO: image
    //drunkensailor: {parlett: "1=, 1X<"}, // TODO: image
    //drunkenbackslider: {parlett: "1=, 1<"}, // TODO: image
    //deserter: {parlett: "1<, 1X<"}, // TODO: image
    //pikeman: {parlett: "1>, 1X>, 1="}, // TODO: image
    silvergeneral: {parlett: "1>, 1X", url:"pc:silvergeneral"},   // aka gin-sho - or #ferz, [0,1]
    //yale: {parlett: "1=, 1X>, 1<"}, // TODO: image
    //drunkenmarine: {parlett: "1>, 1=, 1X<"}, // TODO: image
    wazir: {parlett: "1+", letter: "I", url:"pc:wazir"},    // or ~0/1
    //gorilla: {parlett: "1=, 1X<, 1<"}, // TODO: image
    //diabolo: {parlett: "1+, 1="}, // TODO: image
    //yen: {parlett: "1X>, 1=, 1<"}, // TODO: image
    //invertedsilver: {parlett: "1X+, 1<"}, // TODO: image
    //drunkendeserter: {parlett: "1=, 1X<, 1<"}, // TODO: image
    //drunkenelephant: {parlett: "1+, 1X>, 1="}, // aka siu-zo  TODO: image 
    goldgeneral: {parlett: "1+, 1X>, 1=, 1<", url:"pc:goldgeneral"},  // or: #wazir, [1,1], [-1,1]
    //crane: {parlett: "1+, 1>, 1<"}, // aka horrible panther, mau-hau TODO: image
    //drunkengorilla: {parlett: "1>, 1X<, 1=, 1<"}, // TODO: image
    //blindtiger: {parlett: "1X, 1=, 1<"}, // TODO: image

    "2moveferz": {parlett: "2X, 2+"},       // one move like a ferz, then another from that square
    "2movewazir": {parlett: "2+, 1*"},      // ..
    "2movewazirferz": {parlett: "#2moveferz, #2movewazir"},


    // Combined pieces (compound pieces)
    // From piececlopedia http://www.chessvariants.org/index/mainquery.php?type=Piececlopedia&orderby=LinkText&displayauthor=1&displayinventor=1&usethisheading=Piececlopedia
    // or http://members.shaw.ca/quadibloc/chess/ch03.htm or 
    // http://www.chessvariants.com/graphics.dir/alfaerie/
    equesrex: {parlett: "#king, #knight", image:"equesrex", royal: true},
    //centaur: {parlett: "#knight, #man", url:"pc:centaur"},         // not royal, so not an equesrex  TODO: remove cross, make bcentaur.gif? also, ~0/1, ~1/1, ~1/2
    amazon: {parlett: "#queen, #knight", letter: "XV", url:"pc:amazon"},     // Q+N, aka superqueen
    amazonrider: {parlett: "#queen, #nightrider"}, 
    banshee: {parlett: "#bishop, #nightrider", url:"http://www.mayhematics.com/v/v_gm.htm"}, // TODO: image
    chancellor: {parlett: "#rook, #knight", letter: "C", image:["chancellor", "chancellor1"], url:"pc:rook-knight"},   // R+N, aka empress, marshal (Capablanca, X-FEN standard)
    chancellorrider: {parlett: "#chancellor, #nightrider"},
    chancellorwazir: {parlett: "#chancellor, #wazir"},
    archbishop: {parlett: "#bishop, #knight", letter: "A", image: ["cardinal", "cardinal1", "cardinal2", "princess"], url:"pc:bishop-knight"}, // B+N, aka cardinal, princess, janus (Capablanca, X-FEN standard)
    archbishoprider: {parlett: "#archbishop, #nightrider", image:"cardinalrider"},
    cardinalferz: {parlett: "#archbishop, #ferz"},
    dragonhorse: {parlett: "#bishop, #wazir", image: "promotedbishop", url:"pc:dragonhorse"},
    //berse: {parlett: "#rook, #ferz", image: "promtoedrook"},    // aka dragon king, but its not royal TODO: image
    caliph: {parlett: "#camel, #bishop", image: "camelbishop", url:"pc:caliph"},
    pope: {parlett: "#king, #bishop", image:"kingbishop"},  // http://www.chessvariants.com/difftaking.dir/thunder.html 
    //dragonking: {parlett: "#king, #rook", royal: true, url:"pc:dragonking"},   // TODO: image

    alfilbishop: {parlett: "#alfil, #bishop"},
    duchess: {parlett: "#bishop, #warmachinerider", image:["duchess", "bishopwarmachinerider"], url:"http://www.mayhematics.com/v/v_gm.htm"},
    bishoppawn: {parlett: "#bishop, #pawn"},
    elephantwarmachine: {parlett: "#elephant, #warmachine"},
    dayrider: {parlett: "#alfilrider, #warmachinerider", image:"elephantwarmachinerider"},  // aka alibabarider
    //duck: {parlett: "#ferz, #warmachinerider"},   // TODO: image
    rookpawn: {parlett: "#rook, #pawn"},
    knightwizard: {parlett: "#knight, #wizard", image:"horsezzmoon"},
    horsewazir: {parlett: "#honorablehorse, #wazir"},
    guardknight: {parlett: "#knight, #man", image:["guardknight2", "guardknight"]}, 
    elephantwazir: {parlett: "#elephant, #wazir"},
    elephantferzwarmachine: {parlett: "#elephant, #ferz, #warmachine"},
    camelferz: {parlett: "#camel, #ferz", image:["camelferz", "camel2ferz"]},
    camelqueen: {parlett: "#camel, #queen"},
    camelwarmachine: {parlett: "#camel, #warmachine"},
    camelwazir: {parlett: "#camel, #wazir", image:["camelwazir", "camel2wazir"]},
    camelbishoprider: {parlett: "#camelrider, #bishop"},
    camelpawn: {parlett: "#camel, #pawn"},
    camelwarmachinerider: {parlett: "#camel, #warmachinerider"},
    //camelopard: {parlett: "#camelrider, #fiveleaper", url:"http://www.mayhematics.com/v/v_gm.htm"}, // TODO: image
    crabalfil: {parlett: "#crab, #alfil"},
    crabwarmachine: {parlett: "#crab, #warmachine", image:"crabdabbaba"},
    crabferz: {parlett: "#crab, #ferz"},
    crabwazir: {parlett: "#crab, #wazir"},
    elephantcamel: {parlett: "#elephant, #camel"},
    elephantferz: {parlett: "#elephant, #ferz", image:["elephantferz", "elephant2ferz"]},
    elephantferzrook: {parlett: "#elephant, #ferz, #rook"},
    elephantknight: {parlett: "#elephant, #knight"},
    elephantknightrider: {parlett: "#elephant, #nightrider"},
    elephantknightwazir: {parlett: "#elephant, #knight, #wazir"},
    elephantwizard: {parlett: "#elephant, #wizard", image:"elephantzzmoon"},
    giraffeferz: {parlett: "#giraffe, #ferz"},
    giraffewazir: {parlett: "#giraffe, #wazir"},
    knightcamelzebra: {parlett: "#knight, #camel, #zebra"},
    knightwarmachineferz: {parlett: "#knight, #warmachine, #ferz", image:"knightdababaferz"},
    knightwazirwarmachine: {parlett: "#knight, #wazir, #warmachine"},
    rookwarmachine: {parlett: "#rook, #warmachine", image:"rookdabbaba"},
    queenalfilwarmachine: {parlett: "#queen, #alfil, #warmachine", image:"queenalfildabbaba3"},
    wazirwarmachinealfil: {parlett: "#wazir, #dabbaba, #alfil", image:"wazirdababaalfil"},
    warmachinewazir: {parlett: "#warmachine, #wazir"},
    warmachineriderwazir: {parlett: "#warmachinerider, #wazir"},
    warmachineferz: {parlett: "#warmachine, #ferz"},
    warmachineferzrider: {parlett: "#warmachinerider, #ferz"},
    wizardrider: {parlett: "#camelrider, #ferz", image:"moonrider"},
    zebracamel: {parlett: "#zebra, #camel"},
    zebracamelrider: {parlett: "#zebra, #camelrider"},
    zebraferz: {parlett: "#zebra, #ferz"},
    zebrawazir: {parlett: "#zebra, #wazir"},
    zebrawizard: {parlett: "#zebra, #wizard", image:"zebrazzmoon"},

    //walker: {parlett: "o#wazir, c#ferz"}, // TODO: image
    tiger: {parlett: "o#bishop, c#knight"},
    bd: {parlett: "#warmachine, #bishop", image:"bishopwarmachine", url:"pc:bd"},
    canvasser: {parlett: "#camel, #rook", image:"camelrook", url:"pc:canvassr"}, // yes, url is canvassr (no e)
    carpenter: {parlett: "#knight, #warmachine", image:"knightwarmachine", url:"pc:carpentr"},
    champion: {parlett: "#wazir, #alfil, #warmachine", url:"pc:champion"},
    //crownedrook: {parlett: "#rook, #ferz"},       // TODO: image
    crownedcamel: {parlett: "#camel, #ferz"},
    camelking: {parlett: "#camel, #king", image:"simplecamelking"},
    general: {parlett: "#wazir", royal: true, url:"pc:general", image:["general2", "general"]}, 
    kangaroo: {parlett: "#knight, #alfil", url:"pc:cangaroo"},  // Newton kangaroo, different than pc:kangaroo
    wizard: {parlett: "#camel, #ferz", image:"moon",  url:"pc:wizard"},
    waffle: {parlett: "#wazir, #alfil", image:"elephantwazir", url:"pc:waffle"},
    fad: {parlett: "#ferz, #alfil, #warmachine", image:"elephantferzwarmachine", url:"pc:fad"},
    bede: {parlett: "#bishop, #warmachine", image:"bishopwarmachine"},
    //fibnif: {parlett: "#ferz, [1,2], [-1,2], [-1,2], [-1,-2]", url:"pc:fibnif"},  // TODO: image

    // More complex fairy / non-intl chess pieces
    // See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
    // and even better, Piecelopedia 
    // http://chessvariants.wikidot.com/pcp:piececlopedia
 
    //hornedfalcon: {parlett: "n=x, 2>"},    // from Parlett, TODO: image
    
    // Despite appearances, this is not ~1/2>, since that would allow also
    // allow the forward moves [2,-1] and [-2,1]
    honorablehorse: {parlett: "[-1,2], [1,2]", image:["shogiknight", "horse"], url:"pc:shogiknight"},

    //chineseknight: {parlett: "1//2"}, // TODO: intervening must be unblocked
    lance: {parlett: "n+>", url:"pc:lance", image:["lance", "lance1"]},
    //colonel: {parlett: "n>, n=, 2/1>, 1*", letter: "XC"}, // TODO: image
    //murray_lion: {parlett: "~0/2, ~2/2, c1*", letter: "XM"}, // TODO: image
    lion: {parlett: "~n*", letter: "XL", url:"pc:lion"},
    elephant: {parlett: "2X", letter: "E", image:["elephantmodern", "elephant1"], url:"pc:elephant"},  // Not a leaper, path can be blocked (unlike alfil, ~2X)
    //khohn: {parlett: "1X, 1>", letter: "XK"}, // TODO: image

    // TODO: mushroom, try out Extended Parlett's [], explicitly giving relative moves. See:
    // http://www.chessvariants.org/graphics.dir/alfaeriemisc/spratt/ - would need to add (and all others)
    // http://www.chessvariants.org/piececlopedia.dir/mushroom.html
    // TODO: support ~0/0 for "null move" (---), but don't let drop to null, instead show a button
    //kraken: {parlett: "~n/m ~0/0"},     // any square, not realistic since always checkmates! TODO: image
    //octopus: {parlett: "o~n/m ~0/0", letter: "XD"}, // any square (8x8, octo, get it?) but can't capture, much less powerful TODO: image
    //universal_leaper: {parlett: "~n/m"},// like kraken, but can't go to square it is on (like a zero) TODO: image
    allseeingeye: {parlett: "o~n/m", image:"allseeingeye2"},       // anywhere

    // Riders
    nightrider: {parlett: "~1/2&", letter:"XN", image:["nightrider", "knightinv"], url:"pc:knightrider"},  // Wikipedia says n(1/2), but Parlett says ~1/2&
    alfilrider: {parlett: "~2/2&", image:"elephantrider"},  
    //elephantrider: {parlett: "2/2&", image:"elephantrider2"}, // TODO: gets blocked
    warmachinerider: {parlett: "~2/0&", image:["warmachinerider","dababbarider"]},
    camelrider: {parlett: "~1/3&"},
    alibabariderferz: {parlett: "~2/0&, ~2/2&"},
    girafferider: {parlett: "~1/4&"},
    zebrarider: {parlett: "~2/3&"},

    // Projectiles
    airplane: {parlett: "#allseeingeye, {cn+<;snapback}", letter: "U", image:"plane"},  // drops bombs
    gun: {parlett: "o#man, {c#queen;snapback}"},            // able to walk around, powerful distance projectiles
    rocket: {parlett: "o<<1, o>>1, {~cn+>;snapback}"},    // shoots straight, not very mobile
    // Note: not the patented archer at http://www.google.com/patents?id=MLEWAAAAEBAJ&dq=5901957
    archer: {parlett: "o#bishop, {c#knight;snapback}"},     // quite mobile, but can't shoot very far
    archerzz2: {parlett: "o#rook, {c#knight;snapback}"},
    archerzz3: {parlett: "o#bishop, {c#squirrel;snapback}"},

    // Invincibles
    block: {parlett: "", invincible: true},
    // Stone is an invincible warmachinerider
    stone: {parlett: "~2/0&",
                    // Explicit notation, before had rider syntax
                    /*"[0,2], [0,4;if_unblocked=0,2], [0,6;if_unblocked=0,4], " +
                     "[2,0], [4,0;if_unblocked=2,0], [6,0;if_unblocked=4,0], " +
                     "[-2,0], [-4,0;if_unblocked=-2,0], [-6,0;if_unblocked=-4,0], " +
                     "[0,-2], [0,-4;if_unblocked=0,-2], [0,-6;if_unblocked=0,-4]",*/
                     invincible: true},
    fort: {parlett: "o#wazir", invincible: true},       // masculine
    fortress: {parlett: "o#ferz", invincible: true},    // feminine (-ess, ferz like queen)
    nwall: {parlett: "o1>, o1=", invincible: true},

    // Consumables
    bomb: {parlett: "o1*, {c1*;self_destruct}", image:"medusa", invincible:true},
    superbomb: {parlett: "on*, {c~n*;self_destruct}", image:"gorgona"},

    // Pieces from chess-3
    // http://www.chessbase.com/newsdetail.asp?newsid=4553
    
    // rook + can move (not capture) like bishop
    tower: {parlett: "#rook, o#bishop", castle: true, letter: "T", image: "redrook"},  

    // knight + can move (not capture!) like wazir
    jous: {parlett: "#knight, o#wazir", letter: "J", image: "orangeknight"}, 

    // bishop + can move (not capture) 1 or 2 squares orthogonally
    vicar: {parlett: "#bishop, o2+", letter: "V", image: "yellowbishop"},

    // Explicit movements
    mushroom: {parlett: "[-1,2], [1,2], [3,1], [-3,1], [1,-1], [1,-2], [-1,-1], [-1,-2]", url:"pc:mushroom"},
    crab: {parlett: "[1,2], [-1,2], [-2,-1], [2,-1]", image: ["betzancrab", "crab2", "crab"], url:"pc:crab"},
    barc: {parlett: "[1,-2], [-1,-2], [-2,1], [2,1]", image: ["barc2", "barc"], url:"pc:barc"}
    // TODO: barcrider, would need to express hippogonally instead of explicitly
    
    // Pieces that probably won't be supported without significant coding
    //leo: {parlett: "on*, c^" + AMP, letter:"XO"},        // no locust support
    //checker: {parlett: "cn(^2X>), o1X>", promote: "checker_kinged", letter:"XY"},  // no grouping
    //checker_kinged: {parlett: "cn(^2X), o1x", letter:"XZ"},
    //spy: {parlett: "2>, 2=, (1/1)>", letter:"XS"}  // no grouping
    // pieces with no notation. WinChloe supports 1400 pieces.
    //
    // TODO: pieces from http://members.shaw.ca/quadibloc/chess/ch04.htm
};

        
var DEFAULT_BOARD_GROUP = "Orthodox Chess & Variants";
var DEFAULT_BOARD_NAME = "International Western Chess";

// Saved board setups in FEN
var SAVED_BOARDS = {
    "Orthodox Chess & Variants": {
// Standard chess and variants using no new pieces.  
// Sources:
// http://www.pathguy.com/chess/ChessVar.htm
// http://www.chessclub.com/helpcenter/tips/wild.html
"International Western Chess": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
"Advance Chess":        "rnbqkbnr/8/pppppppp/8/8/PPPPPPPP/8/RNBQKBNR w KQkq - 0 1",
"Atheist Chess": "rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RN1QK1NR w KQkq - 0 1",
// TODO: win if promote (kraken?), allow diagonal even if not capture
// http://en.wikipedia.org/wiki/Breakthrough_(board_game)
//"Breakthrough": "pppppppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPPPPP w - - 0 1",
// TODO: Support Chaturanga pawns. No double move/en passant, and promotes to where started.
//"Indian Chess (Chaturanga)": "rnekxfenr/pppppppp/8/8/8/8/PPPPPPPP/RNEKXFENR w - 0 1",
"Church Chess":         "bbbbkbbb/pppppppp/8/8/8/8/PPPPPPPP/BBBBKBBB w - - 0 1",
"Corner Chess":         "4rbqk/4rb1q/4r1bb/5rrr/RRR5/BB1R4/Q1BR4/KQBR4 w - - 0 1",
"Corner Chess II":      "kbp2pbq/nrp2prn/pp4pp/8/8/PP4PP/NRP2PRN/QBP2PBK w - - 0 1",
"Corridor Chess":       "1nrqkrn1/2b2b2/1pppppp1/8/8/1PPPPPP1/2B2B2/1NRQKRN1 w - - 0 1",
"Desegregated Chess": "RNbqKBnr/ppPpPPPp/8/8/8/8/PPpppPpP/rnBQkBnr w KQkq - 0 1",
"Dunsany's Chess": "rnbqkbnr/pppppppp/8/8/PPPPPPPP/PPPPPPPP/PPPPPPPP/PPPPPPPP w kq - 0 1",
"Eight Kings Chess":    "kkkkkkkk/pppppppp/8/8/8/8/PPPPPPPP/KKKKKKKK w - - 0 1",
"Fianchetto Chess":     "bnrqkrnb/pppppppp/8/8/8/8/PPPPPPPP/BNRQKRNB w KQkq - 0 1",
"Fortress Chess":       "rnbqkbnr/pppppppp/ppp4/8/8/5PPP/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
// TODO: White wins if captures all black's pieces
"Horde Chess":          "ppp2ppp/pppppppp/pppppppp/pppppppp/3pp3/8/PPPPPPPP/RNBQKBNR w KQ - 0 1",
"Knight Odds Chess":   "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/R1BQKBNR w KQkq - 0 1",
"Marxist Chess (DLS-CSB)":       "8/pppppppp/8/8/8/8/PPPPPPPP/8 w - - 0 1",
"Marxist Chess (2x)":       "pppppppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPPPPP w - - 0 1",
"Missionary Chess": "pppppppp/ppppqppp/8/8/4K3 w - - 0 1",
"Mind Chess": "8/8/8/8/8/8/8/8 w - - 0 1",
// chess-3 http://www.chessbase.com/newsdetail.asp?newsid=4553
// TODO: 48 unique setups
"Mongredian Chess":    "rbbqknnr/pppppppp/8/8/8/8/PPPPPPPP/RBBQKNNR w - - 0 1",
"Obama Chess": "rnbqKbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQkBNR b KQkq - 0 1",
"Pawn's Game Chess": "rnbqkbnr/pppppppp/8/8/2PPPP2/1PP2PP1/PPPPPPPP/RNB1KBNR w KQkq - 0 1",
"Pawn Massacre Chess": "RNBQKBNR/pppppppp/8/8/8/8/PPPPPPPP/rnbqkbnr w KQkq - 0 1",
"Pawn Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPP1PP/RNBQKBNR w KQkq - 0 1",
"Pawnless Chess":      "rnbqkbnr/8/8/8/8/8/8/RNBQKBNR w KQkq - 0 1",
"Peasant's Revolt Chess I":"1nn1knn1/4p3/8/8/8/8/PPPPPPPP/4K3 w - - 0 1",
"Peasant's Revolt Chess II":"1nn1k1n1/4p3/8/8/8/8/PPPPPPPP/4K3 w - - 0 1",
"Peasant's Revolt Chess III":"1n2k1n1/2p1p3/8/8/8/8/PPPPPPPP/4K3 w - - 0 1",
"Power Chess / Wild 18":"qqqqkqqq/pppppppp/8/8/8/8/PPPPPPPP/QQQQKQQQ w - - 0 1",
"Power Chess II":       "rrbqkbrr/bbnnnnbb/pppppppp/8/8/PPPPPPPP/BBNNNNBB/RRBQKBRR w - - 0 1",
"Queen Odds Chess":    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB1KBNR w KQkq - 0 1",
"Reverso Chess":        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBKQBNR w KQkq - 0 1",
"Revolt Chess": "pppppppp/rnbqkbnr/8/8/8/8/RNBQKBNR/PPPPPPPP w KQkq - 0 1",
"Republican Chess": "rnb2bnr/pppppppp/8/8/8/8/PPPPPPPP/RNB2BNR w - - 0 1",
"Rook Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/1NBQKBNR w KQkq - 0 1",
"Royal Stables Chess":  "nnnnknnn/pppppppp/8/8/8/8/PPPPPPPP/NNNNKNNN w - - 0 1",
"Survival Chess": "nnnpnpnn/pppnnnpn/nppppppp/np4pn/np2P1pn/pp4pn/nppppppp/nnpnnnpn w - - 0 1",
"Twin Chess":           "rbqkkqbr/pppppppp/n6n/8/8/N6N/PPPPPPPP/RBQKKQBR w - - 0 1",
"Twin Chess B":         "nkbqqbkn/r2pp2r/pppppppp/8/8/PPPPPPPP/R2PP2R/NKBQQBKN w - - 0 1",
"Upside-Down Chess / Wild 5":    "RNBQKBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbqkbnr w KQkq - 0 1",
"Vegetarian Chess": "r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BQKB1R w KQkq - 0 1",
"Weak! / Seven Knights Chess":  "nnnnknnn/pppppppp/2p2p2/1pppppp1/8/8/PPPPPPPP/RNBQKBNR w - - 0 1",
"Wild Chess 7 ":        "4k3/5ppp/8/8/8/8/PPP5/3K4 w - - 0 1",
"Wild Chess 8":         "rnbqkbnr/8/8/pppppppp/PPPPPPPP/8/8/RNBQKBNR w KQkq - 0 1",
"Wild Chess 19":        "8/6k1/4p3/4N3/8/6K1/7N/8 w - - 0 1"
    },

"New Pieces": {
"Amazon Chess":         "rnbxvkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBXVKBNR w KQkq - 0 1",
"Berolina Chess": "rnbqkbnr/xbxbxbxbxbxbxbxb/8/8/8/8/XBXBXBXBXBXBXBXB/RNBQKBNR w KQkq - 0 1",
"Commoner Chess":     "rnbqmbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQMBNR w KQkq - 0 1",
"Knightmate Chess":    "rmbqxrbmr/pppppppp/8/8/8/8/PPPPPPPP/RMBQXRBMR w KQkq - 0 1",
// TODO: No black pawn promotion
"Maharajah and the Sepoys":     "rnbqkbnr/pppppppp/8/8/8/8/8/4XJ3 w kq - 0 1",
"Milener's Chess-3 (non-random)": "rnbqkvjt/pppppppp/8/8/8/8/PPPPPPPP/RNBQKVJT w KQkq - 0 1",
"Nightrider Chess I": "r1bx(nightrider)kb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BX(nightrider)KB1R w KQkq - 0 1",
"Nightrider Chess II": "rx(nightrider)bqkbx(nightrider)r/pppppppp/8/8/8/8/PPPPPPPP/RX(nightrider)BQKBX(nightrider)R w KQkq - 0 1"

// TODO: historical chess group?
// Shatranj, except the following rules are NOT implemented:
// 1. Pawns can't make double moves
// 2. Pawn only promotes to ferz
// 3. Stalemating your opponent wins
// 4. Taking the last piece of your opponent wins, unless your opponent
//    can take your last non-king piece too, in which case the game is drawn
//"Shatranj (Not Quite)":     "rnykxfynr/pppppppp/8/8/8/8/PPPPPPPP/RNYKXFYNR w - - 0 1"

},
    "Chess Openings": {
    },

    "Test Pieces": {
"Test Pawns": "8/x(rookpawn)x(knightpawn)x(bishoppawn)x(superpawn)x(weakpawn)x(berolinapawn)x(pawnattackrook)p/8/2x(steward)/4X(sergeant)1X(liapawn)/8/X(rookpawn)X(knightpawn)X(bishoppawn)X(superpawn)X(weakpawn)X(berolinapawn)X(pawnattackrook)P w - - 0 1",
"Test Leapers": "K/2E1Y1H1/3M/1XT1W1XG1Z/8/3Z1N/4oo/5k w - - 0 1", // TODO: antelope, flamingo
"Test Riders": "B2R//4Q/4X(nightrider)/2X(alibabariderferz)3X(stone)/5X(warmachinerider)/2X(alfilrider)X(camelrider)2X(zebrarider)/4X(girafferider) w - - 0 1",
"Test Amphibians": "4k/8/8/slslslsl/8/8/FFFFFFFF/4K w - - 0 1",
"Test Royalty": "x(royalrook)x(royalknight)x(royalbishop)xjkx(royalbishop)x(royalknight)x(royalrook)/pppppppp/8/8/8/8/PPPPPPPP/X(royalrook)X(royalknight)X(royalbishop)XJKX(royalbishop)X(royalknight)X(royalrook) w KQkq - 0 1",
"Test Projectiles": "x(airplane)X(airplane)4x(airplane)/X(allseeingeye)/1x(bird)/2x(bird)x(bird)x(bird)1x(bird)/3x(bird)x(bird)/3X(archerzz3)x(bird)/4X(archerzz2)X(archer)/x(frog)1X(gun)3X(rocket) w - - 0 1",
"Test Invincibles": "3x(dummy)x(dummy)/7x(nwall)/x(dummy)3x(block)1X(fortress)/4K3/5x(stone)X(fort)/8/1kX(block)1X(stone)/1X(block)x(block)3X(nwall) w - - 0 1",
"Test Consumables": "4k/pppppppp/1pppppp1/2pppp2/X(bomb)2X(superbomb)/8/PPPPPPPP/4K w - - 0 1",
"Test Diminished": "/1X(b4)5X(q4)//4X(b3)//3X(r3)X(honorablehorse)/2X(r4)/7X(q3) w - - 0 1",
"Test Mix 1": "X(airplane)x(airplane)/3x(pawnattackrook)x(caliph)x(pope)X(elephantwarmachine)/8/8/8/4S/X(lance)fwZ1X(pawnattackrook)/AcDeIFvT w - - 0 1",
"Test Mix 2": "//2/1X(silvergeneral)2X(mushroom)/3X(crab)X(wizard)/4X(barc)1X(goldgeneral)//7m w - - 0 1",
"Test Mix 3": "x(zebracamel)//3X(2moveferz)//3X(supermaharajah)1X(2movewazirferz)/2X(2movewazir) w - - 0 1"
    },

    "Test Rules": {
"Test Checkmate": "r1bknbrN/pppppppp/8/8/8/8/PPPPPPPP/nRBNKB1R b - - 0 1",
"Test Stalemate":     "k7/8/8/8/8/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5",
"Test Remove Check by Capture":     "4k3/1p6/2Q5/8/8/8/8/7K b - - 0 5",
"Test Promotion":     "K/PPPPPPPP/8/8/8/8/pppppppp/7k w - - 0 1",
"Test Promotion to Rook": "8/k1P5/p7/P3K3/8/8/8/8 w - - 0 53", // from http://chessteacher.110mb.com/2008/10/22/minor-promotion/
"Test Promotion to Bishop": "8/5P1k/5K1p/7P/8/8/8/8 w - - 0 51",
"Test En Passant (alone)":     "8/8/8/3pP3/8/8/8/8 w - d6 0 1",
"Test En Passant":     "rnbqkbnr/ppp2ppp/8/3pP3/3Qn/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5",
"Test En Passant into Check": "qk6/8/8/3pP3/8/8/8/7K w - d6 0 5",
"Test Lone King": "K w KQkq - 0 1",
"Test K + K":     "k7/8/K7/8/8/8/8/8 b - - 0 30",
"Test K + KQ":     "k7/8/8/8/8/8/8/5KQ1 w - d6 0 50",
"Test K + KR":     "k7/8/8/8/8/8/8/5KR1 w - d6 0 50",
"Test K + KB":     "k7/8/K7/8/8/8/8/B b - - 0 30",
"Test K + KN":     "k7/8/K7/8/8/8/8/N b - - 0 30",
"Test KB + KB opposite colors":     "k7/8/K7/8/8/8/b/B b - - 0 30",
"Test KB + KB same colors":     "k7/8/K7/8/8/8/3b/B b - - 0 30",
"Test KBB + KBB same colors":     "k7/8/K7/8/8/8/3b1b/B3B b - - 0 30",
"Test KBB + KBB opposite colors":     "k7/8/K7/8/8/8/3b1b/B2B b - - 0 30",
"Test Castling out of Check":     "4r3/8/8/8/8/8/8/R3K2R w KQkq - 0 1",
"Test Castling through Check":     "1k3r2/8/8/8/8/7Q/8/R3K2R w KQkq - 0 1",
"Test Castling through Check (pawn)": "rnbqkbnr/pppp2pp/8/6N1/4p3/3B4/PPPP2pP/RNBQK2R w KQkq - 0 7",
"Test Castling w/ Intervening Pieces":     "1k/8/8/8/8/8/8/R3KQ1R w KQ - 0 1",
"Test Only Move ":     "rnbqkbnr/ppp2ppp/8/8/8/8/PPP2PPP/RNBQKBNR w KQkq - 0 1",
"Test Disambiguation by File":     "k7/8/8/8/8/8/3N4/6N1 w - - 0 1",
"Test Disambiguation by Rank":     "k7/8/8/6N1/8/8/8/6N1 w - - 0 1",
"Test Disambiguation by File+Rank":     "k7/8/8/4N1N1/3N3N/8/3N3N/4N1N1 w - - 0 1",
"Test Disambiguation w/ 8 Queens": "3Q4/6q1/2Q5/7q/1Q6/4q3/7Q/5q2 w - - 0 1",
"Test vboard Check-Checking": "8/8/R2k2p1/3n1bp1/1p6/1P3P1P/5KP1/8 b - - 0 36",
"Test Getting out of Check": "rnbqkbnr/ppp1p1pp/4P3/3p3Q/5p2/8/PPPP1PPP/RNB1KBNR b KQkq - 0 4",
"Test Check Checking": "rnbQ1bnr/ppp1kppp/8/4p3/7q/8/PPPP1PPP/RNBQKBNR b KQ - 0 5",
"Test Parlett Move Interference": "r/8/8/1N3b2/3PP3/1P1BBN/8/8 w - - 0 17",
"Test Captures": "8/MMMMMMMM/mmmmmmmm/8/QQQQQQQQ/qqqqqqqq/NNNNNNNN/xlxlxlxlxlxlxlxl w - - 0 1"
    }
};

// Opening positions along with extended ECO codes and common names
// Extended ECO codes are from scid.eco, see http://scid.sourceforge.net/help/ECO.html
//  and http://scid.sourceforge.net/help/EPD.html
// These are listed keyed by FEN without move information, so they can be recognized
// directly from the board position, rather than the move history, allowing for easier
// transposition.
var OPENINGS = {
    // 0th level
    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -": "A00a Standard Start Position",

    // 1st level
    "rnbqkbnr/pppppppp/8/8/8/P7/1PPPPPPP/RNBQKBNR b KQkq -": "A00f Anderssen Opening",
    "rnbqkbnr/pppppppp/8/8/P7/8/1PPPPPPP/RNBQKBNR b KQkq a3": "A00e Ware Opening / Meadow Hay",
    "rnbqkbnr/pppppppp/8/8/8/N7/PPPPPPPP/R1BQKBNR b KQkq -": "A00h Durkin Opening / Sodium Attack",
    "rnbqkbnr/pppppppp/8/8/8/2N5/PPPPPPPP/R1BQKBNR b KQkq -": "A00l Van Geet (Dunst) Opening",
    "rnbqkbnr/pppppppp/8/8/8/1P6/P1PPPPPP/RNBQKBNR b KQkq -": "A01 Nimzowitsch-Larsen Attack",
    "rnbqkbnr/pppppppp/8/8/1P6/8/P1PPPPPP/RNBQKBNR b KQkq b3": "A00p Polish Opening / Orangutan",
    "rnbqkbnr/pppppppp/8/8/8/2P5/PP1PPPPP/RNBQKBNR b KQkq -": "A00i Saragossa Opening / Hempel's",
    "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq c3": "A10 English Opening",
    "rnbqkbnr/pppppppp/8/8/8/3P4/PPP1PPPP/RNBQKBNR b KQkq -": "A00j Mieses Opening",
    "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3": "A40a Queen's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/4P3/PPPP1PPP/RNBQKBNR b KQkq -": "A00k Van 't Kruijis Opening",
    "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3": "B00a King's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/5P2/PPPPP1PP/RNBQKBNR b KQkq -": "A00b Barnes Opening / Gedult's",
    "rnbqkbnr/pppppppp/8/8/5P2/8/PPPPP1PP/RNBQKBNR b KQkq f3": "A02 Bird's Opening / Dutch Attack",
    "rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -": "A04 R\u00e9ti Opening",
    "rnbqkbnr/pppppppp/8/8/8/7N/PPPPPPPP/RNBQKB1R b KQkq -": "A00g Amar Opening / Drunken Knights / Ammonia",
    "rnbqkbnr/pppppppp/8/8/8/6P1/PPPPPP1P/RNBQKBNR b KQkq -": "A00t Benko's Opening / Hungarian",
    "rnbqkbnr/pppppppp/8/8/6P1/8/PPPPPP1P/RNBQKBNR b KQkq g3": "A00n Grob's Attack",
    "rnbqkbnr/pppppppp/8/8/8/7P/PPPPPPP1/RNBQKBNR b KQkq -": "A00d Clemenz Opening",
    "rnbqkbnr/pppppppp/8/8/7P/8/PPPPPPP1/RNBQKBNR b KQkq h3": "A00c Desprez Opening / Reagen's Attack",

    // A few common 2nd level responses - not comprehensive! Keep this short.
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6": "B20 Sicilian Defense",
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq -": "B27a Sicilian Defense Main Line",
    "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6": "C20 Open Game / Mutual King's Pawn",
    "rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq d6": "B01a Scandinavian Centre Counter Game",
    "r1bqkbnr/pppppppp/2n5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B00l Nimzowitsch Defense",
    "rnbqkb1r/pppppppp/5n2/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B02a Alekhine Defense",
    "rnbqkbnr/pp1ppppp/2p5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B10a Caro-Kann Defense"

    // TODO: Ajax to load scid.eco from a server optionally, to get deeper into the
    // openings. scid.eco has 20K+ lines, not practical to load into this file.
};


// TODO: library of interesting games, in PGN format. See
// http://www.xs4all.nl/~timkr/records/records.htm and http://www.xs4all.nl/~timkr/ChessTutor/pgnview.htm


/* Global functions for jslint to recognize. TODO: move to objects? */

/*global edit_pgn restore_edit save_pgn reload_pgn load_pgn parse_pgn output_pgn_dict load_ply set_next_back_accesskeys move_link decode_ply encode_ply mv should_promote promote in_check calculate_notations disambiguate_notations calculate_moves computer_move_if_applicable would_check piece_moved unfiltered_moves filtered_moves relative_decode_direction parse_flags nested_flags decode_relative_explicit_move decode_one_parlett without_dupes opposite_color set_turn set_check_message check_repetition load_notations capture_piece notation_from_piece_square forwards_vector move_piece_to_square mark_repeated_moves move_dropped_piece save_fen load_fen clear_board load_starting_position init_board label_board name_pieces algebraic_letter piece_letter2name full_piece_prefix algebraic_piece_prefix figurine_piece_prefix pc_or_offboard pc image_path_for create_piece create_piece_by_letter highlight_moves unhighlight_all filerank2xy xy2filerank xy2descriptive xy2adescriptive short_descriptive sq randint ucfirst AssertException assert enable_document_selection make_move_by_menu populate_make_a_move_list make_vboard realize_vboard*/
 
google.setOnLoadCallback(function() {
// http://o.aolcdn.com/dojo/1.0.0/dojo/cookie.xd.js
// This file is small enough to just include here (without the module provisions)
dojo.cookie=function(_2,_3,_4){var c=document.cookie;if(arguments.length==1){var _6=c.lastIndexOf(_2+"=");if(_6==-1){return null;}var _7=_6+_2.length+1;var _8=c.indexOf(";",_6+_2.length+1);if(_8==-1){_8=c.length;}return decodeURIComponent(c.substring(_7,_8));}else{_4=_4||{};_3=encodeURIComponent(_3);if(typeof (_4.expires)=="number"){var d=new Date();d.setTime(d.getTime()+(_4.expires*24*60*60*1000));_4.expires=d;}document.cookie=_2+"="+_3+(_4.expires?"; expires="+_4.expires.toUTCString():"")+(_4.path?"; path="+_4.path:"")+(_4.domain?"; domain="+_4.domain:"")+(_4.secure?"; secure":"");return null;}}


    // Safari and IE7: Disable text selection to stop interfering with dragging 
    enable_document_selection(false);    

    // Hide address bar. TODO: Get this working
    //setTimeout(function() { window.scrollTo(0, 1); }, 0);

    // Let the games begin
    load_notations();
    label_board();
    init_board();
    init_dnd();

    // test 50 move rule (game from http://www.chessville.com/misc/History/Mad_Aussie_Trivia_Archive_12.htm)
    //load_pgn('[White "Filipowicz,A"]\n[Black "Smederevac,P"]\n[Site "Rubinstein mem 04th Polanica Zdroj (14)"]\n[Date "1966"]\n\n1. e4 e6 2. d3 Ne7 3. g3 c5 4. Bg2 Nbc6 5. Be3 b6 6. Ne2 d5 7. 0-0 d4 8. Bc1 g6 9. Nd2 Bg7 10. f4 f5 11. a3 0-0 12. e5 a5 13. a4 Ba6 14. b3 Rb8 15. Nc4 Qc7 16. Kh1 Nd5 17. Bd2 Rfd8 18. Ng1 Bf8 19. Nf3 Be7 20. h4 h5 21. Qe2 Ncb4 22. Rfc1 Bb7 23. Kh2 Bc6 24. Na3 Ra8 25. Qe1 Rdb8 26. Qg1 Qb7 27. Qf1 Kg7 28. Qh1 Qd7 29. Ne1 Ra7 30. Nf3 Rba8 31. Ne1 Bd8 32. Nf3 Rb8 33. Ne1 Bc7 34. Nf3 Rh8 35. Ng5 Bd8 36. Nf3 Be7 37. Qg1 Bb7 38. Nb5 Raa8 39. Na3 Ba6 40. Qf1 Rab8 41. Nc4 Bd8 42. Qd1 Ne7 43. Nd6 Bc7 44. Qe2 Ng8 45. Ng5 Nh6 46. Bf3 Bd8 47. Nh3 Ng4+ 48. Kg1 Be7 49. Nc4 Nd5 50. Nf2 Bb7 51. Nh3 Bc6 52. Qg2 Rhc8 53. Re1 Rc7 54. Re2 Ra7 55. Ree1 Ra6 56. Re2 Rba8 57. Ree1 R8a7 58. Na3 Ra8 59. Nc4 Nh6 60. Na3 Nf7 61. Nf2 Rd8');

    // test PGN embedded notes
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 {This opening is called the Ruy Lopez.} 3... a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    

     /* Note: chessos generates PGNs with minimal algebraic notation, sometimes, 
      * not always standard algebraic. 4. ... Bb4 should be Bxb4. Need synonym 
      * support in order to read this, or MAN support. 
      *
pgn = load_pgn(
"[Event \"ChesSOS Game\"]\n" + 
"[Site \"http://www.chessos.com\"]\n" + 
"[Date \"2009.03.18\"]\n" + 
"[Round \"-\"]\n" + 
"[White \"Dema9o9ue\"]\n" + 
"[Black \"shellreef\"]\n" + 
"[WhiteElo \"1500\"]\n" + 
"[BlackElo \"1500\"]\n" + 
"[Result \"0-1\"]\n" + 
"[URL \"http://www.chessos.com/p/?m=board" + AMP + "g=15722\"]\n" + 
"\n" + 
"1. b4 e5 2. Nc3 Bb4 3. a3 Bc3 4. dxc3 Nf6 5. h3 O-O 6. f3 d5 \n" + 
"7. e3 Nc6 8. a4 Qd6 9. Ba3 Qd8 10. g4 g5 11. h4 gxh4 12. Rh4 \n" + 
"Ne4 13. fxe4 Qh4 14. Ke2 Bg4 15. Nf3 Qh2 16. Kd3 dxe4 17. Ke4 \n" + 
"f5 18. Kd5 Rad8 19. Ke6 Qh6 \n" + 
"0-1");*/

     /* TODO: support 1.move in addition to 1. move  */
     /* TODO: support [White "Foo"][Black "Bar"], without newlines. Ignore whitespace. */
     /*
     pgn = load_pgn("[Event \"Berlin\"]\n" + 
"[Site \"?\"]\n" + 
"[Date \"1842\"]\n" + 
"[Round \"?\"]\n" + 
"[White \"Hanstein\"]\n" + 
"[Black \"Von der Lasa\"]\n" + 
"[Result \"1-0\"]\n" + 
"\n" + 
"1.e4 e5 2.f4 exf4 3.Nf3 g5 4.Bc4 Bg7 5.d4 d6 6.O-O h6 7.c3 Ne7 8.h4 Ng6\n" + 
"9.h5 Ne7 10.g3 fxg3 11.Nxg5 hxg5 12.Bxf7+ Kd7 13.Bxg5 c6 14.e5 d5\n" + 
"15.e6+ Kc7 16.Bf4+ Kb6 17.Qb3+ Ka6 18.Qa3+ Kb6 19.b4 a5 20.Bxb8 Nf5\n" + 
"21.Rxf5 Qh4 22.Qb2 Rxb8 23.b5 Qe4 24.Na3 Qxf5 25.bxc6+ Kc7 26.Nb5+\n" + 
"Kxc6 27.Na7+ Kc7 28.Nb5+ Kd8 29.Rf1 Qh3 30.e7+ Kxe7 31.Qa3+ Kd8\n" + 
"32.Qd6+ Qd7 33.Qb6+ Ke7 34.Re1+ Kxf7 35.Qg6+ Kg8 36.Re8+ Qxe8\n" + 
"37.Qxe8+ Kh7 38.Qg6+ Kg8 39.Qd6 Ra8 40.Qxd5+ Kh7 41.Qe4+ Kg8\n" + 
"42.Qe8+ Kh7 43.Qg6+ Kg8 44.Nc7 Ra6 45.Nxa6 bxa6 46.h6 Rxh6 47.Qe8+\n" + 
"Bf8 48.Qxc8 Kf7 49.Kg2 Bd6 50.Qb7+ Ke8 51.Qc6+ Kf8 52.c4 Rf6 53.c5\n" + 
"Rf2+ 54.Kg1 Bf4 55.Qf6+ Ke8 56.d5 Kd7 57.Qf7+ Kc8 58.Qe8+ Kc7\n" + 
"59.Qe7+ Kb8 60.c6 1-0");*/


});

// PGN (PORTABLE GAME NOTATION) FUNCTIONS

// Load the chess notations into the input/output notation select boxes
function load_notations()
{
    var menu = dojo.byId("output_notation");

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var name = AVAILABLE_NOTATIONS[notation];

            menu.appendChild(dojo.create("option", {value:notation, innerHTML:name}));
        }
    }

    menu.selectedIndex = 0;
}

// Open a mail message with a link to the board state
function email_board()
{
    var to, subject, body, url, dots, link, link_text, ply, ply_info;
    
    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fullmove_number) - 1;
    ply_info = decode_ply(ply);

    to = "shellreef@gmail.com";
    subject = "Chess game";
    dots = ply_info.color ? (ply_info.color === "black" ? "... " : " ") : "";

    link = dojo.byId("copyable_link").href;
    link_text = GAME_STATE.made_moves[ply] ? GAME_STATE.made_moves[ply].notations[form_value("output_notation")] : "move";
    // Note: IE ActiveXObject for Outlook: http://www.webdeveloper.com/forum/showthread.php?t=176548
    // Got an automation error when I tried it, but it could supposedly allow HTML bodies on Windows
    //body = ply_info.fullmove_number + ". " + dots + '<a href="' + link + '">' + link_text + '</a>';
    // Plain text
    body = ply_info.fullmove_number + ". " + dots + link_text + " <" + link + ">";

    url = "mailto:" + encodeURIComponent(to) + 
        "?subject=" + encodeURIComponent(subject) + 
        "&body=" + encodeURIComponent(body);
    window.open(url);
}

// Make the PGN content editable (not to be confused with edible).
var ORIGINAL_UI_HTML;
function edit_pgn()
{
    var game_ui = dojo.byId("game_ui");

    ORIGINAL_UI_HTML = game_ui.innerHTML;

    game_ui.innerHTML = "<textarea id='edited_pgn' name='edited_pgn' cols='80' rows='35'>" + save_pgn().escapeHTML() + 
        "<\/textarea>" + 
        "<button type='button' name='ok' accesskey='o' " + 
        "onclick='reload_pgn()'>OK<\/button>" +
        "<button type='button' name='cancel' onclick='restore_edit()' accesskey='x'>Cancel<\/button>";

    dojo.byId("edited_pgn").focus();
}

// Restore the game interface, removing the edit area.
function restore_edit()
{
    dojo.byId("game_ui").innerHTML = ORIGINAL_UI_HTML;
}

// Return a string of color-coded captured piece codes, or null if none.
function export_captured()
{
    var captured = "";
    var captured_count = 0;
    for (var i = 0; i < GAME_STATE.captured.white.length; i += 1) {
        var p = GAME_STATE.captured.white[i];
        captured += color_piece_prefix(p);
        captured_count += 1;
    }
    for (i = 0; i < GAME_STATE.captured.black.length; i += 1) {
        var p = GAME_STATE.captured.black[i];
        captured += color_piece_prefix(p);
        captured_count += 1;
    }
    if (captured_count) {
        return captured;
    } else {
        return null;
    }
}


// Import a color-coded string of captured pieces from export_captured() into GAME_STATE
function import_captured(captured)
{
    for (var i = 0; i < captured.length; i += 1) {
        // TODO: support X(...) piece codes
        var letter = captured.substr(i, 1);
        var decoded_piece = decode_piece_letter(letter);
        //console.log(letter,decoded_piece);
        GAME_STATE.captured[decoded_piece.color].push(decoded_piece);
    }
}

// Export game as PGN.
function save_pgn()
{
    var pgn = "", dict, captured;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
  
    // PGN header information
    dict = {};
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var elt = dojo.byId("PGN_" + tag);

        if (elt.visible()) {
            dict[tag] = elt.innerHTML;
        }
    }

    // Non-standard: captured pieces
    captured = export_captured();
    if (captured) {
        dict.Captured = captured;
    }

    // Non-standard: current board state. The standard tags are FEN and SetUp, for starting position only.
    dict.CurrentFEN = active_fen();

    // Generate move text (not in a tag) 
    var move_text = "";
    var other_move_texts = {};
    for (var ply = 1; ply < GAME_STATE.made_moves.length; ply += 1) {
        var made = GAME_STATE.made_moves[ply];
        if (!made) {
            // Missing move, for one reason or another. Game started late?
            continue;
        }

        var ply_info = decode_ply(ply);

        if (ply_info.color === "white") {
            move_text += ply_info.fullmove_number + ". ";
        }
        move_text += made.notations[EXPORT_NOTATIONS[0]];
        move_text += " ";

        for (var i = 1; i < EXPORT_NOTATIONS.length; i += 1) {
            var notation = EXPORT_NOTATIONS[i];
            if (!other_move_texts[notation]) {
                other_move_texts[notation] = [];
            }
            other_move_texts[notation][ply] = made.notations[notation];
        }
    }
 
    // Alternate moves, in tag
    for (notation in other_move_texts) {
        if (other_move_texts.hasOwnProperty(notation)) {
            var text = "";
            for (ply = 1; ply < other_move_texts[notation].length; ply += 1) {
                text += other_move_texts[notation][ply] + " ";
            }

            dict["Moves_" + notation] = text;
        }
    }

   
    pgn = output_pgn_dict(dict);

    pgn += "\n";
    pgn += move_text;

   
    return pgn;
}

// Reload PGN after editing it.
function reload_pgn()
{
    var pgn = form_value("edited_pgn");

    restore_edit();

    load_pgn(pgn);
}

// Load Portable Game Notation data
// TODO: support a tag for captured pieces, and tags for FEN at each move so don't need to compute
function load_pgn(pgn)
{
    var games = parse_pgn(pgn);
    var game;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
    var time_started = new Date().getTime();

    // TODO: UI to list all games in a PGN and pick one to load, move out parsing from this function
    assert(games.length === 1,
            "load_pgn(" + pgn + "): multiple games (" + games.length + ") found, but only one can be loaded at a time");

    game = games[0];

    // Header
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var node = dojo.byId("PGN_" + tag);

        assert(node, "load_pgn(" + pgn + "): no element for tag " + tag);

        if (game[tag] && game[tag].substr(0, 1) !== "?") {
            var value = game[tag];

            node.style.display = "";

            node.innerHTML = value;

            $$(".show_" + tag).invoke("show");
        } else {
            node.style.display = "none";
            $$(".show_" + tag).invoke("hide");
        }
    }

    // Starting position
    load_fen(game.FEN);
    GAME_STATE.position_after[0] = game.FEN;

    // Captured pieces
    if (game.Captured) {
        import_captured(game.Captured);
        update_captured_piece_images();
    }


    // Alternate notations for moves given in tags
    var other_notations = [];
    for (i = 0; i < EXPORT_NOTATIONS.length; i += 1) {
        var not = EXPORT_NOTATIONS[i];
        if (game["Moves_" + not]) {
            var ns = game["Moves_" + not].split(" ");

            for (var j = 0; j < ns.length; j += 1) {
                var ply = j + 1;
                if (!other_notations[ply]) {
                    other_notations[ply] = {};
                }
                other_notations[ply][not] = ns[j];
            }
        }
    }

    // Movetext given in SAN
    for (ply = 1; ply < game.moves.length; ply += 1) {
        var move = game.moves[ply];

        var others = other_notations[ply] || {};
        others.SAN = move;

        if (others && others.raw) {
            // Fast move
            // TODO: XXX: Use mv() but without calculate_moves()
            //mv(others.raw, true, others);
            var dr = decode_raw_move(others.raw);
            do_virtual_move(dr.piece, dr.move);
        } else {
            //console.log("slow move",move);
            mv(move, true, others);
        }
    }

    // TODO: remove
    if (others && others.raw) {
        var last_ply = decode_ply(ply);
        set_turn(last_ply.color);
    }

    realize_vboard();
    populate_make_a_move_list();
    show_move_history();

    var time_took = new Date().getTime() - time_started;
    if (window.console) {
        alert("load_pgn took " + time_took + " ms");
    }
}

// Parse PGN into an array of dictionaries, one dictionary per game.
function parse_pgn(pgn)
{
    var dict = {move_text: ""};
    var dicts = [dict];

    // Parse headers into dictionaries
    for (var i = 0; i < pgn.length; i += 1) {
        var ch = pgn.charAt(i);

        // Tag
        if (ch === "[") {
            var key, start, quoted;

            // Read tag key name
            for (i += 1, start = i; pgn.charAt(i) !== " "; i += 1) {
                assert(i < pgn.length && pgn.charAt(i) !== "]",
                    "parse_pgn(" + pgn + "), at " + i + ", tag without space, like [foo] instead of [foo bar]");
            }
            key = pgn.substring(start, i);

            // Read value, terminated by end of tag. It can be quoted, which
            // allows for the value to contain the ] character.
            quoted = false;
            for (i += 1, start = i; !quoted ? pgn.charAt(i) !== "]" : true; i += 1) {
                if (pgn.charAt(i) === '"') {
                    quoted = !quoted;
                }

                assert(i < pgn.length, 
                    "parse_pgn(" + pgn + "), at " + i + ", tag value for " + key + " without ]");
            }
            value = pgn.substring(start, i);
            // Dequote value, as the quotes were only there for including ] characters
            if (value.charAt(0) === '"' && value.charAt(value.length - 1) == '"') {
                value = value.substr(1, value.length - 2);
            }

            if (dict[key]) {
                // Duplicate key means this is a new game
                dict = {move_text: ""};
                dicts.push(dict);
            }
            dict[key] = value;

        } else if (ch === "\n") {
            dict.move_text += " ";
        } else {
            dict.move_text += ch;
        }
    }

    // Process each game, parsing move text
    for (var k = 0; k < dicts.length; k += 1) {
        dict = dicts[k];

        // Standard FEN
        if (!dict.FEN) {
            dict.FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
            dict.SetUp = 1;
        }

        // Parse move text
        var tokens = dict.move_text.split(" ");
        delete dict.move_text;  // not for anyone but this function
        var fullmove_number, outcome, moves = [], color = "white";
        var in_comment = false;

        for (i = 0; i < tokens.length; i += 1) {
            var token = tokens[i];

            if (token === "") {
                // Skip
            } else if (in_comment) {
                if (token.substr(token.length - 1) === "}") {
                    in_comment = false;
                }
                // TODO: support annotations
            } else if (token.substring(token.length - 1) === ".") {
                fullmove_number = parseInt(token, 10);

                // 3... means black moves
                if (token.substring(token.length - 3) === "...") {
                    color = "black";
                } else {
                    color = "white";
                }

            } else if (token === "1-0") {
                outcome = "White wins";
            } else if (token === "0-1") {
                outcome = "Black wins";
            } else if (token === "1/2-1/2") {
                outcome = "Draw";
            } else if (token === "*") { 
                outcome = "(In progress)";
            } else if (token.substr(0, 1) === "{") {
                in_comment = true;
            } else {
                // Move 
                
                var ply = encode_ply(color, fullmove_number);
                // TODO: handle #, + for checkmate and check, part of move
                moves[ply] = token;

                // white, then black
                if (color === "white") {
                    color = opposite_color(color);
                } 
            }
        }

        dict.outcome = outcome;
        dict.moves = moves;
    }

    return dicts;
}

// Export a PGN tag dictionary to PGN format, opposite of parse_pgn.
function output_pgn_dict(dict)
{
    var pgn, quoted_value;

    pgn = "";
    // TODO: Use a hash table, avoid for..in
    for (var key in dict) {
        if (dict.hasOwnProperty(key)) {
            var value = dict[key];

            // TODO: unparenthetize, uncommaify, etc. .. or just set attributes
            // to exactly what we want in load_pgn(), then fetch it.
            // TODO: rules for quoting values?
            quoted_value = '"' + value + '"';
            pgn += "[" + key + " " + quoted_value + "]\n";
        }
    }

    return pgn;
}


// Load a move by ply. Used to navigate to past moves.
function load_ply(ply)
{
    // TODO: would be tool to be able to also decode
    // color + fullmove number, for ease of human use.
    // Make "1." be ply 1, and "1..." or "1. ..." be ply 2.
    // Maybe make it a user function, go()
    
    //$$("a.active_move").invoke("removeClassName", "active_move");
    dojo.query("a.active_move").removeClass("active_move");

    load_fen(GAME_STATE.position_after[ply], true);

    dojo.byId("ply_" + ply).addClass("active_move");

    set_next_back_accesskeys(ply);
}

// Setup accesskeys for next and back given the current ply.
function set_next_back_accesskeys(ply)
{
    dojo.query("a.accessible_move").forEach(function(x) {
            dojo.removeClass(x, "accessible_move");
            x.removeAttribute("accesskey");
        });

    dojo.query("a#ply_" + (ply + 1)).forEach(function(x) {
            x.setAttribute("accesskey", ".");       // ctrl+option+.
            dojo.addClass(x, "accessible_move");
        });
    
    dojo.query("a#ply_" + (ply - 1)).forEach(function(x) {
            x.setAttribute("accesskey", ",");       // ctrl+option+,
            dojo.addClass(x, "accessible_move");
        });
}

// Make a link to a move, click it and it loads the board after it.
function move_link(ply, text)
{
    var extra;

    // ctrl+option+/ (at least on Safari 4) to go to initial position
    if (ply === 0) {
        extra = ' accesskey="/"';
    } else {
        extra = "";
    }

    return '<a' + extra + ' id="ply_' + ply + '" class="active_move" ' +
        'href="#" onclick="load_ply(' + 
            ply +
        ')">' + text + "<\/a>";
}

// Decode ply number to color and fullmove number.
function decode_ply(ply)
{
    var color, fullmove_number;

    color = (ply % 2 === 1) ? "white" : "black";
    fullmove_number = Math.ceil(ply / 2);

    return {color: color, fullmove_number: fullmove_number};
}

// Encode color and fullmove number back to ply. Ply is useful for 
// arrays of moves, since it is one integer, instead of integer+color.
function encode_ply(color, fullmove_number)
{
    var ply;

    ply = fullmove_number * 2;
    ply -= (color === "white" ? 1 : 0);

    return ply;
}

//// USER FUNCTIONS

// Make a move using any notation. Useful to use for moving within the JavaScript
// console (Develop -> Show Error Console in Safari), if you prefer CLI over GUI,
// and computer moves also use this function. 
// If is_not_immediate is true, then the UI is not updated after the move; useful
// for quickly making many moves without UI slowness.
// notations is for specifying move notations of the raw move
// Examples:
// mv("e4")
// mv("P-K4")
// mv("/e2/e4/P", false, {SAN:"e4", descr:"P-K4"})
function mv(alg_move, is_not_immediate, notations)
{
    var piece_square, piece, square, is_raw;

    if (!alg_move) {
        assert(VALID_MOVE_NOTATIONS, "mv(" + alg_move + "): called with VALID_MOVE_NOTATIONS false");
        return own_properties(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    }

    if (alg_move.substr(0, 1) === "/") {
        // Raw move notation, parsed directly, no legal move checking. For
        // loading in-progress games quickly, as no move calculation is
        // needed.
        piece_square = decode_raw_move(alg_move);
        dojo.mixin(piece_square, {notations:notations});
        is_raw = true;
    } else {
        // For ordinary notations, find move in precalculated notations. 
        piece_square = find_legal_move(alg_move);
    }

    assert(piece_square, "mv(" + alg_move + "): illegal move");

    // TODO: do some moving animation, optionally (make two functions)
 
    // There is only one choice..
    var promote_to = piece_square.move.promote_to;
    var choices = {};
    choices[promote_to] = piece_square;

    execute_move(promote_to, choices, false, !is_not_immediate, is_raw);
}

// Find a legal move, given the move text, precalculated already with
// calculate_notations().
function find_legal_move(text)
{
    var piece_square;

    // Accept digits, but prefer the letter oh.
    text = text.replace("0-0-0", "O-O-O").replace("0-0", "O-O");

    // Check/mate indicators not part of move.
    text = text.replace("+", "").replace("#", "");

    // Promotions, e1=Q, not needed, e1Q is fine
    text = text.replace("=", "")

    // Prefer these move notations, in this order.
    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            if (notation === "descr" || notation === "adesc") {
                text = text.replace(/Kt/g, "N");
            }

            piece_square = VALID_MOVE_NOTATIONS[notation][text];

            if (piece_square) {
                // Found one.
                break;
            }
        }
    }

    // Allow alternate, non-canonical forms. These are overly-descriptive
    // notations for ambiguous move notation formats. For example, in SAN
    // the canonical form of a particularly bad opening move is Nh3, but 
    // it can also be written as N1h3 or Ngh3 or Ng1h3, even though this longer
    // form is only supposed to be used when Nh3 is ambiguous, and it is not
    // standard. But you might see it, so allow it.
    if (!piece_square) {
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                if (notation === "descr" || notation === "adesc") {
                    text = text.replace(/Kt/g, "N");
                }

                piece_square = ALT_MOVE_NOTATIONS[notation][text];

                if (piece_square) {
                    //console.log("Warning: non-canonical move notation: ", notation);
                    break;
                }
            }
        }
    }

    if (piece_square) {
        // Find move in all other notations
        // TODO: avoid calling get_notations() which loops; the answer should be above
        piece_square.notations = get_notations(piece_square.piece,
                piece_square.square, 
                piece_square.move.promote_to)[piece_square.move.promote_to].notations;
    }

    return piece_square;
}
 
//// SPECIAL MOVE FUNCTIONS

// Return whether a piece should be promoted
function should_promote(piece)
{
    var square;

    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    square = piece.square;

    // Is it on the last rank?
    if (GAME_STATE.active_color === "white") {
        return square.y === 8;    // 8th rank
    } else if (GAME_STATE.active_color === "black") {
        return square.y === 1;    // 1st rank
    } else {
        assert(false, "should_promote(" + piece + "): unknown active color");
    }
}

// Return whether the move would cause the piece to promote
function would_promote(piece, move)
{
    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    // Will it be on the last rank?
    if (GAME_STATE.active_color === "white") {
        return move.y === 8;    // 8th rank
    } else if (GAME_STATE.active_color === "black") {
        return move.y === 1;    // 1st rank
    } else {
        assert(false, "would_promote(" + piece + "): unknown active color");
    }
}


// Finish up a promotion move.
function promote(piece, square, type, notation, is_immediate)
{
    // TODO: Puff out, or fade in from new to old piece. Is there an
    // effect that can fade from one image to another? LikE IE page transitions.
    // http://sachiniscool.blogspot.com/2006/01/implementing-page-transitions-in.html
    // ... except when changing images. Safari has CSS animations.
    // or try CSS transitions, see CSS at the top of this document.
    //piece.style.background = image_path_for(promotes_to, piece.color);
    // or TODO: create another img, same place same time, change opacity to reveal it
    // but this leaves the old image behind..
    piece.src = image_path_for(type, piece.color);
    piece.type = type;

    dojo.byId("promote_container").hide();

    // TODO: call with a correct tieback. Re-find it?
    var tieback = get_notations(piece, square, type);

    finish_up_move(tieback, is_immediate, type);
}

// Change a piece to whatever it promotes to.
function ask_to_promote(piece, tieback, is_immediate)
{
    var element, container, choice;

    realize_vboard();

    // Clear previous container
    var container = dojo.byId("promote_container");

    while(container.firstChild) {
        container.removeChild(container.firstChild);
    }

    // Create clickable promotion pieces
    for (var type in tieback) {
        if (tieback.hasOwnProperty(type)) {
            // The move the user selected that will be made
            var notation = tieback[type].notations[form_value("output_notation")];

            //element = create_piece(GAME_STATE.active_color, type);
            element = dojo.create("img", {src:image_path_for(type, piece.color), piece_type:type, notation:notation});
            element.onclick = function() {
                // Finishes up the move
                promote(piece, tieback[type].square, dojo.attr(this, "piece_type"), dojo.attr(this, "notation"), is_immediate);
            };
            container.appendChild(element);
        }
    }

    container.show();

}

//// VALID MOVE FUNCTIONS
//
// TODO: step through moves, like on http://www.pgnview.com/ (jspgnviewer) as used on http://www.zenpawn.com/chessblog/

// Check if any royal pieces of victim_color are being attacked; that is:
// victim_color's royal pieces could be captured after any of all_moves.
function in_check(victim_color, all_moves)
{
    var royals;
    var attacked = false;
    var virtual = true;

    // Pieces that can't be captured and need to move if attacked
    if (virtual) { 
        royals = [];
        for (var x = 1; x <= FILE_MAX; x += 1) {
            for (var y = 1; y <= RANK_MAX; y += 1) {
                var piece;

                piece = VBOARD[x][y].piece;

                if (piece && PIECE_TYPES[piece.type].royal) {
                    royals.push(piece);
                }
            }
        }
    } else {
        royals = $$("img.royal." + victim_color);
    }

    // Attack the royal pieces?
    for (var filerank in all_moves) {
        if (all_moves.hasOwnProperty(filerank)) {
            var moves = all_moves[filerank];

            moves.each(function(move) {
                royals.each(function(royal) {
                    var square = royal.square;

                    if (move.x === square.x && move.y === square.y) { 
                        // Being attacked!
                        //console.log("CHECKED BY",piece,filerank,xy2filerank(move.x, move.y));
                        attacked = true;
                    }
                });
            });
        }
    }

    return attacked;
}

// Calculate and save the move notations for a move.
// Note: only do this if not hypothetical.
function calculate_notations(color, piece, moves, starting_filerank, ps, square_from)
{
    moves.each(function(move) {
        var square = VBOARD[move.x][move.y];

        // Building blocks
        var dest_filerank = xy2filerank(move.x, move.y);        // e4
        var dest_file = dest_filerank.substr(0, 1);             // e
        var dest_rank = dest_filerank.substr(1, 1);             // 4
        // starting_filerank (passed in as parameter)           // e2
        var starting_file = starting_filerank.substr(0, 1);     // e
        var starting_rank = starting_filerank.substr(1, 1);     // 2
        var descriptive_origin = xy2descriptive(color, filerank2xy(starting_filerank));             // K2
        var adescriptive_origin = xy2adescriptive(color, filerank2xy(starting_filerank));           // e2
        var descriptive_dest = xy2descriptive(color, move);                                         // K4
        var adescriptive_dest = xy2adescriptive(color, move);                                       // e4
        var descriptive_dest_file = descriptive_dest.substr(0, descriptive_dest.length - 1);        // K
        var descriptive_dest_rank = descriptive_dest.substr(descriptive_dest.length - 1);           //  4
        var descriptive_origin_file = descriptive_origin.substr(0, descriptive_origin.length - 1);  // K
        var descriptive_origin_rank = descriptive_dest.substr(descriptive_dest.length - 1);         //  4
        //var adescriptive_dest_file = adescriptive_dest.substr(0, 1);                              // e
        //var adescriptive_dest_rank = adescriptive_dest.substr(1, 1);                              //  4
        var adescriptive_origin_file = adescriptive_origin.substr(0, 1);                            // e
        var adescriptive_origin_rank = adescriptive_dest.substr(1, 1);                              //  4

        var capture_x;                  // x/blank
        var capture_slash;              // slash/blank
        var capture_or_dash;            // x/-
        var captured_letter = "";       // capital letter of piece, P for pawn, etc. or blank
        var captured_colon_letter = ""; // colon if captured, then piece letter if not pawn
        var captured_piece = move.capture; 

        var promote_or_blank = "";      // Q/blank
        var promote_figurine = "";      // ♕/blank
        var promote_iccf = "";          // 1/blank
        var promote_paren = "";         // (Q)/blank

        if (move.promote_to) {
            var promote_piece = {type:move.promote_to};

            promote_or_blank = full_piece_prefix(promote_piece);
            promote_figurine = figurine_piece_prefix(GAME_STATE.active_color, promote_piece);
            promote_iccf = PIECE_TYPES[move.promote_to].iccf_number;
            promote_paren = "(" + promote_or_blank + ")";
        }

        if (captured_piece) {
            capture_x = "x";
            capture_slash = "/";
            capture_or_dash = "x";
            captured_letter = full_piece_prefix(captured_piece);
            captured_colon_letter = ":" + (captured_letter === "P" ? "": captured_letter);
        } else {
            capture_or_dash = "-";
            capture_x = "";
            capture_slash = "";
            captured_letter = "";
            captured_colon_letter = "";
        }


        // Compute notations: SAN, FAN, MAN, LAN, RAN, CRAN and also descriptive.
        // But first check if the move text was overridden in decode_one_parlett(), for the
        // notations where it can be overridden. Not all have special notation for castling.
        if (move.notation_override) {
            // Override notation; used for special moves (castling)
            // Note: not all notations have special notation for castling.
            ps.SAN.push([piece, square, [move.notation_override], move]);
            ps.LAN.push([piece, square, [move.notation_override], move]);
            ps.MAN.push([piece, square, [move.notation_override], move]);
            ps.RAN.push([piece, square, [move.notation_override], move]);
            ps.CRAN.push([piece, square, [move.notation_override], move]);
            ps.descr.push([piece, square, [move.notation_override], move]);
            ps.adesc.push([piece, square, [move.notation_override], move]);
        } else {
            var algs, figurine_prefix, algebraic_prefix, piece_letter, minimal_algs;

            if (capture_x === "x" && piece.type === "pawn") {
                // Pawn captures begin with file of pawn.
                algs = [starting_file + capture_x + dest_filerank]; // ?xd5
            } else {
                algs = [
                    capture_x + dest_filerank,                      // ?f3
                    starting_file + capture_x + dest_filerank,      // ?gf3
                    starting_rank + capture_x + dest_filerank,      // ?1f3
                    starting_filerank + capture_x + dest_filerank   // ?g1f3
                ];
            }

            piece_letter = full_piece_prefix(piece);               // P, N, etc.
            algebraic_prefix = algebraic_piece_prefix(piece);      // blank, N, etc.
            figurine_prefix = figurine_piece_prefix(color, piece); // ♟, ♞, ♙, ♘, etc.

            ps.SAN.push([piece, square, algs.map(function(a) { return algebraic_prefix + a + promote_or_blank; }), move]);  // N??
            ps.FAN.push([piece, square, algs.map(function(a) { return figurine_prefix + a + promote_figurine; }), move]);   // ♘??

            // Minimal notation, supposedly used in Informant
            minimal_algs = [
                algebraic_prefix + dest_filerank + promote_or_blank,                      // ?f3
                algebraic_prefix + starting_file + dest_filerank + promote_or_blank,      // ?gf3
                algebraic_prefix + starting_rank + dest_filerank + promote_or_blank,      // ?1f3
                algebraic_prefix + starting_filerank + dest_filerank + promote_or_blank]; // ?g1f3
            ps.MAN.push([piece, square, minimal_algs, move]);

            ps.LAN.push([piece, square, [algebraic_prefix + starting_filerank + 
                    capture_or_dash + dest_filerank + promote_or_blank], move]);

            // TODO: Find out for sure how promotions are shown in RAN
            ps.RAN.push([piece, square, [algebraic_prefix + starting_filerank + capture_or_dash + 
                captured_letter + dest_filerank + promote_or_blank], move]);

            // Best online documentation I could find on CRAN: 
            //  http://main.uschess.org/forums/viewtopic.php?f=2&t=1428&start=30
            // Always gives origin square filerank, then only non-redundant file/rank of dest square
            // Uses ':' for capture instead of 'x', and piece letter isn't given if pawn
            // Full description will have to wait until I receive the book
            //  http://www.amazon.com/Play-Stronger-Chess-Examining-Chess960/dp/0977452107
            ps.CRAN.push([piece, square, [
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_filerank + promote_or_blank,  // Rd3:d7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_file + promote_or_blank,      // Rd3:7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_rank + promote_or_blank       // Rd3:e
                ], move]);

            // English descriptive notation
            // TODO: 
            // - alt_letter (Kt for knight instead of N) and
            //   alt_descriptive_dest (QKt1 for b1 instead of QN1) - currently, Kt is preprocessed to N in mv()
            //   would be nice to have an option to prefer Kt over N, for using old books (though N/Kt would be synonyms)
            // - allow slashes in addition to parenthesises, or maybe not, since would be shorter and therefore preferred
 
            // Descriptive vs algebraic is like imperial vs. metric units, in some ways. Descriptive
            // is from each player's perspective, so 1. P-K4 P-K4 is easily recognizable as the same
            // move from both players, more readily than 1. e4 e5. And 2. PxP PxP more clearly shows
            // a pawn trade than 10. exd5 cxd5. Smith notation shows the latter, too, but the coordinates
            // are still not symmetric from each player's perspective. I like descriptive. Problem is
            // just that it needs to be disambiguated often, algebraic less so.
            // This paper mentions how a book on openings for black showed all of the diagrams from
            // white's perspective: http://www.castlelong.com/essay/Essay_HSym_fd47b_Doc_Prn.PDF
            // -- it discusses symmetric figurines, interesting. Although it says algebraic is superior.
          
            var piece_name = piece.descriptive_name;
            var short_piece_name = short_descriptive(piece_name);
            var short_descriptive_dest = short_descriptive(descriptive_dest_file) + descriptive_dest_rank;

            var piece_aname = piece.adescriptive_name;

            if (capture_or_dash === "-") { 
                // non-capturing move
                ps.descr.push([piece, square, [
                    piece_letter + capture_or_dash + short_descriptive_dest + promote_paren,        // P-B4
                    piece_name + capture_or_dash + short_descriptive_dest + promote_paren,          // QBP-B4
                    short_piece_name + capture_or_dash + short_descriptive_dest + promote_paren,    // BP-B4
                    piece_letter + capture_or_dash + descriptive_dest + promote_paren,              // P-QB4
                    short_piece_name + capture_or_dash + descriptive_dest + promote_paren,          // BP-QB4
                    piece_name + capture_or_dash + descriptive_dest + promote_paren,                // QBP-QB4

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + descriptive_dest + promote_paren,      // P(K2)-K4
                    piece_letter + "(" + descriptive_origin_rank + ")" + capture_or_dash + descriptive_dest + promote_paren, // P(2)-K4
                    piece_letter + "(" + descriptive_origin_file + ")" + capture_or_dash + descriptive_dest + promote_paren  // P(K)-K4

                // Must uniq() the array, since some of the notations actually appear twice
                // in the list above, and disambiguate_moves() will delete both since it'll think they
                // are ambiguous. This would have occurred when piece_name === short_piece_name, that is,
                // for KP, QP, K, and Q. 
                ].uniq(), move]);


                ps.adesc.push([piece, square, [
                    piece_letter + capture_or_dash + adescriptive_dest + promote_paren,             // P-c4
                    piece_aname + capture_or_dash + adescriptive_dest + promote_paren,              // cP-c4
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + adescriptive_dest + promote_paren,       // P(c2)-c4
                    piece_letter + "(" + adescriptive_origin_rank + ")" + capture_or_dash + adescriptive_dest + promote_paren,  // P(2)-c4
                    piece_letter + "(" + adescriptive_origin_file + ")" + capture_or_dash + adescriptive_dest + promote_paren   // P(c)-c4
                ].uniq(), move]);
            } else if (capture_or_dash === "x") {
                var captured_name = captured_piece.descriptive_name;
                var short_captured_name = short_descriptive(captured_name);
                
                var captured_aname = captured_piece.adescriptive_name;

                // capture
                ps.descr.push([piece, square, [
                    // Note: a permutation function would be handy here
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + short_captured_name + promote_paren,       // PxBP
                    piece_letter + capture_or_dash + captured_name + promote_paren,             // PxQBP
                    short_piece_name + capture_or_dash + captured_letter + promote_paren,       // NPxP
                    short_piece_name + capture_or_dash + short_captured_name + promote_paren,   // NPxBP
                    short_piece_name + capture_or_dash + captured_name + promote_paren,         // NPxQBP
                    piece_name + capture_or_dash + captured_letter + promote_paren,             // QNPxP
                    piece_name + capture_or_dash + short_captured_name + promote_paren,         // QNPxBP
                    piece_name + capture_or_dash + captured_name + promote_paren,               // QNPxQBP

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_name + promote_paren,    // P(K4)xQP
                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren,  // P(K4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren,    // PxP(Q4)
                    piece_name + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren       // KPxP(Q4)
                ].uniq(), move]);

                ps.adesc.push([piece, square, [
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + captured_aname + promote_paren,            // PxcP
                    piece_aname + capture_or_dash + captured_letter + promote_paren,            // bPxP
                    piece_aname + capture_or_dash + captured_aname + promote_paren,             // bPxcP

                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_aname + promote_paren,  // P(b4)xcP
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren, // P(b4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren,   // PxP(c5)
                    piece_aname + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren     // bPxP(c5)
                ].uniq(), move]);
            } else {
                assert(false, "calculate_notations: " + capture_or_dash + " is not - or x");
            }
        }

        // Coordinate notation - least descriptive notation possible, but must include promotion to be non-ambiguous
        ps.coord.push([piece, square, [starting_filerank.toUpperCase() + "-" + dest_filerank.toUpperCase() + promote_paren], move]);

        // ICCF numeric notation
        var starting_xy = filerank2xy(starting_filerank);
        var starting_x = starting_xy[0], starting_y = starting_xy[1];
        ps.ICCF.push([piece, square, [starting_x + "" + starting_y + "" + move.x + "" + move.y + promote_iccf], move]);

        // Smith notation, reversible, non-ambiguous: https://www.chessclub.com/chessviewer/smith.html
        var smith_capture_letter;
        if (move.smith_castle) {
            // c = short castle, C = long castle
            smith_capture_letter = move.smith_castle;
        } else if (move.en_passant_capture) { 
            // E = en passant capture
            smith_capture_letter = "E";
        } else if (move.capture) {
            // pnbrqk = captured respective piece. This is what makes it reversible.
            smith_capture_letter = captured_letter.toLowerCase();
        } else {
            smith_capture_letter = "";
        }
        ps.smith.push([piece, square, [starting_filerank + dest_filerank + smith_capture_letter + promote_or_blank], move]);
       
        // Should NEVER need to lookup raw notation, but calculate here so it is treated like all the others
        ps.raw.push([piece, square, [make_raw_notation(piece, move)], move]);
    });

    // TODO: check for cross-notation ambiguities. Inputs are tested in the order of
    // AVAILABLE_NOTATIONS, but a notation that matches two different moves in
    // two different notations, if it exists, is sure to cause trouble!
}

// Used for sorting a function by length
function by_length(x, y) 
{ 
    return x.length - y.length; 
}

// Given a list of all valid move notations, remove the ambiguous 
// (Nf3 and Nf3, remove both) overly-disambiguated (Ng1f3 if Ngf3
// or N1f3 is not ambiguous).
function disambiguate_notations(notations)
{
    var freq_count = {};
    var canonical_notations = {};
    var synonymous_notations = {};
    var piece, square, same_moves, abs_move;

    // Count occurrences of each notation text, so know if is ambiguous.
    for (var i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];

        for (var j = 0; j < same_moves.length; j += 1) {
            var move = same_moves[j];

            if (!freq_count[move]) {
                // Store index so can delete if is a dupe
                freq_count[move] = [[i, j]];
            } else {
                freq_count[move].push([i, j]);
            }
        }
    }

    // Delete ambiguous moves (or actually, replace with 'undefined')
    for (notation in freq_count) {
        if (freq_count.hasOwnProperty(notation)) {
            var locations = freq_count[notation];

            if (locations.length > 1) {
                for (var k = 0; k < locations.length; k += 1) { 
                    var i = locations[k][0], j = locations[k][1];
                    delete notations[i][2][j];
                }
            }
        }
    }

    // Find shortest notation text
    for (i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];
        var shortest, synonyms;

        // Remove undefined elements
        same_moves = same_moves.compact();
       
        // Choose shortest (now unambiguous) notation
        // Could also do: min_length = same_moves.pluck("length").min();, then partition
        // Rather, sort by length, ascending.
        same_moves.sort(by_length);

        // The shortest, non-ambiguous move is canonical. But also keep the
        // synonymous moves around.
        shortest = same_moves.shift();
        synonyms = same_moves;

        canonical_notations[shortest] = {piece:piece, square:square, move:abs_move};

        for (j = 0; j < synonyms.length; j += 1) {
            synonymous_notations[synonyms[j]] = {piece:piece, square:square, move:abs_move};
        }
    }

    // TODO: also return synonymous_notations, so overly-disambiguated move
    // notations can be used, too, but return them separately so they won't be
    // listed as unique, canonical moves.
    return [canonical_notations, synonymous_notations];
}

// After the board changes and it is the next person's turn, calculate 
// what the next possible allowable moves are, and update the globals with this information.
//
// If is_hypothetical, do not update globals, and allow "moves" that put in
// check (useful for attacks, see is_hypothetical elsewhere).
//
// This operates on VBOARD only, for speed. Use make_vboard() before if needed.
function calculate_moves(color, is_hypothetical)
{
    var valid_moves = {}, is_valid_move = {};
    var possible_notations, notation, raw_notations = {};

    if (!is_hypothetical) { 
        // Values are [ [ [piece, square ], [possible move names] ], ... ]
        // Instead of a hash or assocative array, because I couldn't use
        // [piece, square] as a key, even with Prototype's Hash. Could use
        // http://www.tutorials4html.com/2009/02/06/true-javascript-hash-table/
        // but instead, using an array with linear lookup.
        possible_notations = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                possible_notations[notation] = [];
            }
        }
    }

    // Look at all the active pieces
    for (var x = 1; x <= FILE_MAX; x += 1) {
        for (var y = 1; y <= RANK_MAX; y += 1) {
            var starting_filerank, square_from, moves, piece;

            square_from = VBOARD[x][y];
            piece = square_from.piece;
 
            // Skip blank squares and inactive pieces
            if (!piece || piece.color !== color) {
                continue;
            }

            // Convert xy to filerank notation (a string), so it can be easily used
            // as a hash key, class name for droppables, and also for notations.
            starting_filerank = square_from.filerank;

            moves = filtered_moves(piece, color, is_hypothetical);
            if (!is_hypothetical) {
                // Fills in possible_notations with possibly-ambiguous move notations in each system
                calculate_notations(color, piece, moves, starting_filerank, possible_notations, square_from);
            }

            // Store valid moves for mouseovers etc.
            if (moves.length !== 0) {
                // For move highlighting
                valid_moves[starting_filerank] = moves;

                // Lookup for accepts()
                is_valid_move[starting_filerank] = {};
                dojo.forEach(moves, function(m) {
                    is_valid_move[starting_filerank][xy2filerank([m.x, m.y])] = m;
                });
            }

            //console.log(starting_filerank, moves);
        }
    }


    // Gather all the notations, disambiguate and apply
    if (!is_hypothetical) {
        var notations = possible_notations;
        VALID_MOVE_NOTATIONS = {};
        ALT_MOVE_NOTATIONS = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                var canonical_and_synonyms;

                canonical_and_synonyms = disambiguate_notations(notations[notation]);
                VALID_MOVE_NOTATIONS[notation] = canonical_and_synonyms[0];
                ALT_MOVE_NOTATIONS[notation] = canonical_and_synonyms[1];
            }
        }

        // For reals.
        VALID_MOVES = valid_moves;
        IS_VALID_MOVE = is_valid_move;
    }
    
    return valid_moves;
}

// Get the number of properties an object has on its own.
// Conceptually, the "size" of an "associative array"
function own_property_count(obj)
{
    var count = 0;

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            count += 1;
        }
    }

    return count;
}

// Get the properties of an object as an array
function own_properties(obj)
{
    var props = [];

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            props.push(prop);
        }
    }

    return props;
}



// Populate the menu of valid moves, where you can make a move
// by selection instead of moving a piece with your mouse.
function populate_make_a_move_list()
{
    var active_name = AVAILABLE_NOTATIONS[PREFS.input_notation];
    var move_group, change_group, count, menu;

    menu = dojo.byId("make_move_menu");
    menu.innerHTML = "";

    count = own_property_count(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    if (count === 0) {
        menu.appendChild(dojo.create("option", {value:""}, "No legal moves"));
        return;
    }

    menu.appendChild(dojo.create("option", 
                {value:"", innerHTML:"Make a move... (" + count + ")"}));
   
    // Moves in active input notation.
    move_group = dojo.create("optgroup", {label:active_name});
    menu.appendChild(move_group);

    for (var notation in VALID_MOVE_NOTATIONS[PREFS.input_notation]) {
        if (VALID_MOVE_NOTATIONS[PREFS.input_notation].hasOwnProperty(notation)) {
            move_group.appendChild(dojo.create("option", 
                        {value: notation, innerHTML:notation}));
        }
    }

    // Change the input notation.
    change_group = dojo.create("optgroup", {label:"Other notation..."});
    menu.appendChild(change_group);

    for (var n in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(n) && n !== PREFS.input_notation) {
            var name = AVAILABLE_NOTATIONS[n];
            change_group.appendChild(dojo.create("option", 
                        {value: "change_" + n, innerHTML:name}));
        }
    }

    menu.selectedIndex = 0;
}

// Called when the make a move menu is changed, either to change the
// input notation or actually make a move by the menu.
function make_move_by_menu(menu)
{
    var choice = form_value("make_move_menu");

    // Notation change
    if (choice.indexOf("change_") === 0) {
        var new_notation = choice.substring("change_".length);
   
        PREFS.input_notation = new_notation;
        populate_make_a_move_list();
        return;
    }

    mv(choice);
}

// AI - artificial intelligence 
// Do this after a delay, so that when playing computer vs. computer, you can
// see the move, since they are not animated (Effect.Move) yet.
function computer_move_if_applicable(clicked)
{
    if (clicked) {
        if (form_value("black_computer") || form_value("white_computer")) {
            dojo.byId("skill_level").value = PREFS.skill;
            $("show_skill").show();
        } else {
            $("show_skill").hide();
        }
    }

    if (!form_value(GAME_STATE.active_color + "_computer")) {
        return;
    }

    // TODO: better variables
    if (dojo.byId("check").innerHTML.indexOf("Checkmate") !== -1 ||
        dojo.byId("check").innerHTML.indexOf("Draw") !== -1) {
        // Game is completed, don't bug the computer
        return;
    }

    if (PREFS.skill === 0) {
        setTimeout(random_move, 1);
    } else {
        schedule_engine_move(PREFS.skill);
    }
}

// Update the skill level when the user changes the form field.
function update_skill(element)
{
    var skill = parseInt(element.value, 10);

    if (skill < 0) {
        skill = 0;
    }  else if (skill > 100) {
        skill = 100;
    }

    element.value = skill;

    PREFS.skill = skill;
}

// Make a random move with equal probability. No intelligence.
function random_move()
{
    // simply choose a random move
    var keys = own_properties(VALID_MOVE_NOTATIONS.SAN);
    var alg_move = keys[randint(0, keys.length - 1)];
    //var alg_move = keys[0];

    //var piece_square = VALID_MOVE_NOTATIONS.SAN[alg_move];

    // TODO: do some animation when moving, Effect.Move, to slow it down so we can see it.
    mv(alg_move);
}

// Ask a chess engine, via Ajax, for its move and the board score.
// TODO: also allow remote human moves, for realtime games?
function schedule_engine_move(skill)
{
    var query;

    // TODO: pass skill, too.
    
    query = "?skill=" + skill + ";fen=" + encodeURIComponent(active_fen());

    dojo.xhrGet({
        url: PREFS.engine + query,
        handleAs: "json",
        load: got_engine_move,
        error: got_engine_error
        });

    set_check_message("Analyzing...");
}

// Callback for when the chess engine Ajax request move is received.
function got_engine_move(response)
{
    if (!response.error) {
        set_check_message("");
        mv(response.next_move);
        // TODO: show a meter for the board position
        dojo.byId("score").innerHTML = "Score: " + response.score;
    } else {
        disable_engine("Engine error: " + response.error);
    }
}

// Called when the Ajax request fails
function got_engine_error(response)
{
    disable_engine("Engine unavailable: " + response);
}

// Disable the external chess engine usage and make a random move in its place.
function disable_engine(why)
{
    PREFS.skill = 0;
    dojo.byId("skill_level").value = PREFS.skill;
    dojo.byId("skill_level").title = "Reset because of: " + why;
    window.status = "Skill level reset because: " + why;

    // It'll have to do
    random_move();
}

// Codes for raw notation
// TODO: generalize in raw notation and abs_move? 
var RAW_NOTATION_FLAG_LONG2SHORT = {
    en_passant_capture: "e",    // captures pawn behind destination square
    snapback: "s",              // clears "destination square", piece doesn't move
    self_destruct: "d"          // destination square is cleared
};

var RAW_NOTATION_FLAG_SHORT2LONG = {
    e: "en_passant_capture",
    s: "snapback",
    d: "self_destruct"
};

// Decode a serialized "raw" notation and execute it using do_virtual_move().
// This move notation allows moves to be made without calculating the valid
// moves, a time-consuming process.
// Syntax: /from_square/to_square/piece_code/flags
// TODO: Use for quickly loading a saved game, in a URL, without calculating valid
// moves (time consuming)
function decode_raw_move(s)
{
    var a, piece, move, square, notations, flags;

    assert(s.substr(0, 1) === "/", "do_raw_move(" + s + "): must begin with /");

    // TODO: support X(...) piece codes
    piece = decode_piece_letter(s.substring(5, 6));
    piece.square = filerank2obj(s.substring(1, 3));
    move = filerank2obj(s.substring(3, 5));
    flags = s.substring(6);

    for (var i = 0; i < flags.length; i += 1) {
        var flag_code = flags.charAt(i);
        var long_flag = RAW_NOTATION_FLAG_SHORT2LONG[flag_code];
        
        assert(long_flag, "decode_raw_move(" + s + "): invalid flag code: " + flag_code);
        move[long_flag] = true;
    }

    
    square = VBOARD[move.x][move.y];

    // Populate move with flags
    dojo.mixin(move, parse_flags(flags));

    return {piece:piece, square:square, move:move};
    //do_virtual_move(piece, move);
}

// Generate the raw move notation for a move
function make_raw_notation(piece, move)
{
    var from_square, to_square, piece_code, flags;

    from_square = xy2filerank([piece.square.x, piece.square.y]);
    to_square = xy2filerank([move.x, move.y]);
    piece_code = color_piece_prefix(piece);

    flags = "";
    for (var prop in move) 
    {
        if (move.hasOwnProperty(prop)) {
            var code = RAW_NOTATION_FLAG_LONG2SHORT[prop];
            if (code) {
                flags += code;
            }
        }
    }

    return "/" + from_square + to_square + piece_code + flags;
}

// Make a move in the VBOARD, which can be undone. Only makes the move.
function do_virtual_move(piece, move)
{
    var did = {};

    did.piece = piece;
    did.move = move;

    did.from_square = piece.square;

    did.to_square = VBOARD[move.x][move.y];
 
    // Special case: en passant captures to an empty square
    if (move.en_passant_capture) {
        var forward = forwards_vector(GAME_STATE.active_color);

        did.capture_square = VBOARD[did.to_square.x][did.to_square.y - forward];
    } else {
        did.capture_square = did.to_square;
    }

    // The piece that was captured, not always where the piece moved to.
    did.captured = did.capture_square.piece;

    // Piece that was on destination square, if any. For restoring old piece.
    did.piece_moved_over = did.to_square.piece;

    if (did.captured) { 
        VBOARD[did.capture_square.x][did.capture_square.y].piece = null;
        did.captured.square = null;
    }

    if (move.snapback) {
        // Projectile attack, withdrawals back to where it came from
        did.to_square = did.from_square;    // this is key
        did.piece_moved_over = did.captured;
        return did;
    }
    if (move.self_destruct) {
        VBOARD[did.to_square.x][did.to_square.y].piece = null;
        did.self_destructed = true;
        VBOARD[did.from_square.x][did.from_square.y].piece = null;
        return did;
    }

    piece.square = VBOARD[did.to_square.x][did.to_square.y];
    VBOARD[did.to_square.x][did.to_square.y].piece = piece;
    if (did.from_square) {
        VBOARD[did.from_square.x][did.from_square.y].piece = null;
    }

    return did;
}

// Undo a move given the result of do_virtual_move().
function undo_virtual_move(did)
{
    // Restore captured piece
    if (did.captured) {
        did.captured.square = VBOARD[did.capture_square.x][did.capture_square.y];
        did.captured.square.piece = did.captured;
    }

    // Piece that was clobbered by the move
    VBOARD[did.move.x][did.move.y].piece = did.piece_moved_over;

    // Move piece back
    did.piece.square = VBOARD[did.from_square.x][did.from_square.y];
    VBOARD[did.from_square.x][did.from_square.y].piece = did.piece;
}


// Return whether moving piece to move would mean that
// color is in check. Note, that doesn't mean that the move
// *caused* the check, they could have already been in check and
// this move didn't take them out. Either way, its illegal.
function would_check(piece, move, color)
{
    var from_square = piece.square;
    var to_square = VBOARD[move.x][move.y];
    var checked, all_moves, did;


    // Hypothetical move, with possible capture
    did = do_virtual_move(piece, move);

    // TODO: This is a lot of calculation to do, see if can speed it up
    all_moves = calculate_moves(opposite_color(color), true);
    checked = in_check(color, all_moves);

    // Restore move
    undo_virtual_move(did); 

    return checked;
}

// Return whether a pawn has moved from its initial position. Unfortunately,
// the starting ranks of black and white pawns are hardcoded, so that games
// in-progress can be loaded and pawns that have moved, but we haven't seen move,
// are recognized as in fact having moved. Other games with pawns in ranks other
// than 2nd and 7th (Chinese Chess, etc.) will need to have this modified.
// TODO: store initial rank in piece information
function piece_moved(piece)
{
    // Bit of a hack, but castling privileges take care of this.
    if (piece.type === "king") {
        return false;
    }

    // TODO: don't hardcode! Give rank in piece type, mirror black/white.
    //assert(piece.type === "pawn" || piece.type === "berolina_pawn" || piece.type === "pawnattackrook", "piece_moved(" + piece + "): can only tell if pawns moved, not " + piece.type);

    var square = piece.square;

    if (piece.color === "white") {
        return square.y !== 2;    // 2nd rank
    } else if (piece.color === "black") {
        return square.y !== 7;    // 7th rank
    } else {
        assert("piece_moved(" + piece + "): neither white nor black");
    }
}

//// PARLETT NOTATION FUNCTIONS

// Get the unfiltered, relative moves for a Parlett string.
// Warning: do not modify the moves! Otherwise other moves will get confused.
var PARLETT_CACHE = {};
function unfiltered_moves(parlett)
{
    var choice_groups, rel_moves;

    // Cache for a performance improvement, since Parlett is constant per move.
    if (PARLETT_CACHE[parlett]) {
        //return deep_copy(PARLETT_CACHE[parlett]);
        //return PARLETT_CACHE[parlett].evalJSON();
        return PARLETT_CACHE[parlett];
    }

    // Get all the unfiltered moves for the mutually exclusive choices
    choice_groups = parlett.split(", ");

    rel_moves = [];
    for (var i = 0; i < choice_groups.length; i += 1) {
        // For each group, gather the move options. 
        // (Would be nice if JavaScript arrays had a Python-like .extend)
        rel_moves.push.apply(rel_moves, decode_one_parlett(choice_groups[i]));
    }   
    rel_moves = without_dupes(rel_moves);

    PARLETT_CACHE[parlett] = rel_moves;
    //PARLETT_CACHE[parlett] = Object.toJSON(rel_moves);

    return rel_moves;
}

// Get the legal moves for a piece.
function filtered_moves(piece, color, is_hypothetical)
{
    var parlett, rel_moves, moves, start, blocked;
    var start_x, start_y, piece_info;

    start = piece.square;
    if (!start) {
        return [];
    }

    start_x = start.x;
    start_y = start.y;

    piece_info = PIECE_TYPES[piece.type];
    parlett = piece_info.parlett;

    rel_moves = unfiltered_moves(parlett);

    // Absolutize and find what is allowed
    moves = [];
    blocked = {};
    for (var i = 0; i < rel_moves.length; i += 1) {
        var rel_x, rel_y, flags, abs_move, x, y;
       
        rel_x = rel_moves[i][0];
        rel_y = rel_moves[i][1]; 
        flags = rel_moves[i][2];

        // Local copies of relative coords, so don't modify original.
        var if_unblocked_dx = flags.if_unblocked_dx, if_unblocked_dy = flags.if_unblocked_dy;
        var if_unblocked2_dx = flags.if_unblocked2_dx, if_unblocked2_dy = flags.if_unblocked2_dy;
        var if_unblocked3_dx = flags.if_unblocked3_dx, if_unblocked3_dy = flags.if_unblocked3_dy;
        //var capture_at_dx = flags.capture_at_dx, capture_at_dy = flags.capture_at_dy;
        var mark_ep_target_dx = flags.mark_ep_target_dx, mark_ep_target_dy = flags.mark_ep_target_dy;

        // Positive is forwards, so mirror for black.
        if (color === "black") {
            rel_y = -rel_y;
            // Reverse any embedded relative coordinates.
            if (if_unblocked_dy) { if_unblocked_dy = -if_unblocked_dy; }
            if (if_unblocked2_dy) { if_unblocked2_dy = -if_unblocked2_dy; }
            if (if_unblocked3_dy) { if_unblocked3_dy = -if_unblocked3_dy; }
            //if (capture_at_dy) { capture_at_dy = -capture_at_dy; }
            if (mark_ep_target_dy) { mark_ep_target_dy = -mark_ep_target_dy; }
        }

        x = rel_x + start_x;
        y = rel_y + start_y;

        abs_move = {x: x, y: y};

        if (x < 1 || y < 1 || x > FILE_MAX || y > RANK_MAX) {
            // Out of bounds
            continue;
        }

        var dest_square = VBOARD[x][y];
        var capture_piece = dest_square.piece;

        // If there is any piece there, it may block other moves
        if (capture_piece) {
            blocked[rel_x + "," + rel_y] = true;

            if (flags.if_blocked_skip) {
                i += flags.if_blocked_skip;
            }

            // Can't move to self-occupied square OR invincible pieces
            if (capture_piece.color === color || PIECE_TYPES[capture_piece.type].invincible) {
                continue;
            }

            // For move notations
            abs_move.capture = capture_piece;
        } 

        // Must be a capture
        if (flags.capture_only && !capture_piece) {
            continue;
        }

        // Must not be capture
        if (flags.no_capture && capture_piece) {
            continue;
        }

        // TODO: Does piece_moved() need to be virtualized?
        if (flags.initial_only && piece_moved(piece)) {
            continue;
        }

        // Blocked by an obstruction. Can check for up to three spaces. To check
        // more, chain the moves. 
        var key;
        if (if_unblocked_dy !== undefined) {
            key = if_unblocked_dx + "," + if_unblocked_dy;

            // If was either blocked by a previous move (faster), or there is a
            // piece there but it wasn't a valid move. For example, elephant (2X)
            // can be blocked, since it is not a leaper (sticking the elephant's eye),
            // non-hippogonal rider.
            if (blocked[key] || pc_or_offboard(if_unblocked_dx + start_x, if_unblocked_dy + start_y, true)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }
        if (if_unblocked2_dy !== undefined) {
            key = if_unblocked2_dx + "," + if_unblocked2_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked2_dx + start_x, if_unblocked2_dy + start_y, true)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }
        if (if_unblocked3_dy !== undefined) {
            key = if_unblocked3_dx + "," + if_unblocked3_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked3_dx + start_x, if_unblocked3_dy + start_y, true)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }

        // Snap back after moving - for guns
        if (flags.snapback !== undefined) {
            abs_move.snapback = true;
        }
       
        // Self-destruct - for consumables
        if (flags.self_destruct !== undefined) {
            abs_move.self_destruct = true;
        }


        // Map pawn moves to what the en passant target will be if
        // the pawn moves there.

        if (!is_hypothetical) {
           if (mark_ep_target_dx !== undefined) {
                abs_move.create_ep_target = [
                    mark_ep_target_dx + start_x, 
                    mark_ep_target_dy + start_y];
            }

        }

        // Only valid if this move is to an ep target.
        if (flags.if_ep_target) {
            if (!GAME_STATE.ep_target || GAME_STATE.ep_target[0] !== x ||
                GAME_STATE.ep_target[1] !== y)  {
                continue;
            }

            abs_move.en_passant_capture = true;
        }

        // Castling moves
        if (flags.if_can_castle_short) {
            // Moved and lost castling privileges
            if (!GAME_STATE.can_castle[color].cshort) {
                continue;
            }

            // Can't castle if in check
            if (GAME_STATE.active_in_check) {
                continue;
            }

            // Can't castle through check. Ugly hardcoded, check if
            // if a valid regular move (which must have been listed before
            // the castling move in Parlett).
            var found = false;
            for (var j = 0; j < moves.length; j += 1) {
                if (moves[j].x === 6 && moves[j].y === (color === "white" ? 1 : 8)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                continue;
            }

            // TODO: check if unimpeded here? instead of if_unblockedX in Parlett

            abs_move.notation_override = "O-O";
        }

        if (flags.if_can_castle_long) {
            if (!GAME_STATE.can_castle[color].clong) {
                continue;
            }
            if (GAME_STATE.active_in_check) {
                continue;
            }

            // Another ugly hardcoded "can't castle through check"
            found = false;
            for (j = 0; j < moves.length; j += 1) {
                if (moves[j].x === 4) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                continue;
            }


            abs_move.notation_override = "O-O-O";
        }

        // Capture at relative location, instead of at destination square.
        // Not actually implemented. En passant capture location is hardcoded.
        /*
        if (capture_at_dx !== undefined) {
           var cx = capture_at_dx + start_x, cy = capture_at_dy + start_y;

           if (cx < 1 || cy < 1 || cx > RANK_MAX || cy > FILE_MAX) {
               continue;
           }

           var capture = VBOARD[cx][cy].piece;
           //console.log("C",xy2filerank([cx,cy]));
           if (capture) {
               abs_move.capture = capture;
           } else {
               // Nothing there to capture.
               continue;
           }
        }*/

        if (piece_info.castles_with) {
            // If this piece castles with another piece, moving it clears that ability.
            abs_move.clear_castle_short = true;
            abs_move.clear_castle_long = true;
        }

        // TODO: faster check checking? maybe split into:
        // 1. if not in check, can't move into
        //   a. can't move a pinned piece that would cause check, unblocks attack
        //   b. can't move royal piece into attacked square
        // 2. if in check, must move out of
        //   a. move royal piece (if double check, only can move)
        //   b. capture with another piece
        //   c. block with another piece
        if (!is_hypothetical && would_check(piece, abs_move, color)) { 
            continue; 
        }

        if (would_promote(piece, abs_move)) {
            // Expand promotions; make a move for each piece you can promote to
            for (var j = 0; j < piece_info.promote.length; j += 1) {
                var prom_move = {promote_to: piece_info.promote[j]};

                dojo.mixin(prom_move, abs_move);
               
                moves.push(prom_move);
            }
        } else {
            // Just one move
            moves.push(abs_move);
        }
    }

    return moves;
}

// Return an array of [direction vectors, ch2 consumed]. The vectors
// are positive for forward, negative for backwards.
function relative_decode_direction(ch, ch2)
{
    if (ch === "+") { 
        // orthogonally four possible directions
        return [[[1, 0], [0, 1], [-1, 0], [0, -1]], false];
    } else if (ch === "=") {
        // orthogonally sideways
        return [[[1, 0], [-1, 0]], false];
    } else if (ch === ">") {
        if (ch2 === "=") {
            // >= orthogonally forwards or sideways
            return [relative_decode_direction(">", undefined)[0].concat(relative_decode_direction("=", undefined)[0]), true];
        } else if (ch2 === ">") {
            // >> right (Extended Parlett)
            return [[[1, 0]], true];
        } else {
            // = orthogonally forward
            return [[[0, 1]], false];
        }
    } else if (ch === "<") {
        if (ch2 === ">") {
            // <> orthogonally forwards and backwards
            return [[[0, 1], [0, -1]], true];
        } else if (ch2 === "=") {
            // <= orthogonally backwards or sideways
            return [relative_decode_direction("<", undefined)[0].concat(relative_decode_direction("=", undefined)[0]), true];
        } else if (ch2 === "<") {
            // << left (Extended Parlett)
            return [[[-1, 0]], true];
        } else {
            // < orthogonally backwards
            return [[[0, -1]], false];
        }
    } else if (ch === "X") { 
        if (ch2 === ">") {
            // X> diagonally forwards
            return [[[1, 1], [-1, 1]], true];
        } else if (ch2 === "<") {
            // X< diagonally backwards
            return [[[1, -1], [-1, -1]], true];
        } else {
            // X diagonally four possible directions
            return [[[1, 1], [1, -1], [-1, 1], [-1, -1]], false];
        }
    } else if (ch === "*") {    
        // orthogonally or diagonally (eight possible directions)
        return [relative_decode_direction("+", undefined)[0].concat(relative_decode_direction("X", undefined)[0]), false];
    } else {
        assert(false, "relative_decode_direction('" + ch + "', '" + ch2 + "'): invalid direction");
    }
}

function parseInt10(x) 
{ 
    return parseInt(x, 10); 
}

// Parse semicolon separated flags, possibly key/value pairs
// foo;bar sets foo:true and bar:true, can also set relative coordinates:
// if_unblocked=1,2.
function parse_flags(text, flags)
{
    var flags_text;

    if (flags === undefined) {
        flags = {};
    }

    if (Object.isArray(text)) {
        flags_text = text;
    } else {
        flags_text = text.split(";");
    }

    // Semicolon-separated flags
    for (var i = 0; i < flags_text.length; i += 1) {
        var flag_text = flags_text[i];
        var value;
       
        // Allow if_unblocked=0,1, etc.
        if (flag_text.indexOf("=") !== -1) { 
            // Unfortunately, need JavaScript 1.8 to do [x,y] = ...
            var ary = flag_text.split("=");
            var left = ary[0], right = ary[1];
            value = right.split(",");
            value = value.map(parseInt10);
            if (value.length === 1) {
                flags[left] = value[0];
            } else if (value.length === 2) {
                flags[left + "_dx"] = value[0];
                flags[left + "_dy"] = value[1];
            } else {
                assert(false, "parse_flags(" + text + ", " + flags + "): not 1 or 2 elements: " + value);
            }
        } else {
            flags[flag_text] = true;
        }
    }

    return flags;
}

// Decode the Extended Parlett {} construct, which adds flags
// to arbitrary move text. {parlett, flags}
function nested_flags(parlett)
{
    var rel_moves, flags_text, flags;
    
    flags_text = parlett.split(";");
    // Do not cache, since can be modified
    rel_moves = dojo.clone(unfiltered_moves(flags_text.shift()));

    flags = parse_flags(flags_text);

    for (var flag in flags) {
        if (flags.hasOwnProperty(flag)) {
            for (var j = 0; j < rel_moves.length; j += 1) {
                rel_moves[j][2][flag] = flags[flag];
            }
        }
    }

    return rel_moves;
}

// Decodes an explicit relative move that was in square brackets: [0,2;initial_only]
function decode_relative_explicit_move(text_move, existing_flags)
{
    var xy_text_flags, xy_text, xy, x, y, flags;
    
    xy_text_flags = text_move.split(";");
    xy_text = xy_text_flags.shift();

    if (xy_text.indexOf(",") !== 0) {
        // Relative x,y
        xy = xy_text.split(",");
        x = parseInt(xy[0], 10);
        y = parseInt(xy[1], 10);
    } else {
        // TODO: call decode_one_parlett, to allow
        // [oi2>;flags] or oi[2>;flags], etc.
        assert(false, "decode_relative_explicit_move(" + text_move + ", " + existing_flags + "): not [x,y;flags], missing comma");
    }

    flags = parse_flags(xy_text_flags, existing_flags);

    return [x, y, flags];
}

// Decode a Parlett notation into a list of [x,y,flags], where
// x and y are destinations relative to the piece origin, and flags describes
// under what conditions the move can be made. + is forward, - is backwards,
// from the perspective of the active color. Has no knowledge of board state.
// The moves must be filtered to determine their validity.
function decode_one_parlett(parlett)
{
    var distances, directions, flags, movement, rel_moves, limit;
    var hippogonal = false;

    flags = {};
    distances = [];
    rel_moves = [];

    movement = "rider";
    for (var i = 0; i < parlett.length; i += 1) {
        var ch = parlett.substr(i, 1);

        if (ch === "~") {
            movement = "leaper";
            // TODO: "darters", blockable 'leapers' - 1//2, elban knight, mao, moa
            // http://www.mayhematics.com/v/v_gm.htm

        // Flags, documented on http://en.wikipedia.org/wiki/Fairy_chess_piece#Additions_to_Parlett.27s
        } else if (ch === "i") { 
            // Initial move: Can only if the piece is in its original position
            // (pawn's 2 move forward)
            flags.initial_only = true;
        } else if (ch === "c") {
            // Capture only: may only be used if destination is occupied by enemy piece
            // (pawn's diagnal capture)
            flags.capture_only = true;
        } else if (ch === "o") {
            // Can not capture: destination square must be unoccupied; since by default, piece
            // can move to enemy square in order to capture it
            // (pawn's forward move)
            flags.no_capture = true;

        // Extended Parlett
      
        // Include an existing piece movement, possibly with flags
        } else if (ch === "#") {
            var type = parlett.substr(i + 1);
            assert(PIECE_TYPES[type], "in Parlett #include, piece name not found: " + type);
            var included = dojo.clone(unfiltered_moves(PIECE_TYPES[type].parlett));

            for (i = 0; i < included.length; i += 1) {
                dojo.mixin(included[i][2], flags);
            }

            return included;

        // Direct move text: [rel_x,rel_y;flag1;flag2;...] 
        } else if (ch === "[") {
            var text_move = "";
            var nest_level = 1;
            while(i < parlett.length)
            {
                i += 1;
                var chi = parlett.substr(i, 1);
                if (chi === "]") { nest_level -= 1; }
                if (chi === "[") { nest_level += 1; }
                if (nest_level === 0) { break; } 

                text_move += chi;
            }
            rel_moves.push(decode_relative_explicit_move(text_move, flags));

        // Nested flags: {oi2>, asdf.. ;flag1;flag2;flag3...}
        } else if (ch === "{") {
            var inner, nest;
            
            inner = "";
            nest = 1;
            while(i < parlett.length)
            {
                i += 1;
                var cho = parlett.substr(i, 1);
                if (cho === "}") { nest -= 1; }
                if (cho === "{") { nest += 1; }
                if (nest === 0) { break; } 

                inner += cho;
            }

            return nested_flags(inner);

        // Limit on distances, for diminished pieces
        } else if (ch === ".") {
            // Only one digit for now
            limit = parseInt(parlett.substr(i + 1, 1), 10);
            i += 1;

        // Standard Parlett
        } else if (/[0-9]/.test(ch)) {
            distances.push(parseInt(ch, 10));
        } else if (ch === "n" || ch === "m") {
            distances.push(Infinity);
        } else if (ch === "/") {
            hippogonal = true;
        } else if (ch === "&") {
            movement = "rider";
            // TODO: n(...) grouping, either n or a number. 2(~1/2) double knight, makes
            // two moves
        } else if (ch === " ") {
            assert(false, "relative_parlett(" + parlett + "): whitespace encountered, did you forget a comma?");
        } else {
            var maybe_directions = relative_decode_direction(ch, parlett.substr(i + 1, 1));

            if (maybe_directions) {
                directions = maybe_directions[0];
                if (maybe_directions[1]) {
                    i += 1; // two-character direction
                }
            } else {
                assert(false, "relative_parlett(" + parlett + "): unsupported: '" + ch + "'");
            }
        }
    }

    if (hippogonal) {
        assert(distances.length === 2, "relative_parlett(" + parlett + "): for hippogonal, expected exactly two distances");
        var a = distances[0], b = distances[1];

        if (a !== Infinity && b !== Infinity) {
            // Hippogonals in all directions
            // TODO: support direction modifiers, vector
            rel_moves.push.apply(rel_moves, without_dupes([
                [-a, -b, flags],
                [-a, +b, flags],
                [+a, -b, flags],
                [+a, +b, flags],

                [-b, -a, flags],
                [-b, +a, flags],
                [+b, -a, flags],
                [+b, +a, flags]
                ]));
        } else {
            // ~n/m, any square on board. Remember, these are relative moves.
            for (var x = -FILE_MAX; x <= +FILE_MAX; x += 1) {
                for (var y = -RANK_MAX; y <= +RANK_MAX; y += 1) {
                    rel_moves.push([x, y, flags]);
                }
            }
        }

        // Hippogonal can be optionally restricted by direction
        if (directions) {
            var keep_relmoves = [];

            for (i = 0; i < directions.length; i += 1) {
                var dir = directions[i];

                for (var j = 0; j < rel_moves.length; j += 1) {
                    var move = rel_moves[j];

                    if ((dir[0] === Infinity || signum(move[0]) === signum(dir[0])) &&
                        (dir[1] === Infinity || signum(move[1]) === signum(dir[1]))) {
                        keep_relmoves.push(move);
                    }
                }
            }

            rel_moves = keep_relmoves;
        }

        if (movement === "rider") {
            var new_rel_moves = [];

            // Nightrider-like piece
            expand_directions(rel_moves, [], limit || 5, flags, movement, new_rel_moves);

            rel_moves = new_rel_moves;
        }

 
    } else if (directions) {
        expand_directions(directions, distances, limit, flags, movement, rel_moves);
    }

    return rel_moves;
}

// Expand a piece in the given directions, distances, up to
// an optional limit, pushing the moves to rel_moves. Used for non-hippogonal
// pieces, often riders (n*), but leapers (~n*) are also allowed.
function expand_directions(directions, distances, limit, flags, movement, rel_moves)
{
    for (i = 0; i < directions.length; i += 1) {
        var dir = directions[i];
        var rel_x, rel_y, prev_rel_x, prev_rel_y, distance;

        // Optional explicit distance instead of all in between (n)
        // Example: 2X, can only move two diagonally, unblocked
        if (distances.length !== 0) {
            distance = distances[0];

            assert(distances.length === 1, "expand_rider(" + distances + "): multiple distances given for rider, expected one or none");
        } else {
            distance = Infinity;
        }

        rel_x = rel_y = 0;
        prev_rel_x = null;
        prev_rel_y = null;

        // Iterate to either given limit or maximum
        var max = limit || Math.max(RANK_MAX, FILE_MAX);

        var count = 0;

        for (var j = 1; j <= max; j += 1) {
            var these_flags = {};

            // Riders get blocked. Note that you can have a non-hippogonal leaper.
            // ~n* (lion) for example, is like a queen, but not blocked by intervening pieces.

            // Blocked on a square which you CANNOT move to - riders w/ distance limits
            if (prev_rel_x !== null && prev_rel_y !== null && 
                    movement === "rider" && distance !== Infinity) { 
                // TODO: Support multiple squares. This only works for one square, for
                // pawn's double-moves. 2> means two forward, unblocked, and it works,
                // but 3> for three forward, unblocked, won't work yet.
                these_flags.if_unblocked_dx = prev_rel_x;
                these_flags.if_unblocked_dy = prev_rel_y;

            } 

            // Directions - these were either specified by direction vector code
            // as in n* or hippogonally using ~1/2& (both these expand to >1 direction)
            rel_x += dir[0];
            rel_y += dir[1];

            dojo.mixin(these_flags, flags);

            // Blocked by a square which you CAN move to - riders w/ no limits except board dimensions
            if (distance === Infinity && movement === "rider") {
                these_flags.if_blocked_skip = max - count - 1;
            }

            if (distance === Infinity || j === distance) {
                rel_moves.push([rel_x, rel_y, these_flags]);
                count += 1;

                if (j === distance) { 
                    break;
                }
            }

            prev_rel_x = rel_x;
            prev_rel_y = rel_y;
        }
    }
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//    [1,2] in [[1,2], [3,4]]
// is false, since 
//    [1,2] === [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
// Note: flags also differentiate a move.
function without_dupes(a)
{
    var hash = {};
    var result = [];

    for (var i = 0; i < a.length; i += 1) {
        // Add if not a dupe
        if (!hash[Object.toJSON(a[i])]) {
            result.push(a[i]);
        }

        // Record that this element was added. Converts to a string,
        // unfortunately, so can't just use own_properties() after filling 
        // in the hash.
        hash[Object.toJSON(a[i])] = true;
    }

    return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
    return {white: "black", black: "white"}[color];
}

function update_check()
{
}

// Set the active color to white or black, or go to the next color (toggling).
// Returns a character for algebraic notation, + = check, etc., if applicable
// If historical, do not check for threefold repetition.
function set_turn(color, historical)
{
    var new_color, checked, no_moves, text_move, text_end, old_color, old_fullmove, repeats;

    old_color = GAME_STATE.active_color;

    if (color === "next") {
        new_color = opposite_color(GAME_STATE.active_color);
    } else if (color === "black" || color === "white") {
        new_color = color;
    } else {
        assert(false, "set_turn(" + color + "): invalid color");
    }

    dojo.byId("status").innerHTML = ucfirst(new_color) + "'s Turn";

    // Move number is incremented after black moves, according to rules.
    old_fullmove = GAME_STATE.fullmove_number;
    if (color === "next" && GAME_STATE.active_color === "black") {
        GAME_STATE.fullmove_number += 1;
    }

    GAME_STATE.active_color = new_color;
   
    // Active player in check?
    VALID_MOVES_OPP = calculate_moves(opposite_color(new_color), true);
    checked = GAME_STATE.active_in_check = in_check(GAME_STATE.active_color, VALID_MOVES_OPP);

    // Note: this takes some time... is there any way to run it right AFTER the piece has
    // gone through the endeffect? This is called in onDrop.
    // TODO: find out how to run something *after* the endeffect, for smoother UI.
    calculate_moves(GAME_STATE.active_color);

    // Zero mobility? For detecting stalemate, checkmate.
    no_moves = own_property_count(VALID_MOVES) === 0;

    // Results. 
    if (checked && !no_moves) {
        set_check_message("Check!");
        text_move = "+";
        // TODO: detect double-check, allow ++ for descriptive/algebraic descriptive, but not algebraic
    } else if (!checked && no_moves) {
        set_check_message("Draw (stalemate)");
        text_end = "&frac12;-&frac12;";
    } else if (checked && no_moves) {
        set_check_message("Checkmate.");
        if (new_color === "white") { 
            text_move = "#";
            text_end = "0-1";  // white lost
        } else {
            text_move = "#";
            text_end = "1-0";
        }
    } else if (check_insufficient_material()) {
        set_check_message("Draw (material)");
        text_end = "&frac12;-&frac12;";
    } else if (GAME_STATE.halfmove_clock >= 50) {
        set_check_message("Draw (fifty move) claimable");
    } else {
        set_check_message("");
    }

    if (text_end) {
        // So can programmatically tell the game is finished.
        GAME_STATE.ended = text_end;
    }

    var new_state = save_fen();

    var ply = encode_ply(old_color, old_fullmove);

    if (!old_color) {
        // If no one has moved yet, ply is 0 for initial board position.
        ply = 0;
    }

    if (!historical) {
        repeats = check_repetition(ply);
    }
    
    if (color === "next") { 
        GAME_STATE.position_after[ply] = new_state;
    }

    set_copyable_link();
    return {text_move: text_move, text_end: text_end, repeats: repeats};
}

// Update the copyable link that goes to the board state
function set_copyable_link()
{
    var fen, captured;
    var last = GAME_STATE.position_after.slice(-1)[0];
    var prior = GAME_STATE.position_after.slice(-2)[0];
    var perspective;

    // TODO: up to N last moves
    var last_move = GAME_STATE.made_moves.slice(-1)[0];

    if (last_move) {
        // Store the previous move and the board state _before_ the move,
        // so it can be made.
        last_move = ";m=" + last_move.notations[form_value("output_notation")];
        if (!prior) {
            // No move has been made yet
            dojo.byId("copyable_link").href = document.URL;
            return;
        }

        fen = prior;
    } else {
        last_move = "";
        fen = last;
    }

    captured = GAME_STATE.last_captured;
    if (captured) {
        captured = ";c=" + captured;
    } else {
        captured = "";
    }

    // Flipped if black's turn
    perspective = GAME_STATE.active_color === "black" ? ";f=1" : "";

    // TODO: also include c=, like Captured tag, so can know what was captured
    
    dojo.byId("copyable_link").href = make_copyable_link(fen) + captured + last_move + perspective;
}

// Make a URL that can be clicked to go to this board state
function make_copyable_link(fen)
{
    var base, base_split, query, href;

    // Get current URL without query string
    base_split = document.URL.split("?");
    base = base_split[0];

    // Replace with characters that do not need to be encoded
    fen = fen.replace(/ /g, "~").replace(/\//g, "|");
    query = "?b=" + encodeURIComponent(fen);

    href = base + query;

    return href;
}

// Set the game check status (or draw, checkmate) message.
function set_check_message(msg)
{
    dojo.byId("check").innerHTML = msg;
    dojo.byId("dash").style.display = msg ? "" : "none";
}

// Return whether there is insufficient material to mate
function check_insufficient_material()
{
    var counts = {}, total = 0, total_bishops = 0;
    var bishops = {white:{white:0, black:0}, black:{white:0, black:0}};
   
    // Count how many of each piece type are on the board
    // TODO: piece lists?
    for (var x = 1; x <= RANK_MAX; x += 1) {
        for (var y = 1; y <= FILE_MAX; y += 1) {
            var square = VBOARD[x][y];

            if (square.piece) {
                // Count all pieces
                if (counts[square.piece.type] === undefined) {
                    counts[square.piece.type] = 1;
                } else {
                    counts[square.piece.type] += 1;
                }
                total += 1;

                // Count color of bishops and squares they are bound to
                if (square.piece.type === "bishop") {
                    bishops[square.color][square.piece.color] += 1;
                    total_bishops += 1;
                }
            }
        }
    }

    // FIDE rules 
    if (total === 2 && counts.king === 2) {
        // king v. king
        return true;
    } else if (total === 3 && counts.king === 2) {
        // king v. king + bishop
        // king v. king + knight
        return counts.bishop === 1 || counts.knight === 1;
    } else if (total === total_bishops + 2 && counts.king === 2 && 
            (bishops.black.black === bishops.black.white ||
             bishops.white.black === bishops.white.white)) {
        // king and bishop(s) versus king and bishop(s) all on same color
        return true;
    }

    return false;
}

// Check for three-move repetition, which allows a draw to be claimed (not compulsory)
function check_repetition(ply)
{
    var new_state = active_fen(true);
    var reps;

    // Save new board state for three-move repetition
    if (GAME_STATE.position_moves[new_state] === undefined) {
        GAME_STATE.position_moves[new_state] = [ply];
    } else {

        reps = GAME_STATE.position_moves[new_state].slice();

        // This occurred here, too.
        GAME_STATE.position_moves[new_state].push(ply);

        if (GAME_STATE.position_moves[new_state].length >= 3) {
            // Player can claim a draw, but its not required (you might have a better position)
            // See http://en.wikipedia.org/wiki/Threefold_repetition
            set_check_message("Draw (repetition) claimable");

            // Return moves for highlighting, except this move (it is too early
            // for mark_repeated_moves to highlight, so move_piece_to_square will
            // add the current move, if we return something).
            return reps;
        }
    }

    return null;
}

//// BOARD FUNCTIONS

// TODO: a "board lab", where can drag pieces onto board in arbitrary
// positions, or drag off (with an Effect.Puff), to load arbitrary fen.
// Have a different mode where pieces can be dragged anywhere, including
// to offboard, and from a piece library.

// Load the virtual board into the displayed board. Any number of operations
// can be conducted on the virtual in-memory board, then when it is finished,
// only then does the board need to be rendered in HTML. 
function realize_vboard()
{
    var time_started = new Date().getTime();
    for (var x = 1; x <= FILE_MAX; x += 1) {
        for (var y = 1; y <= RANK_MAX; y += 1) {
            var v = VBOARD[x][y];
            var square = SQUARES[x][y];
            var piece;

            while (square.firstChild) {
                // 14% of realize_vboard() is spent here. TODO: Avoid removing if no change??
                square.removeChild(square.firstChild);
            }

            if (v.piece) {
                piece = create_piece(v.piece.color, v.piece.type);
                piece.square = SQUARES[x][y];
                // TODO: what about descriptive_name, adescriptive_name?? Its important.
                piece.unique_id = v.piece.unique_id;

                square.appendChild(piece);
            }
        }
    }

    // On my machine:
    // Safari 4: 5 ms
    // Firefox 3.0.10: 21 ms
    // MSIE7: 100+ ms, noticeably slower piece dropping
    var time_took = new Date().getTime() - time_started;
    //alert("realize_vboard took " + time_took + " ms");
}

// Save the current displayed board state to VBOARD.
function make_vboard()
{
    for (var x = 1; x <= FILE_MAX; x += 1) {
        for (var y = 1; y <= RANK_MAX; y += 1) {
            var square = SQUARES[x][y];
            var piece = square.firstChild;

            if (piece) {
                // TODO: Store arbitrary parameters?
                VBOARD[x][y].piece = {virtual:true, color:piece.color, type:piece.type, square:VBOARD[x][y], unique_id:piece.unique_id};
            } else {
                VBOARD[x][y].piece = null;
            }
        }
    }
}

// Toggle perspective of board
function flip()
{
    label_board(!PREFS.flipped);
    load_fen(active_fen(), true);
    // BUG: if edit board, then flip it, lose changes. TODO: fix
}

// Internally name the square cells with their (x,y) coordinates
// and filerank notation, once when the page loads. This is only code so I
// don't have to manually type <td x=0 y=0 filerank=a8> etc. in all the cells.
// Also populates SQUARES for fast lookup, and VBOARD virtual board.
// If flipped is true, then the board is from black's perspective, instead of white's.
function label_board(flipped)
{
    SQUARES = [];
    VBOARD = [];
    for (var x = 1; x <= FILE_MAX; x += 1) {
        SQUARES[x] = [];
        VBOARD[x] = [];
        for (var y = 1; y <= RANK_MAX; y += 1) {
            // Lookup the table cell from the DOM. This is extraordinarly expensive,
            // so it is only done once here then stored in a global, SQUARES.
            var square  = dojo.byId("board-body").childNodes[flipped ? y : 9 - y].childNodes[flipped ? 9 - x : x];

            square.x = x;
            square.y = y;
            square.filerank = xy2filerank(x, y);
            // Store the square color here once, so can always lookup .color, 
            // never have to check the white/black class name again.
            square.color = dojo.hasClass(square, "white") ? "white" : "black";

            square.descriptive = {};
            square.descriptive.white = xy2descriptive("white", [x, y]);
            square.descriptive.black = xy2descriptive("black", [x, y]);

            // http://www.sitepen.com/labs/code/iphone/events.html - fast
            // TODO: get this working on desktop and phone
            // http://www.manifestinteractive.com/iphone/touch/
            // jQuery Touch is slow. Prototype + Scriptaculous is expected to be as well,
            // maybe look into switching to a more lightweight JavaScript library.
            /*
            Event.observe(square, "click", function() {
                        // TODO: tap-to-move, as an alternative to dragging
                        if (DRAG.dragging) {
                            alert(1);
                            //function move_dropped_piece(piece, square, event)
                        }
                    });
            */

            SQUARES[x][y] = square;

            // Virtual, in-memory board
            VBOARD[x][y] = {
                virtual: true,
                x: x, 
                y: y, 
                filerank: square.filerank, 
                color: square.color,
                descriptive: {white: square.descriptive.white, black: square.descriptive.black}
            };
        }
    }

    // Label ranks and files
    var ranks = dojo.query(".rank.label")
    for (var i = 0; i < ranks.length; i += 1) {
        ranks[i].innerHTML = flipped ? i + 1 : 8 - i;
    }

    var files = dojo.query(".file.label");
    for (i = 0; i < files.length; i += 1) {
        files[i].innerHTML = String.fromCharCode(flipped ? "h".charCodeAt(0) - i : "a".charCodeAt(0) + i);
    }

    PREFS.flipped = flipped;
    dojo.byId("enable_flip").checked = flipped;
}

// Initialize the board - menu, load from query string if present.
// Only needs to be performed once per page load.
function init_board()
{
    var board_menu = dojo.byId("saved_board_menu");

    // Create saved boards for openings, since they are stored by
    // board position rather than name.
    SAVED_BOARDS["Chess Openings"] = {};
    for (var opening_board in OPENINGS) {
        if (OPENINGS.hasOwnProperty(opening_board)) {
            var opening_name = OPENINGS[opening_board];

            SAVED_BOARDS["Chess Openings"][opening_name] = opening_board;
        }
    }

    document.onkeydown = function(event) {
            event = event || window.event;

            if (!event.keyCode) { 
                return;
            }
            // TODO: type move to do it

            // Shift opens piece inspector. Usually it is invoked on mouse
            // over if shiftKey is held down; this case catches if shift is
            // pressed while the mouse is /already/ over the piece.
            if (event.keyCode === 16) {
                GAME_STATE.shift = true;
                if (GAME_STATE.piece_under) {
                    show_piece_inspector(GAME_STATE.piece_under);
                    over_piece(GAME_STATE.piece_under, {});
                }
            }
        };

    document.onkeyup = function(event) {
        event = event || window.event;

        if (!event.keyCode) {
            return;
        }

        if (event.keyCode === 16) {
            if (GAME_STATE.shift === 1) {
                // When releasing shift, unhighlight opponent's moves, if any
                var save = GAME_STATE.piece_under;
                out_piece(GAME_STATE.piece_under, {});
                GAME_STATE.piece_under = save;
            }

            GAME_STATE.shift = false;
            hide_piece_inspector();
        }
    }


    // Get board name in cookie, if any. This lets the user select
    // their favorite board, and revisit the page, and it will
    // automatically load, instead of standard chess.
    var selected_board_group = dojo.cookie("board_group");
    var selected_board_name = dojo.cookie("board_name");
    if (!selected_board_name) {
        selected_board_group = DEFAULT_BOARD_GROUP;
        selected_board_name = DEFAULT_BOARD_NAME;
    }

    // Saved boards by group
    var index = 0, sel_index;
    for (var group_name in SAVED_BOARDS) {
        if (SAVED_BOARDS.hasOwnProperty(group_name)) {
            var members = SAVED_BOARDS[group_name];

            var group = dojo.create("optgroup", {label:group_name});
            board_menu.appendChild(group);

            for (var board_name in members) {
                if (members.hasOwnProperty(board_name)) {
                    var fen = members[board_name];
                    if (group_name === selected_board_group && board_name === selected_board_name) {
                        sel_index = index;
                    }
                    group.appendChild(dojo.create("option", 
                                {value: fen, innerHTML:board_name}));
                    index += 1;
                }
            }
        }
    }

    // Select loaded board. Could use selected attribute, but Firefox selects last item,
    // unless we set selectedIndex, so just do that.
    board_menu.selectedIndex = sel_index;

    var fen = SAVED_BOARDS[selected_board_group] && SAVED_BOARDS[selected_board_group][selected_board_name];
    if (!fen) {
        // Cookie corrupted? Load default.
        fen = SAVED_BOARDS[DEFAULT_BOARD_GROUP][DEFAULT_BOARD_NAME];
        board_menu.selectedIndex = 0;
    }

    if (!load_from_query_string()) {
        load_fen(fen);
    }


}

// Load board from URL query string, if any
function load_from_query_string()
{
    var query = query_string();
    if (!query.b) {
        // No board given
        return false;
    }

    // Flip/unflip board as needed. Avoid doing this unless
    // there is a change in the flip state, as it is expensive.
    // Needs to be done before loading.
    if (!!query.f !== !!PREFS.flipped) {
        label_board(query.f);
    }


    // TODO: convert query to PGN, then load that

    query.b = query.b.replace(/~/g, " ").replace(/\|/g, "/");
    load_fen(query.b);

    if (query.m) {
        dojo.forEach(query.m.split(","), function(move_text) {
                mv(move_text);
            });
    }

    if (query.c) {
        import_captured(query.c);
        update_captured_piece_images();
    }

    // Succeeded
    return true;
}



// Load a board from the drop down menu of SAVED_BOARDS.
function change_loaded_board(menu)
{
    if (!menu.value) {
        return;
    }

    var option = menu.options[menu.selectedIndex];
    var group = option.parentNode.label;        // optgroup 
    var name = option.innerHTML;
    dojo.cookie("board_group", group);
    dojo.cookie("board_name", name);

    load_fen(menu.value);
}

// Acknowledge that a piece was captured. Called by move_piece_to_square(), which
// does all the board manipulation. 
function piece_was_captured(piece, square)
{
    // If rook captured, remove castling privileges
    if (piece.type === "rook") {
        // Note that this is the first rank of the *other* player
        var opponent = opposite_color(GAME_STATE.active_color);
        var first_rank = opponent === "white" ? 1 : 8;
        
        // TODO: really would like to not have to hardcode this
        if (square.y === first_rank) {
            if (square.x === 1) {
                GAME_STATE.can_castle[opponent].clong = false;
                //console.log("no more long");
            } else if (square.x === 8) {
                GAME_STATE.can_castle[opponent].cshort = false;
                //console.log("no more short");
            }
        }
    }

    GAME_STATE.captured[piece.color].push(piece);
    update_captured_piece_images();
}

// Show captured with icons from GAME_STATE.captured
function update_captured_piece_images(piece)
{
    var captured = dojo.byId("captured_piece_images");

    captured.innerHTML = "";

    // Make miniature images. In this case it is better to specify the full
    // image size and have the browser scale it, instead of having it reference
    // a pre-scaled image, because of the higher latency involved in another request.
    var html = "";
    for (var i = 0; i < GAME_STATE.captured.white.length; i += 1) {
        var p = GAME_STATE.captured.white[i];
        // TODO: Allow in some games for these pieces to be dragged back to board.
        // Currently you can't really, even in setup mode.
        // For Shogi (but captured pieces would need to change colors), where can drop
        // captured pieces back onto the board. create_piece() then add captured class.
        html += '<img src="' + image_path_for(p.type, p.color) + '" class="captured"> ';

        var piece = create_piece(p.color, p.type);
        dojo.addClass(piece, "captured");
        piece.style.position = "static";

        captured.appendChild(piece);
    }
    for (var i = 0; i < GAME_STATE.captured.black.length; i += 1) {
        var p = GAME_STATE.captured.black[i];

        var piece = create_piece(p.color, p.type);
        piece.style.position = "static";
        dojo.addClass(piece, "captured");

        captured.appendChild(piece);
    }
}

// Get all the move notation texts and moves for a given piece and destination
// square combination. Returns an object structured by a property for each
// promotion piece type (queen, knight, etc.) or undefined if not a promotion,
// then with keys: move, piece, square, and notations. The notations
// object has properties for each notation type, with strings as values.
// promote_to optionally narrows down the move to a specific promotion, otherwise,
// all promotion moves are returned (if it is a promotion).
function get_notations(piece, square, promote_to)
{
    var finds = {};
    var last_key;

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var texts = VALID_MOVE_NOTATIONS[notation];

            for (var text in texts) {
                if (texts.hasOwnProperty(text)) {
                    var this_square = texts[text].square;
                    var this_piece = texts[text].piece;
                    var this_move = texts[text].move;

                    if (this_square.x === square.x && this_square.y === square.y && 
                        this_piece.unique_id === piece.unique_id &&
                        (!promote_to || this_move.promote_to === promote_to)) {

                        // Key by final piece type. Promotion type, if any.
                        var key = this_move.promote_to || "undefined";
                        last_key = key;

                        if (!finds[key]) {
                            finds[key] = {
                                move: this_move, 
                                square: this_square,
                                piece: this_piece,
                                notations: {}};
                        }
                        
                        finds[key].notations[notation] = text;
                    }
                }
            }
        }
    }
  
    // Ensure that the 'undefined' key is always defined, so that for
    // promotions, the first half of the move can still be completed
    // without having a chosen promotion piece.
    // TODO
    /*if (!finds.undefined) {
        finds.undefined = finds[last_key];
    }*/

    return finds;
}

// Get the move(s) for the given piece moving to the given square, in all of the
// available move notations.
// TODO: kill XXX
function all_notations_from_piece_square(piece, square, text_input)
{
    var notation, results = {};

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            results[notation] = notation_from_piece_square(piece, square, text_input, notation);
        }
    }

    return results;
}

// Find precomputed algebraic notation for this move. Called when
// user drags a piece to a square and we don't know what move it is.
function notation_from_piece_square(piece, square, text_input, notation_type)
{
    notation_type = notation_type || form_value("output_notation");
    var notations = VALID_MOVE_NOTATIONS[notation_type];
    var finds = {}, find_count = 0, one;

    // TODO: better data structure, inverted hash table lookup
    for (var notation in notations) {
        if (notations.hasOwnProperty(notation)) {
            var this_piece = notations[notation].piece;
            var this_square = notations[notation].square;
            var this_move = notations[notation].move;

            if (this_square.x === square.x && this_square.y === square.y && 
                this_piece.unique_id === piece.unique_id &&
                // TODO: if given text_input, lookup more directly
                (!text_input || text_input === notation)) {

                notation.move = this_move;

                one = {notation:notation, move:this_move};
                finds[notation] = one;
                find_count += 1;

                if (!this_move.promote_to) {
                    // Speed hack: no-promotion moves are unique by pc+sq
                    return one;
                }
            }
        }
    }

    if (find_count === 0) {
        return null;
    } else if (find_count === 1) {
        return one;
    } else {
        // When player drags a pawn to the last rank to be promoted,
        // four moves will be found, and they'll have to choose. Make this appear
        // to be the last found promotion option, since they all have the same
        // location, and the piece will be able to move into place before the 
        // user piece selection is made.
        return dojo.mixin(one, {multiple:true, choices:finds});
    }
}

// Get the direction vector (y component only) that is "forward" for the given color
function forwards_vector(color)
{
    if (color === "white") {
        return 1;
    } else { 
        return -1;
    } 
}



// Make a move or half-move on the virtual board given piece + square.
// If is_hypothetical is true, this is an internal move part of another move
// (castling) so it shouldn't be logged.
// If is_immediate, then finish_up_move() will realize the virtual board.
// If piece_square.promote_to is given, it is the name of the piece type to promote to - along with
// piece and square, this uniquely identifies a move (a1Q, a1N, etc.) whereas if only
// piece + square are given, the promotion piece type will have to be queried.
function move_piece_to_square(piece, square, is_hypothetical, is_immediate)
{
    var choices, surrogate;

    // Get all possible moves for this piece+square combination, keyed
    // by promotion type (or undefined). A move like c8 as invoked by drag
    // and drop expands here to c8Q, c8N, c8R, c8B.
    choices = get_notations(piece, square);
    assert(choices, "move_piece_to_square(" + piece + ", " + square + "): could not find notation");

    execute_move(undefined, choices, is_hypothetical, is_immediate);
}

// Make a move, or half-move, given choices.
function execute_move(promote_to, choices, is_hypothetical, is_immediate, is_raw) 
{
    var piece, square, promote_to;
    var from_square, move_text, filerank, only_move, move, choices, did, one;
  
    if (choices[promote_to]) {
        one = choices[promote_to];
    } else {
        // Surrogate move, for location only
        one = choices.bishop;
    }
    move = one.move;
    piece = one.piece;
    square = one.square;
    from_square = piece.square;

    if (!is_hypothetical) {
        // Pieces captured /before/ this move
        GAME_STATE.last_captured = export_captured();

        // For highlighting recent move on board
        GAME_STATE.recent_square = from_square;
        GAME_STATE.recent_piece = piece;

        // Moving king makes it ineligible for castling
        if (move.clear_castle_short) {
            GAME_STATE.can_castle[GAME_STATE.active_color].cshort = false;
        }

        if (move.clear_castle_long) {
            GAME_STATE.can_castle[GAME_STATE.active_color].clong = false;
        }

        // If moved either rook, can't castle on that side.
        if (PIECE_TYPES[piece.type].castle) {
            // TODO: More generic, so will work with chess960 or 480
            if (from_square.x === 8) {
                GAME_STATE.can_castle[GAME_STATE.active_color].cshort = false;
            } else if (from_square.x === 1) {
                GAME_STATE.can_castle[GAME_STATE.active_color].clong = false;
            }
        }

        // If moved pawn, or was a capture, reset fifty move rule counter
        if (move.capture || PIECE_TYPES[piece.type].resets_50move) {
            GAME_STATE.halfmove_clock = 0;
        } else {
            GAME_STATE.halfmove_clock += 1;
        }

        var real_square = SQUARES[square.x][square.y];
        var real_from_square = SQUARES[from_square.x][from_square.y];

        // Remove old from square highlighting, and re-add new. This makes it
        // persist after the move has been made, to show what happened.
        dojo.query(".recent-move-black").removeClass("recent-move-black");
        dojo.query(".recent-move-white").removeClass("recent-move-white");
        dojo.addClass(real_from_square, " recent-move-" + real_from_square.color);

        // Re-highlight to-square
        dojo.query(".dropping-square").removeClass("dropping-square");
        dojo.query(".dropped-square").removeClass("dropped-square");
        dojo.addClass(real_square, " dropped-square");
    }

    // If castling, move the rook in place. Ugly hardcoded.
    // Note: if pass this in abs_move/choices, need to save in raw move notation, too.
    if (piece.type === "king") {
        // TODO: test with chess960 positions
        var first_rank = (GAME_STATE.active_color === "white" ? 1 : 8);
        if (from_square.x === 5) {
            if (square.x === 7) {
                // TODO: actually calculate square moved over, then move rook there
                // (instead of hardcoding). Short.
                move_piece_to_square(pc(8, first_rank, piece.virtual), VBOARD[6][first_rank], true, true);
            } else if (square.x === 3) {
                // Castle long.
                move_piece_to_square(pc(1, first_rank, piece.virtual), VBOARD[4][first_rank], true, true);
            }
        }
    }

    did = do_virtual_move(piece, move);
    if (did.captured) {
        piece_was_captured(did.captured, did.capture_square);
    }
    if (did.self_destructed) {
        piece_was_captured(did.piece, did.to_square);
    }

    if (!is_hypothetical) {
        // If double pawn move, this creates an en passant target square
        filerank = xy2filerank([square.x, square.y]);
        if (move.create_ep_target) {
            GAME_STATE.ep_target = move.create_ep_target;
        } else {
            // En passant possibility disappears immediately after any other move
            GAME_STATE.ep_target = null;
        }
    }

    if (should_promote(piece)) {
        if (own_property_count(choices) > 1) {
            // Piece+square move, need input from user: what piece 
            ask_to_promote(piece, choices, is_immediate);
        } else {
            for (var a in choices) {
                if (choices.hasOwnProperty(a)) {
                    promote_to = a;
                }
            }
            // Piece+square+piece to promote has been given (probably from mv())
            promote(piece, square, promote_to, choices.notation, is_immediate);
        }
    } else {
        // If not a multi-move (moving rook in castling), log and go to next turn
        if (!is_hypothetical) {
            finish_up_move(choices, is_immediate, undefined, is_raw);
        }
    }


    // TODO: return from finish_up_move, deferred? promotions..
    // To allow undo_virtual_move
    //return did;
}

// Perform bookkeeping on the move after it has been actually made, 
// in move_piece_to_square().
// promote_to is the type for promotions, or undefined otherwise.
function finish_up_move(tieback, is_immediate, promote_to, is_raw)
{
    var alg_move, ply, turn_info, move_text, info;

    if (is_immediate) {
        // Display the new board state
        realize_vboard();
    }

    info = tieback[promote_to];

    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fullmove_number);
  
    info.only_move = own_property_count(VALID_MOVE_NOTATIONS.SAN) === 1;
    // TODO: skip move calculation if is_raw
    turn_info = set_turn("next", false);

    if (turn_info.text_move) { info.add_text = turn_info.text_move; }
    if (turn_info.text_end) { info.text_end = turn_info.text_end; } 
    // If there was a repetition, it occurred on this move. Indicate the moves.
    if (turn_info.repeats) { 
        turn_info.repeats.push(ply);
        info.repeats = turn_info.repeats;
    }

    // Save for history
    GAME_STATE.made_moves[ply] = info;

    var opening = OPENINGS[active_fen(true)];
    if (opening) {
        dojo.byId("opening_name").innerHTML = opening;
    }
    // If not recognized, do not clear it -- keep up opening during the game

    if (is_immediate) {
        set_copyable_link();

        show_move_history();
        populate_make_a_move_list();
        computer_move_if_applicable();
    }
}

// Fill in move_history with the move history
function show_move_history()
{
    var htmls = [];
    var first = true;

    for (var ply = 1; ply < GAME_STATE.made_moves.length; ply += 1) {
        var color_fullmove, color, fullmove_number, move_text, move_info, only_move;

        color_fullmove = decode_ply(ply);
        color = color_fullmove.color;
        fullmove_number = color_fullmove.fullmove_number;

        move_info = GAME_STATE.made_moves[ply];
        if (!move_info) {
            continue;
        }

        move_text = move_info.notations[form_value("output_notation")];
        
        if (color === "white") {
            htmls.push('<span class="fullmove_number">' + fullmove_number + '<\/span>');
            // Period goes to initial position, kind of strange, but its uninstrusive
            htmls.push(first ? move_link(0, ".") : ".");
        } else {
            // Ellipsis if black is first recorded move,
            // TODO: or intervening commentary
            if (first) {
                htmls.push('<span class="fullmove_number">' + fullmove_number + '<\/span>');
                htmls.push(first ? move_link(0, ".") : ".");
                htmls.push("&hellip; ");
            }
        }

        htmls.push(" " + move_link(ply, move_text));

        if (move_info.only_move) {
            // NAG for "only move", see http://www.markalowery.net/Chess/Notation/NAG.html
            htmls.push("$7 ");
        }

        if (move_info.add_text) {
            htmls.push(move_info.add_text);
        }

        if (move_info.repeats) {
            mark_repeated_moves(move_info.repeats);
        }

        // End-text, not a move. Terminates the game.
        if (move_info.text_end) {
            htmls.push("\n" + move_info.text_end);
        }

        htmls.push(" ");

        first = false;
    }

    dojo.byId("move_history").innerHTML = htmls.join("");

    // Last ply
    $$("a.active_move").each(function(m) {
            dojo.removeClass(m, "active_move");
        });

    set_next_back_accesskeys(ply);
}

// Visually indicate the moves which after threefold repetition
// Unfortunately, we highlight the move *after* the board state was repeated. This is
// because the first clickable link, say 1. Nf3, loads the move after
// Nf3 was made, not before (the initial board position). But you can
// repeat the initial board position:
// 1. Nf3 Nf6 2. Ng1 Ng8 3. Nf3 Nf6 4. Ng1 Ng8
var HIGHLIGHT_COLORS = ["yellow", "aquamarine", "lime", "khaki", "aqua"];
var REPEAT_COLOR_COUNT = 0;
function mark_repeated_moves(reps)
{
    var color = HIGHLIGHT_COLORS[REPEAT_COLOR_COUNT];

    REPEAT_COLOR_COUNT += 1;
   
    var setcolor = function(m) {
                //dojo.addClass(m, "repeated_move");
                m.setStyle({backgroundColor: color});
            };

    for (var i = 0; i < reps.length; i += 1) {
        var ply = reps[i];

        $$("a#ply_" + ply).each(setcolor);
    }
}

// Handle graphically moving of a piece, dropping it to its new location
function move_dropped_piece(piece, square, event)
{
    //console.log(piece);
    //console.log(square);
 
    // TODO: Consider setting piece.style.position to static here, so it is 
    // static when stationary, and change it to absolute (absolutize) when dragging..
    // Any way to finish running the code AFTER the effect finishes? New effect?
    //if (square.firstChild) {
        // Consider animating opacity or width+height (with dojo.anim or CSS transitions)
    //}

    // Visually rehome piece. This is a UI speed hack: after move_piece_to_square() is
    // called, realize_vboard() will finalize the board position, moving any other
    // pieces (castling, en passant, snapback, etc.) -- but it feels faster to have
    // the piece immediately move to its destination. This is optional.
    while(square.firstChild) {
        square.removeChild(square.firstChild);
    }
    piece.style.position = "relative";
    piece.style.top = piece.style.left = 0;
    square.appendChild(piece);

    if (PREFS.setup_mode) {
        var from_square = piece.square;

        do_virtual_move(piece, {x:square.x, y:square.y});
        unhighlight_all();
        dojo.query(".recent-move-black").removeClass("recent-move-black");
        dojo.query(".recent-move-white").removeClass("recent-move-white");
        dojo.query(".dropped-square").removeClass("dropped-square");
        if (from_square) { 
            dojo.addClass(from_square, "dropped-square");
        }

        realize_vboard();
        return;
    }


    var virtual_square = VBOARD[square.x][square.y];
    var virtual_piece = VBOARD[piece.square.x][piece.square.y].piece;

    // Move the piece in the virtual board and realize it.
    setTimeout(function() { 
            unhighlight_all();
            move_piece_to_square(virtual_piece, virtual_square, false, true) 
        }, 0);
}

// Get the representation of the active board state in FEN.
// If strip_moves, return time-independent representation.
function active_fen(strip_moves)
{
    var fen = GAME_STATE.position_after.slice(-1)[0];

    if (strip_moves) {
        // Remove last two fields, move counts.
        fen = fen.split(" ").slice(0, -2).join(" ");
    } 

    return fen;
}

// Generate FEN from board state. Use active_fen() to get
// this if it already been calculated.
function save_fen()
{
    var fen = "", castles;

    // Board position
    for (var y = RANK_MAX; y > 0; y -= 1) {
        var blanks = 0;
        for (var x = 1; x <= FILE_MAX; x += 1) {
            var piece = VBOARD[x][y].piece;
            var letter;

            if (piece) {
                if (blanks) {
                    fen += blanks.toString();
                    blanks = 0;
                }
                letter = full_piece_prefix(piece);

                // Uppercase = white, lowercase = black
                if (piece.color === "black") {
                    letter = letter.toLowerCase();
                }

                fen += letter;
            } else {
                blanks += 1;
            }
        }
        if (blanks) {
            fen += blanks.toString();
        }
        if (y !== 1) {
            fen += "/";
        }
    }

    // Active color
    fen += " ";
    if (GAME_STATE.active_color === "white") {
        fen += "w";
    } else {
        fen += "b";
    }

    // Castling availability
    fen += " ";
    castles = false;
    if (GAME_STATE.can_castle.white.cshort) { fen += "K"; castles = true; }
    if (GAME_STATE.can_castle.white.clong)  { fen += "Q"; castles = true; }
    if (GAME_STATE.can_castle.black.cshort) { fen += "k"; castles = true; }
    if (GAME_STATE.can_castle.black.clong)  { fen += "q"; castles = true; }
    if (!castles) { fen += "-"; }

    // En passant target square
    fen += " ";
    if (GAME_STATE.ep_target) {
        fen += xy2filerank(GAME_STATE.ep_target);
    } else {
        fen += "-";
    }

    fen += " " + GAME_STATE.halfmove_clock;
    fen += " " + GAME_STATE.fullmove_number;

    return fen;
}

// Load board state in Forsyth-Edwards Notation. If replay is true, this is reloading an 
// existing position, not loading a new game.
// TODO: support EPD, and special rules
// TODO: support any base 10 number (10 for skip ten spaces), and asterisks for filling remainder of rank with empty
// spaces, and {} for labels, see http://play.chessvariants.org/pbm/devguide.html
function load_fen(fen, replay)
{
    var parts, castling, color;

    parts = fen.split(" ");
    load_starting_position(parts[0], replay);

    assert(/^[wb]$/.test(parts[1]), "load_fen(" + fen + "): bad active color: " + parts[1]);

    castling = parts[2];
    GAME_STATE.can_castle.white.cshort = /K/.test(castling);
    GAME_STATE.can_castle.white.clong  = /Q/.test(castling);
    GAME_STATE.can_castle.black.cshort = /k/.test(castling);
    GAME_STATE.can_castle.black.clong  = /q/.test(castling);

    if (parts[3] === "-") {
        GAME_STATE.ep_target = null;
    } else {
        GAME_STATE.ep_target = filerank2xy(parts[3]);
    }

    GAME_STATE.halfmove_clock = parseInt(parts[4], 10);
    GAME_STATE.fullmove_number = parseInt(parts[5], 10);

    color = {w:"white", b:"black"}[parts[1]];

    if (!replay) { 
        GAME_STATE.position_moves = {}; 
        GAME_STATE.position_after = [fen];  // 0th ply = initial state

        var ply = encode_ply(color, GAME_STATE.fullmove_number);
        GAME_STATE.position_after[ply] = fen;

        GAME_STATE.ended = null; 
        GAME_STATE.captured = {white:[], black:[]};
        GAME_STATE.made_moves = [null];
        GAME_STATE.made_moves[ply] = null;

        dojo.query(".recent-move-black").removeClass("recent-move-black");
        dojo.query(".recent-move-white").removeClass("recent-move-white");
        dojo.query(".dropped-square").removeClass("dropped-square");

        update_captured_piece_images();
    }
   
    // Now that everything is loaded, set the turn.
    make_vboard();
    set_turn(color, replay);
    populate_make_a_move_list();
}

// Remove all pieces from the board.
function clear_board()
{
    for (var x = 1; x <= RANK_MAX; x += 1) {
        for (var y = 1; y <= FILE_MAX; y += 1) {
            var square = SQUARES[x][y];
            while(square.firstChild) {
                square.removeChild(square.firstChild);
            }
        }
    }
}

// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR.
// If !replay, name pieces.
function load_starting_position(fen, replay)
{
    var i, x, y, code;

    clear_board();

    // Note that ranks and files internally are represented here by
    // x,y coordinates, so a8 = 1,8. That is where FEN starts.
    x = 1;
    y = 8;
    for (i = 0; i < fen.length; i += 1) {
        code = fen.charAt(i);
        if (code === "X" || code === "x") {
            i += 1;
            code += fen.charAt(i);

            // Expanded FEN codes
            if (code === "X(" || code === "x(") {
                // Read until closing paren
                var ch;
                i += 1;
                while(i < fen.length) {
                    ch = fen.charAt(i);
                    code += ch;
                    if (ch === ")") { break; }
                    i += 1;
                }
            }

            SQUARES[x][y].appendChild(create_piece_by_letter(code));
            SQUARES[x][y].firstChild.square = SQUARES[x][y];
            //VBOARD[x][y].piece = decode_piece_letter(code);
            //VBOARD[x][y].piece.square = VBOARD[x][y];
            x += 1;
        } else if (/[a-zA-Z]/.test(code)) {
            SQUARES[x][y].appendChild(create_piece_by_letter(code));
            SQUARES[x][y].firstChild.square = SQUARES[x][y];
            //VBOARD[x][y].piece = decode_piece_letter(code);
            //VBOARD[x][y].piece.square = VBOARD[x][y];
            x += 1;
        } else if (code === "/") {
            x = 1;
            y -= 1;
        } else if (/[0-9]/.test(code)) {
            x += code.charCodeAt(0) - "0".charCodeAt(0);
        } else if (code === " ") {
            break;
        } else {
            assert(false, "load_starting_position(" + fen + "): unknown code: " + code);
        }
    }

    if (!replay) {
        name_pieces();
        // Clear move history. TODO: Better way.
        dojo.byId("move_history").innerHTML = "";
    }
}

//// PIECE LIBRARY / INFO FUNCTIONS

// Show all available images, even those without movement
function show_library_images()
{
    var root = "images/" + PREFS.image_set + "/";
    var used_paths = {}, count;

    count = 0;
    // Map path of used image to piece type it is used for
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            // Mark all images used, including alternates
            var paths = image_path_for(type, "white", true);

            for (var i = 0; i < paths.length; i += 1) {
                used_paths[paths[i]] = type + (i === 0 ? "" : " (alternate image)");
                count += 1;
            }
        }
    }

    // Get list of all images, even those not being used in a piece
    dojo.xhrGet({url:root + "list.txt", load:function(text) {
        var images = text.split("\n");

        document.write("<html><head><title>All piece images</title></head><body>");
        document.write("<h1>All piece images</h1>");
        document.write("<h2>" + count + " of " + images.length + " (" + 
            Math.round(count / images.length * 100) + "%) defined" + "</h2>");
        document.write("<p>This is a list of all blue and white piece images available in the <b>" + PREFS.image_set + "</b> image set, including those that are not assigned to a piece. See also: <ul>");
        document.write("<li><a href=\"images/" + PREFS.image_set + "\">Directory listing</a>");
        document.write("<li><a href=\"images/" + PREFS.image_set + "/README.html\">README</a>");
        document.write("</ul>");

        document.write("<table>");
        for (var i = 0; i < images.length; i += 1) {
            var image = images[i];

            if (!image) {
                continue;
            }

            var wpath = root + "w" + image + ".gif";
            var bpath = root + "b" + image + ".gif";

            document.write('<tr>');
            document.write('<td>' + i + '.</td>');
            document.write('<td><img src="' + wpath + '"></td>');
            document.write('<td><img src="' + bpath + '"></td>');
            document.write('<td>' + image + '</td>');
            document.write('<td>' + (used_paths[wpath] || "") + '</td>');
            document.write('</tr>');
        }
        document.write('</table></body></html>');
    }});
}

// Disable or enable game setup mode
function set_setup_mode(on)
{
    // Set setup mode as opening/closing piece library, since that is what it is for
    dojo.byId("enable_setup_mode").checked = on;
    PREFS.setup_mode = on;

    if (!on) {
        // Exited setup mode, so calculate moves with new setup
        calculate_moves(GAME_STATE.active_color);
    }
}

// Show the piece library, of readily usable pieces with defined movement
function toggle_piece_library()
{
    var table, lib, want_setup_mode, parent, i, wp, bp;

    parent = dojo.byId("piece-library-parent");
    want_setup_mode = parent.style.display === "none";
    new Effect.toggle(parent, 'slide', { duration: 0.1 });

    // Set setup mode as opening/closing piece library, since that is what it is for
    set_setup_mode(want_setup_mode);

    // Lazily generate the table. 
    lib = dojo.byId("piece-library");
    if (dojo.byId("piece-library-table")) {
        return;
    }

    // TODO: sortable columns, searchable table, so can list by symbol, alphabetically,
    // royal pieces first, pieces that promote, and find what you want.
    // IE7 chokes due to the fix for http://dev.rubyonrails.org/ticket/2707
    // TODO: Find out why this table doesn't display in IE7
    table = dojo.create("table", {id:"piece-library-table"});
    tbody = dojo.create("tbody");
    table.appendChild(tbody);
    var r1 = dojo.create("tr");
    tbody.appendChild(r1);
    var c1 = dojo.create("th", {innerHTML:"White"});
    r1.appendChild(c1);
    var c2 = dojo.create("th", {innerHTML:"Black"});
    r1.appendChild(c2);
    var c3 = dojo.create("th", {style:"text-align: left", innerHTML:"Name"});
    r1.appendChild(c3);

    i = 0;
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            wp = create_piece("white", type);
            bp = create_piece("black", type);

            // Not directly draggable, since these elements are absolutely 
            // positioned inside a relatively positioned element. But keep
            // them as pieces so you can shift-hover to open the piece
            // inspector.
            dojo.addClass(wp, "tear-off");
            dojo.addClass(bp, "tear-off");

            /*
            // TODO: Create another piece under when drag off, so
            // more will always be available.
            wp.onmousedown = bp.onmousedown = function(event) {
                var target, tear;
               
                // Torn off piece
                tear = create_piece(this.color, this.type);

                // TODO: position
                
                event = event || window.event;
                target = event.target !== undefined ? event.target : event.srcElement;

                //= target.offsetLeft;
                //= target.offsetTop;
                //tear.style.left = dojo._abs(target, true).x + "px";
                //tear.style.top = dojo._abs(target, true).y + "px";
 
                dojo.body().appendChild(tear);
            };*/

            var row = dojo.create("tr");
            var white_cell = dojo.create("td", {"class": "square"}, row);
            white_cell.appendChild(wp);
            var black_cell = dojo.create("td", {"class": "square"}, row);
            black_cell.appendChild(bp);
            dojo.create("td", {innerHTML:type}, row);
    
            tbody.appendChild(row);
            i += 1;
        }
    }

    lib.appendChild(table);
    lib.appendChild(dojo.create("p", {innerHTML: i + " pieces available"}));
    lib.appendChild(dojo.create("a", {href: "#", onclick:"show_library_images()", 
                innerHTML:"show all images (clears page)"}));
}

// Show information on a piece
function show_piece_inspector(piece)
{
    var symbols, type_info, misc, images, paths;
    var inspector = dojo.byId("piece-inspector");

    type_info = PIECE_TYPES[piece.type];

    dojo.byId("inspector-type").innerHTML = piece.type;

    // Show all the images, in order of preference.
    image_html = "";
    paths = image_path_for(piece.type, piece.color, true);
    for (var i = 0; i < paths.length; i += 1) {
        image_html += "<img src=\"" + paths[i] + "\"> ";
    }

    dojo.byId("inspector-image").innerHTML = image_html;
    dojo.byId("inspector-movement").innerHTML = type_info.parlett.replace(/&/g, "&amp;");

    // Symbols (letter, figurine, number) for notations
    symbols = [];
    if (type_info.letter) {
        symbols.push(type_info.letter);
    } else {
        symbols.push("X(" + piece.type + ")");
    }
    if (type_info.alg_letter) {
        symbols.push(" (algebraic: " + type_info.alg_letter + ")");
    }
    if (type_info.figurines) {
        symbols.push(", " + type_info.figurines.join(", "));
    }
    if (type_info.iccf_number) {
        symbols.push(", " + type_info.iccf_number);
    }
    dojo.byId("inspector-symbols").innerHTML = symbols.join("");

    // Other settings
    misc = [];
    if (type_info.promote) {
        // TODO: links to view other pieces?
        misc.push("Promotes to " + type_info.promote.join(", ") + "<br>");
    }
    if (type_info.royal) {
        misc.push("Royal (can be checked/checkmated)<br>");
    }
    if (type_info.resets_50move) {
        misc.push("Resets 50-move counter<br>");
    }
    if (type_info.castles_with) {
        misc.push("Castles with " + type_info.castles_with + "<br>");
    }
    if (type_info.castle) {
        misc.push("Is a castle<br>");
    }
    if (type_info.invincible) {
        misc.push("Invincible (cannot be captured)<br>");
    }
    if (type_info.url) {
        misc.push("<em>Additional information is available by shift-clicking the piece</em>");
    }

    dojo.byId("inspector-info").innerHTML = misc.join("");

    inspector.style.display = "";
}

// Open an external website with more information on a piece, if any
function open_piece_url(piece)
{
    var type_info = PIECE_TYPES[piece.type];

    if (type_info.url) {
        var url = type_info.url;
        if (url.substr(0, 3) === "pc:") {
            url = "http://www.chessvariants.org/piececlopedia.dir/" + url.substr(3) + ".html";
        }
        window.open(url);
    } else {
        //alert("No additional information is available for " + piece.type);
    }
}


// Hide information on the piece shown, if any
function hide_piece_inspector()
{
    var inspector = dojo.byId("piece-inspector");

    inspector.style.display = "none";
}

//// PIECE FUNCTIONS

// Name each piece, in standard chess1 locations, using English descriptive notation.
function name_pieces()
{
    var piece, descriptive_name;

    for (var file_number = 1; file_number <= FILE_MAX; file_number += 1) {
        // English descriptive notation (only really applicable to chess1)
        var file = xy2descriptive("white", file_number);

        // White's pieces and pawns
        piece = pc(file_number, 1); if (piece) { piece.descriptive_name = file; }
        piece = pc(file_number, 2); if (piece) { descriptive_name = file + "P"; }

        // Black's pieces and pawns
        piece = pc(file_number, 8); if (piece) { descriptive_name = file; }
        piece = pc(file_number, 7); if (piece) { descriptive_name = file + "P"; }


        // Algebraic descriptive notation
        var afile = xy2filerank(file_number, "");
        for (var white_rank = 1; white_rank <= RANK_MAX; white_rank += 1) {
            var black_rank = 9 - white_rank;
            piece = pc(file_number, white_rank);
            var rank, piece_letter;

            if (!piece) {
                continue;
            }

            if (piece.color === "white") {
                rank = white_rank;
            } else {
                rank = black_rank;
            }

            piece_letter = full_piece_prefix(piece);
            // aP, bP, etc.. TODO: use rank, if needed to disambiguate (two
            // pieces of same type on same file). Use file, rank, or filerank
            // like disambiguating moves.
            piece.adescriptive_name = afile + piece_letter;

            // Unique identifier of piece. TODO: Use adescriptive_name, make it disambiguated
            // so it will be always unique and descriptive.
            piece.unique_id = afile + "" + white_rank + piece_letter;
        }
    }
}

/// TODO: a "piece lab", where can dynamically create new pieces,
// browse existing pieces. Show piece on board by itself, highlighting 
// valid moves, update when change Parlett movement types, allow to operate
// the piece and see how it behaves. Then return to the main board.

// Return the letter, if any, used for representing the piece type (name)
// in algebraic notation.
function algebraic_letter(type)
{
    if (PIECE_TYPES[type].alg_letter !== undefined) {
        return PIECE_TYPES[type].alg_letter;
    } else {
        return PIECE_TYPES[type].letter;
    }
}

// Given a letter, find the name of the piece (R = rook, etc.). The letter
// can either be for FEN (P = pawn), or algebraic notation (blank = pawn);
// both are recognized.
var cache_letter2name;
function piece_letter2name(letter)
{
    // If given a name, return what we were given.
    if (PIECE_TYPES[letter]) {
        return letter;
    }

    letter = letter.toUpperCase();

    if (!cache_letter2name) {
        cache_letter2name = {};

        for (var name in PIECE_TYPES) {
            if (PIECE_TYPES.hasOwnProperty(name)) {
                var info = PIECE_TYPES[name];

                if (info.letter !== undefined) {
                    cache_letter2name[info.letter] = name;
                } else if (info.alg_letter !== undefined) {
                    cache_letter2name[info.alg_letter] = name;
                }
            }
        }
    }

    return cache_letter2name[letter.toUpperCase()];
}

// Return the full piece prefix, succiently indicating the piece type.
// Will not return an empty string but may return E-FEN piece codes. 
function full_piece_prefix(piece)
{
    var letter = PIECE_TYPES[piece.type].letter;

    if (letter !== undefined) {
        return letter;
    } else {
        return "X(" + piece.type + ")";
    }
}

// Return the full piece prefix using lowercase for black, uppercase for white.
// The resulting code can be decoded with decode_piece_letter().
function color_piece_prefix(piece)
{
    var letter = full_piece_prefix(piece);
    var first = letter.substr(0, 1);
    var rest = letter.substr(1);

    if (piece.color === "white") {
        return first.toUpperCase() + rest;
    } else {
        return first.toLowerCase() + rest;
    }
}

// Return algebraic prefix for a piece. May return an empty 
// string (for pawns, for example): prefers alg_letter over letter.
// To always get a non-empty string, use full_piece_prefix() instead.
function algebraic_piece_prefix(piece)
{
    if (PIECE_TYPES[piece.type].alg_letter !== undefined) {
        return PIECE_TYPES[piece.type].alg_letter;
    } else {
        return full_piece_prefix(piece);
    }
}

// Get the Unicode figurine for a piece of a given color, or fall back on 
// algebraic_piece_prefix if there isn't one.
function figurine_piece_prefix(color, piece)
{
    if (PIECE_TYPES[piece.type].figurines) {
        return PIECE_TYPES[piece.type].figurines[color === "white" ? 0 : 1];
    } else {
        return algebraic_piece_prefix(piece);
    }
}

// Return a piece at (x,y), or "offboard" if the coordinates are out of range.
// If virtual, operates on VBOARD, otherwise on SQUARES.
// TODO TODO: Make it only operate on virtual?
function pc_or_offboard(x, y, virtual)
{
    if (x < 1 || y < 1 || x > FILE_MAX || y > RANK_MAX) {
        return "offboard";
    }

    return pc(x, y, virtual);
}

// Return an existing piece somewhere (or a false value), given:
// - (x,y) coordinates, like (8,1)
// - location in filerank notation, like "a8"
// To get piece from a square, use .piece if virtual, or .firstChild if not
function pc(x, y, virtual)
{
    if (x.charAt) {
        var xy = filerank2xy(x);
        x = xy[0];
        y = xy[1];
    }

    //assert(x >= 1 && x <= FILE_MAX, "pc(" + x + ", " + y + "): bad x: " + x);
    //assert(y >= 1 && y <= RANK_MAX, "pc(" + x + ", " + y + "): bad y: " + y);

    return virtual ? VBOARD[x][y].piece : SQUARES[x][y].firstChild;
}

// Return the path to an image for the piece of that color.
// If all, then returns an array of all images including alternates,
// otherwise returns preferred.
function image_path_for(type, color, all)
{
    var bases, image_list, paths;

    assert(PIECE_TYPES[type], "image_path_for(" + type + ", " + color + "): no such piece type");

    // Override image name
    image_list = PIECE_TYPES[type].image;
    if (image_list) {
        // Choose first from array if is an array
        bases = dojo.isArray(image_list) ? image_list : [image_list];
    } else {
        bases = [type];
    }

    // TODO: Use .style.webkitTransform="rotate(45deg)" etc. to get rotated pieces,
    // instead of having rotated images saved! Would allow anything to be rotated.

    // Rejected TODOs, lack support:
    // - pngs
    // - use Unicode characters in a span!! How cool would that be? Infinite resolution.
    //   See for example http://en.wikipedia.org/wiki/Knight_(chess)
    //   Unfortunately, MSIE doesn't seem to support it, though it should..different font?
    // - Web fonts! Supported on Firefox 3.1+, Opera 10+, Safari 3.1+, IE4+
    //   See http://fonts.philip.html5.org/
    
    paths = [];
    for (var i = 0; i < bases.length; i += 1) {
        paths.push(["images/", PREFS.image_set, "/", {white:"w", black:"b"}[color], bases[i], ".gif"].join(""));
    }

    return all ? paths : paths[0];
}

// Decode Forsyth-Edwards Notation piece code, for example:
//  r = black rook, R = white rook, N = white knight
// Also allows extended names, X(elephant), x(elephant), etc.
// To encode, use color_piece_prefix().
function decode_piece_letter(name)
{
    var color, type;

    // In FEN, uppercase=white, lower=black
    if (/^[A-Z]/.test(name)) {
        color = "white";
    } else if (/^[a-z]/.test(name)) {
        color = "black";
    } else {
        assert(false, "create_piece_by_letter(" + name + "): not a letter");
    }
    name = name.toLowerCase();

    // x(name) or X(name) is explicit name, otherwise, is a letter
    if (/\(/.test(name)) {
        var ary = /^[xX]\(([^)]+)/.exec(name);
        type = ary[1];
    } else {
        type = piece_letter2name(name);
    }

    return {color: color, type: type};
}

// Create a new piece or pawn, given the letter.
function create_piece_by_letter(name)
{
    var decoded = decode_piece_letter(name);

    return create_piece(decoded.color, decoded.type);
}

// Called when mouse is over a piece
function over_piece(piece, event) 
{
    var square = highlight_moves(piece, true);
    // for debugging
    //piece.setStyle({border: '1px solid black'});
    if (square) {
        dojo.addClass(square, "recent-move-" + square.color);
    }
   
    if (event.shiftKey) {
        show_piece_inspector(piece);
    }
    GAME_STATE.piece_under = piece;
}

// Called when mouse is no longer over a piece
function out_piece(piece, event)
{
    var square = highlight_moves(piece, false);
    //piece.setStyle({border: 'none'});
    if (square) {
        dojo.removeClass(square, "recent-move-" + square.color);
    }
   
    if (!event.shiftKey) {
        hide_piece_inspector();
    }

    GAME_STATE.piece_under = null;
}


// Create a new piece by color and type (full name).
// TODO: make this a constructor so you can do new Piece().
function create_piece(color, type)
{
    var filename, piece, classes;

    assert(type, "create_piece(" + type+ "): unrecognized piece type: " + type);

    filename = image_path_for(type, color);

    // CSS classes, can use with $$ and also shown in toString (useful 
    // for debugging), however, note that code should not use this, because
    // all the classes are in a space-separated string, .className, according to
    // the DOM, and Prototype's hasClassName uses a slow RegExp to parse it,
    // and dojo's hasClass uses indexOf so its faster, but it still involves
    // parsing, and it is ugly. Probably a design flaw, oh well.
    // Use .type and .piece (set below) instead of classes for speed.
    classes = ["draggable", "piece", color, type];

    // Royal class is very important.
    if (PIECE_TYPES[type].royal) {
        classes.push("royal");
    }

    // Create the node
    // TODO Use a div with background-image instead, then can have arbitrary
    // characters, instead of just images, more flexible, maybe transition too.
    piece = dojo.create("img", {src:filename, "class":classes.join(" "), 
            className:classes.join(" ")});

    // Property will tell name of piece. To tell what color, or if it is
    // a piece in the first place, check the class names.
    piece.type = type;
    piece.color = color;

    // Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
    // Yahoo Games does this too, but uses a yellow outline.
    Event.observe(piece, "mouseover", function(event) { over_piece(piece, event); });

    Event.observe(piece, "mouseout", function(event) { out_piece(piece, event); });

    // Make all new pieces draggable. I tried only making the active color's
    // pieces draggable, but then in Safari they can still be selected like text,
    // even with enable_document_selection(false), maybe I need to enable it on the
    // images too, but it wasn't appealing. In Firefox, the images can be dragged
    // as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
    // if they are the active colors move. The player can drag the opponent's pieces
    // around but not drop anywhere.

    return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
// Return the from square, if anything was highlighted.
function highlight_moves(piece, enable)
{
    var from_square, moves;

    // If player is dragging a piece over another piece, don't show
    // legal moves for the piece under it.
    if (!piece || DRAG.dragging) {
        return null;
    }

    from_square = piece.square;

    if (!from_square) {
        // Could not find a square for the piece, it no longer exists,
        // so no need to concern ourselves with highlighting its moves.
        return null;
    }

    //console.log(from_square.filerank);
   
    if (piece.color === GAME_STATE.active_color) {
        // Active player's pieces
        moves = VALID_MOVES[from_square.filerank];
    } else {
        // Opponent's pieces -- allow seeing valid moves if it was
        // their turn, if holding down shift.
        if (GAME_STATE.shift) {
            moves = VALID_MOVES_OPP[from_square.filerank];
            GAME_STATE.shift = 1;    // showing other player's moves
        } else {
            return null;
        }
    }


    //console.log(moves);
    if (!moves) {
        return null;    
    }

    moves.each(function(move) {
        var x, y, flags, to_square;
        
        x = move.x;
        y = move.y;
        flags = move;
        to_square = SQUARES[x][y];

        if (enable) {
            if (to_square.color === "white") {
                dojo.addClass(to_square, "legal-move-white");
            } else {
                dojo.addClass(to_square, "legal-move-black");
            }
        } else {
            dojo.removeClass(to_square, "legal-move-white");
            dojo.removeClass(to_square, "legal-move-black");
        }
    });

    return from_square;
}

// Unhighlight all highlighted black/white squares. Used in onEnd draggable, for
// some reason, highlight_moves(piece, false) does not unhighlight, maybe the piece changed..
function unhighlight_all()
{
    $$("td.legal-move-white", "td.legal-move-black").each(function(square) {
        dojo.removeClass(square, "legal-move-white");
        dojo.removeClass(square, "legal-move-black");
    });
}

//// SQUARE FUNCTIONS / FILE-RANK NOTATION

// Convert filerank f8 to the x,y coordinate [8,6], etc. These coordinates
// are used internally, but filerank notation is useful for human consumption
// (though I actually think better in descriptive notation, but maybe I'm in the minority there)
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// one-based table cell with (8,1) at the top-left. In filerank notation, this
// square is labeled a8. The bottom-right square (8,1) is filerank's h1.
function filerank2xy(code)
{
    var x = code.charCodeAt(0) - "a".charCodeAt(0) + 1; // corresponds to file (horizontal)
    var y = code.charCodeAt(1) - "1".charCodeAt(0) + 1; // corresponds to rank (vertical)

    //assert(x >= 1 && x <= FILE_MAX, "filerank2xy(" + code + "): bad x: " + x);
    //assert(y >= 1 && y <= RANK_MAX, "filerank2xy(" + code + "): bad y: " + y);

    return [x, y];
}

// Return an object with x and y from a filerank
// TODO: Replace filerank2xy with this
function filerank2obj(code)
{
    var xy = filerank2xy(code);

    return {x:xy[0], y:xy[1]};
}

// Convert from x,y coordinates to filerank notation for human consumption. Can either pass
// xy2filerank(1, 8) === "a8"
// xy2filerank([1, 8]) === "a8"
// xy2filerank(1, "") === "a"
function xy2filerank(x, y)
{
    var filerank;

    if (y === undefined) {
        // Passed array
        y = x[1];
        x = x[0];
    }

    //assert(x >= 1 && x <= FILE_MAX, "xy2filerank(" + x + ", " + y + "): bad x: " + x);
    //assert(y === "" || (y >= 1 && y <= RANK_MAX), "xy2filerank(" + x + ", " + y + "): bad y: " + y);

    filerank = String.fromCharCode(x + "a".charCodeAt(0) - 1);
    if (y !== "") {
        filerank += String.fromCharCode(y + "1".charCodeAt(0) - 1);
    }

    return filerank;
}


// Return name of square from color's perspective in English descriptive notation
// Accepts an array of two numbers, for file and rank, or just a file
// Only works for chess1, not any variants where the pieces are arranged differently.
function xy2descriptive(color, xy)
{
    var x, y;
    if (Object.isArray(xy)) {
        x = xy[0];
        y = xy[1];
    } else if (xy.x && xy.y) {
        x = xy.x;
        y = xy.y;
    } else {
        x = xy;
        y = "";
    }

    assert(x >= 1 && x <= FILE_MAX, "xy2descriptive(" + x + ", " + y + "): bad x: " + x);
    assert(y === "" || (y >= 1 && y <= RANK_MAX), "xy2descriptive(" + x + ", " + y + "): bad y: " + y);

    return [null, "QR", "QN", "QB", "Q", "K", "KB", "KN", "KR"][x] + (color === "white" ? y : 9 - y);
}

// Return name of square from color's perspective in "algebraic descriptive notation".
// Same file as xy2algebraic, but rank is from symmetric, not always white's perspective.
function xy2adescriptive(color, xy)
{
    var x, y;
 
    if (Object.isArray(xy)) {
        x = xy[0];
        y = xy[1];
    } else if (xy.x && xy.y) {
        x = xy.x;
        y = xy.y;
    } else {
        x = xy;
        y = "";
    }

    assert(x >= 1 && x <= FILE_MAX, "xy2adescriptive(" + x + ", " + y + "): bad x: " + x);
    assert(y >= 1 && y <= RANK_MAX, "xy2adescriptive(" + x + ", " + y + "): bad y: " + y);

    return xy2filerank(x, "") + (color === "white" ? y : 9 - y);
}

// Shorten a file name, in descriptive notation, to a possibly-ambiguous name.
// QR for queen's rook file is shortened to R, and so is KR for king's rook. 
function short_descriptive(descriptive_file)
{
    return {
        QR:"R", QN:"N", QB:"B", KB:"B", KN:"N", KR:"R", K:"K", Q:"Q",
        QRP:"RP", QNP:"NP", QBP:"BP", KBP:"BP", KNP:"NP", KRP:"RP", KP:"KP", QP:"QP" 
    }[descriptive_file];
}

// Get a square cell, given location in either
// - filerank notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 1,8)
// To get the square of a piece, use .square
// Note: code should use SQUARES[x][y] or .square. This is 
// only for user convenience (console) and debugging.
function sq(code, extra)
{
    var x, y, xy;

    //assert(code !== undefined, "sq(" + code + ", " + extra + "): code is undefined");
    //assert(code !== null, "sq(" + code + ", " + extra + "): code is null");

    // Is it x,y passed as separate parameters?
    if (extra !== undefined) {
        x = code;
        y = extra;
    // Is it a string in algebraic notation that can be converted?
    } else if (code.charCodeAt) {
        xy = filerank2xy(code);

        // Note JavaScript 1.8 can do var [x,y] = ...
        x = xy[0];
        y = xy[1];
    } else {
        assert(false, "sq(" + code + ", " + extra + "): couldn't find out what I was given");
    }

    /*assert(x >= 1 && x <= FILE_MAX && y >= 1 && y <= RANK_MAX, "sq(" + code + ", " + extra + 
        "): out of range (" + x + ", " + y + ")");*/

    return SQUARES[x][y];
}

//// DRAG-AND-DROP FUNCTIONS

// Initiate drag-and-drop on mouse down, if over a draggable element
function mousedown(event)
{
    var target;

    event = event || window.event;

    target = event.target !== undefined ? event.target : event.srcElement;

    if (target.className.indexOf("draggable") === -1) {
        return;
    }

    if (event.shiftKey) {
        open_piece_url(target);
    }

    if (target.className.indexOf("tear-off") !== -1) {
        // This is from the piece library, so allow a new copy
        // of the piece to be torn off.
        var tear = create_piece(target.color, target.type);

        tear.style.left = dojo._abs(target, true).x + "px";
        tear.style.top = dojo._abs(target, true).y + "px";

        dojo.body().appendChild(tear);

        target = tear;
    }

    DRAG.initial_x = event.clientX;
    DRAG.initial_y = event.clientY;

    DRAG.start_x = target.offsetLeft;
    DRAG.start_y = target.offsetTop;

    DRAG.initial_left = dojo._abs(target, true).x;
    DRAG.initial_top = dojo._abs(target, true).y;

    // Bring to front
    DRAG.old_zindex = target.style.zIndex;
    target.style.zIndex = 10000;

    // Capture mouse
    DRAG.element_m = target;
    document.onmousemove = mousemove;
    document.onmouseup = mouseup;

    // Prevent text selection
    document.body.focus();
    document.onselectstart = function() { return false; };
    target.ondragstart = function() { return false; };

    DRAG.dragging = true;

    return false;
}

// Initiate dragging if touching a draggable element
function touch(evt)
{
    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i]; 

        var color, border;
        var target = e.target;

        if (target && target.className &&
                target.className.indexOf("draggable") !== -1 && !DRAG.touching) {

            // Save the offset of the touch within the current note
            DRAG.initial_left = dojo._abs(target, true).x;
            DRAG.initial_top = dojo._abs(target, true).y;
            DRAG.touching = [e.pageX - DRAG.initial_left, e.pageY - DRAG.initial_top];

            over_piece(target, {});
        }
    }

    DRAG.dragging = true;
}

// Continue dragging with the mouse
function mousemove(event)
{
    var element, new_x, new_y;
        
    event = event || window.event;

    element = DRAG.element_m;

    // Must have draggable class
    if (!element || element.className.indexOf("draggable") === -1) {
        return;
    }

    new_x = event.clientX - DRAG.initial_x + DRAG.start_x;
    new_y = event.clientY - DRAG.initial_y + DRAG.start_y;

    // Drag
    element.style.webkitTransition = "";
    element.style.left = new_x + "px";
    element.style.top = new_y + "px";
    dragging_over(element, new_x, new_y);

    return false;
}

// Continue dragging with touch events
function touchmove(evt) 
{
    evt.preventDefault();
    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i];

        if (DRAG.touching && e.target.className.indexOf("draggable") !== -1) {
                // Move the node if we're in a state of dragging, but not resizing
                var new_x = e.pageX - DRAG.touching[0];
                var new_y = e.pageY - DRAG.touching[1];

                e.target.style.webkitTransition = "";
                e.target.style.left = new_x + "px";
                e.target.style.top = new_y + "px";

                dragging_over(e.target, new_x, new_y);
                DRAG.element_t = e.target;
        }
    }
}

// Detect if over droppable area and act as needed.
// element: the element that is /being dragged/
function dragging_over(element, left, top)
{
    // Position from center
    var x = left + (DROP.area.cell_width / 2);
    var y = top + (DROP.area.cell_width / 2);

    // Inside board?
    if (x > DROP.area.left && y > DROP.area.top &&
        x < DROP.area.right && y < DROP.area.bottom) {

        DROP.offboard = false;

        // Find cell mathematically
        var cell_x = Math.ceil((x - DROP.area.left) / DROP.area.cell_width);
        var cell_y = Math.ceil((DROP.area.right - y) / DROP.area.cell_width);
        if (cell_y === 0) {
            cell_y = 1;
        }

        // Highlight droppable square
        var flipped = PREFS.flipped;
        if (!SQUARES[flipped ? 9 - cell_x : cell_x]) {
            DROP.square = null;
            return;
        }
        var square = SQUARES[flipped ? 9 - cell_x : cell_x][flipped ? 9 - cell_y : cell_y];
        // Slow, so use cached node above
        //var square  = dojo.query('#board-body')[0].childNodes[9 - cell_y].childNodes[cell_x];
        
        if (DROP.square) {
            dojo.removeClass(DROP.square, "dropping-square");
        }

        if (accepts(element, square)) {
            DROP.square = square;
            dojo.addClass(square, "dropping-square");
        } else {
            DROP.square = null;
        }

    } else {
        // Outside droppable area
        DROP.offboard = true;
        
        if (DROP.square) {
            dojo.removeClass(DROP.square, "dropping-square");
            DROP.square = null;
        }

        // TODO: change icon to show out of range, if was from within range
    }
}

// Drop or revert on mouse up
function mouseup()
{
    if (DRAG.element_m === null) {
        return;
    }

    DRAG.element_m.style.zIndex = DRAG.old_zindex;
    document.onmousemove = null;
    document.onselectstart = null;
    DRAG.element_m.ondragstart = null;

    drop_or_revert();

    DRAG.element_m = null;
}


// Drop or revert on touch end
function touchend(evt)
{
    drop_or_revert();

    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i];

        // Check to see if we've gone from a gesture back down to a touch
        if (e.target && e.target.className && e.target.className.indexOf("draggable") !== -1) {

            out_piece(e.target, {});

            if (evt.targetTouches.length == 1) {
                // If there was rotation, this number needs to be reset
                DRAG.touching = [evt.targetTouches[0].pageX - dojo.style(e.target, "left"), evt.targetTouches[0].pageY - dojo.style(e.target, "top")];
            } else if(!evt.targetTouches.length) {
                // Great use of e.targeTouches, since releasing on finger that's part
                // of a gesture over this node would trigger a touchend even though
                // it could keep going
                DRAG.touching = false;
            }
        }
    }
}

// Return whether square should accept dropping a piece on it
function accepts(piece, square)
{
    // Can never move to source square (not even for null moves).
    if (piece.square && piece.square.x === square.x &&
        piece.square.y === square.y) {
        return false;
    }

    // Can drop anywhere
    if (PREFS.setup_mode) {
        return true;
    }

    if (!piece.square) {
        // If not in setup mode, needs a source square
        return false;
    }

    var outer = IS_VALID_MOVE[piece.square.filerank];
    return outer && outer[square.filerank];
}

// Drop the dragging object (wherever it is), or move it back if it is not over a droppable area
function drop_or_revert()
{
    var piece, square;

    DRAG.dragging = false;

    piece = (DRAG.touching && DRAG.element_t) || DRAG.element_m;
    if (!piece) {
        // Nothing was being dragged
        return;
    }

    square = DROP.square;

    // Dragging offboard: delete in setup mode
    if (DROP.offboard && PREFS.setup_mode) {
        // Shrink off into the distance
        dojo.anim(piece, {width:0, height:0}, PREFS.revert_time, undefined, function() {
                // It was on board, move piece over itself to kill it
                if (piece.square) {
                    do_virtual_move(piece, {x:piece.square.x, y:piece.square.y});
                }
                // Remove node, so leftover torn-off pieces from library
                // that were not dragged anywhere do not accumulate.
                if (piece.parentNode) {
                    piece.remove();
                }
               
            });
        return;
    }

    // Not valid drop square: revert
    if (!square || !accepts(piece, square)) {
        if (!piece.style.left && !piece.style.top) {
            // Dropped where picked it up - no movement.
            // Do not revert, since would then pop out to (0,0)
            // and revert it back.
            piece.style.left = dojo._abs(piece, true).x;
            piece.style.top = dojo._abs(piece, true).y;
        }

        // Revert
        if (typeof WebKitCSSMatrix === "object") {
            // Use webkit transforms if available; faster
            // Feature detection from http://iui.googlecode.com/svn/trunk/test/features.html
            // (detects for css transforms, hopefully close enough)
            piece.style.webkitTransition = "left " + PREFS.revert_time + "ms linear, " + 
                "top " + PREFS.revert_time + "ms linear";
            piece.style.left = DRAG.initial_left + "px";
            piece.style.top  = DRAG.initial_top + "px";
        } else {
            dojo.anim(piece, { left: DRAG.initial_left, top: DRAG.initial_top }, PREFS.revert_time);
        }
        return;
    }

    //console.log("drop",piece,square);
    move_dropped_piece(piece, square, null);
}

// Initialize drag and drop system
function init_dnd() 
{
    document.onmousedown = mousedown;
    document.ontouchmove = touchmove;//mousemove

    document.ontouchstart = touch;
    dojo.query(".draggable").forEach(function(e) {
            e.ontouchmove = touchmove;
        });
    document.ontouchend = touchend;

    // Get dimensions of droppable area
    var top_left_square = dojo.query("#top-left-square")[0];
    var bottom_right_square = dojo.query("#bottom-right-square")[0];
    var top_left = dojo._abs(top_left_square, true);
    DROP.area.left = top_left.x;
    DROP.area.top = top_left.y;

    var bottom_right_top_left = dojo._abs(bottom_right_square, true);
    DROP.area.cell_width = dojo.style(bottom_right_square, "width");
    DROP.area.width = bottom_right_top_left.x - DROP.area.left + DROP.area.cell_width;
    DROP.area.height  = bottom_right_top_left.y - DROP.area.top + DROP.area.cell_width; // square

    // for testing
    //dojo._setBox(foo, DROP.area.left, DROP.area.top, DROP.area.width, DROP.area.height, "px");

    DROP.area.right = DROP.area.left + DROP.area.width;
    DROP.area.bottom = DROP.area.top + DROP.area.height;
}

//// LOW-LEVEL FUNCTIONS

// Return sign of number as {-1,0,1}
function signum(n)
{
    return n > 0 ? 1 : (n < 0 ? -1 : 0);
}

// Get the value of a form element
function form_value(e)
{
    e = dojo.byId(e);

    if (e.checked !== undefined) {
    return e.checked;
    }

    return dojo.byId(e).value;
}

// Get URL query string as an object
// Based on http://www.dojotoolkit.org/book/dojo-porting-guide-0-4-x-0-9/dojo-uri-changes
function query_string()
{
    var parts, dict = {};
    var query;

    if (location.search) {
        query = location.search;
    } else if (location.hash) {
        query = location.hash;
    }
    if (!query) {
        return {};
    }

    parts = query.split(/[&;]/);
    dojo.forEach(parts, function(pair) {
            var part = pair.match(/([a-zA-Z0-9]*)=(.*)/);
            if (part) { 
                dict[part[1]] = decodeURIComponent(part[2]); 
            }
         }, this);

    return dict;
}

// Random integer within range
function randint(minimum, maximum)
{
    return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}

// Uppercase first character, like in Perl
function ucfirst(s)
{
    assert(s.substring, "ucfirst(" + s + "): no substring method, not a string? callee=" + 
            arguments.callee);
    return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
    return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
    if (!expression) {
        alert(message);
        if (window.console && console.trace) {
            // Give a stack trace for Firebug
            console.trace();
        }

        throw new AssertException(message);
    }
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
var ORIGINAL_ONSELECTSTART;
function enable_document_selection(enable) 
{
    if(enable) {
        document.onselectstart = ORIGINAL_ONSELECTSTART;
    } else {
        ORIGINAL_ONSELECTSTART = document.onselectstart;
        document.onselectstart = function() { return false; };
    }
}

</script>
</head>
<body>
<table id="outer">
<tr>
<td style="vertical-align: top">
<!-- TODO: dynamically generate, so can have arbitrary sizes -->
<table class="board" id="board">
<tbody id="board-body"
><tr
><td></td
><td class="file label">a</td
><td class="file label">b</td
><td class="file label">c</td
><td class="file label">d</td
><td class="file label">e</td
><td class="file label">f</td
><td class="file label">g</td
><td class="file label">h</td
></tr
><tr
><td class="rank label">8</td
><td class="white square" id="top-left-square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square right-edge"></td
></tr
><tr
><td class="rank label">7</td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square right-edge"></td
></tr
><tr
><td class="rank label">6</td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square right-edge"></td
></tr
><tr
><td class="rank label">5</td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square right-edge"></td
></tr
><tr
><td class="rank label">4</td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square right-edge"></td
></tr
><tr
><td class="rank label">3</td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square right-edge"></td
></tr
><tr
><td class="rank label">2</td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square"></td
><td class="white square"></td
><td class="black square right-edge"></td
></tr
><tr
><td class="rank label">1</td
><td class="black square bottom-edge"></td
><td class="white square bottom-edge"></td
><td class="black square bottom-edge" id="f1"></td
><td class="white square bottom-edge" id="f2"></td
><td class="black square bottom-edge"></td
><td class="white square bottom-edge"></td
><td class="black square bottom-edge"></td
><td class="white square bottom-edge right-edge" id="bottom-right-square"></td
></tr
></tbody
></table>

</td><td style="vertical-align: top">
<noscript><p>JavaScript is disabled, nothing will work!</p></noscript>

<div id="game_ui">

<!-- Header elements, game metadata. Hidden/shown as needed. -->
<p id="header" style="display: none; text-align: center" 
onclick="edit_pgn()" class="show_White">
<span class="players">
<span id="PGN_White" class="player_name" style="display: none">White</span>
<span class="player_elo"><span style="display: none" class="show_WhiteElo">(</span><span id="PGN_WhiteElo" style="display: none">1500</span><span class="show_WhiteElo" style="display: none">)</span></span>
<span id="vs" style="display: none" class="show_White">vs.</span>
<span id="PGN_Black" class="player_name" style="display: none">Black</span>
<span class="player_elo"><span style="display: none" class="show_BlackElo">(</span><span id="PGN_BlackElo" style="display: none">1500</span><span class="show_BlackElo" style="display: none">)</span></span>
</span>
<br class="show_White" style="display: none">

<span id="PGN_Event" style="display: none">Event</span>
<span style="display: none" class="show_Round">(</span><span id="PGN_Round" style="display: none">Round</span><span style="display: none" class="show_Round">)</span>
<span id="PGN_Site" style="display: none">Site</span><br class="show_Event" style="display: none">

<span id="PGN_Date" style="display: none">Date</span>
<span id="PGN_Time" style="display: none">Time</span>
</p> 

<p>
<span id="status"></span> 
<span id="dash" style="display: none">&mdash;</span>
<span id="check"></span>
<br>
<span id="promote_container"></span>
</p>

<p><a id="copyable_link">copyable link</a> (<a href="#" onclick="email_board()">email</a>)
<p><span id="opening_name"></span>

<div id="piece-inspector" style="display: none; z-index: 2">
<p><span style="vertical-align: middle" id="inspector-image"></span> <span id="inspector-type" style="font-weight: bold">type</span>
<p>Movement: <span id="inspector-movement">movement</span>
<p>Symbols: <span id="inspector-symbols">symbols</span>
<p><span id="inspector-info">other info</span>
</div>

<!-- TODO: disclosure triangles -->
<p><a href="#" onclick="new Effect.toggle('controls', 'slide', { duration: 0.1 })">controls</a> | 
<a href="#" onclick="toggle_piece_library();">pieces</a>

<div id="controls" style="display: none; border-left: 2px solid blue">
<div>

<p><select accesskey="m" id="make_move_menu" onchange="make_move_by_menu(this)"></select>

<!-- TODO: hide all this, since the purpose of this app is
not to implement chess AI. But having automatic moves is useful for testing. -->
<p>Engine: <label for="white_computer"><input accesskey="w" type="checkbox" id="white_computer" name="white_computer" onclick="computer_move_if_applicable(this)">White</label> 
<label for="black_computer"><input accesskey="b" type="checkbox" id="black_computer" name="black_computer" onclick="computer_move_if_applicable(this)">Black</label>

<span id="score"></span><br>

<div id="show_skill" style="display: none"><p>Skill Level: 
<input type="text" size="3" maxlength="3" id="skill_level" onchange="update_skill(this)"></div>

<p><select accesskey="o" id="output_notation" name="output_notation" onchange="show_move_history()"></select>

<p><a href="#" onclick="edit_pgn()">import/edit PGN</a>

 <p>
 <label for="enable_flip"><input accesskey="f" name="enable_flip" id="enable_flip" type="checkbox" onclick="flip()">Flip</label>

 <label for="enable_setup_mode"><input accesskey="e" name="enable_setup_mode" id="enable_setup_mode" type="checkbox" onclick="set_setup_mode(this.checked)">Setup</label>

 <p><select id="saved_board_menu" onchange="change_loaded_board(this)"></select>
     <button onclick="load_fen(dojo.byId('saved_board_menu').value)" accesskey="n">New Game</button>
 
 </div>
 </div>
 <!-- end controls-->

 <div id="piece-library-parent" style="display: none">
 <div id="piece-library" style="width: 600px; height: 325px; overflow: auto; position: relative"> </div>
 </div>

  <div id="captured_piece_images" style="width: 250px;"></div>
  <div id="moves_container" style="width: 500px; text-align: justify">
  <!-- TODO: scrollbar, http://livepipe.net/control/scrollbar -->
  <p id="move_history"></p>
  </div>
</div>

 </td>
</tr>
</table>

</body>
</html>
