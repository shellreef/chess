<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Chess by Jeff</title>
<!-- Copyright (C) 2009 Jeff Connelly -->
<!-- Created:20090411 -->
<style>
img.piece
{ 
 border: none;
 margin: 0px;
}

img.black {}
img.white {}

table.board
{
 border: 2px solid black;

/* This is like cellspacing=0 cellpadding=0 */
 border-collapse: collapse;

/* Firefox: disable text selection when dragging */
 -moz-user-select: none;
}

td.square
{
 border-style: none;
 /* border: 1px solid black; */
 padding: 0em;
 margin: 0em;
 width: 53px;
 height: 53px;
}

td.hover 
{ 
 /* border: 1px solid black; */
 background-color: blue !important;
}


/* Colors based on http://en.wikipedia.org/wiki/Chessboard
 * Useful site: http://www.cssdrive.com/imagepalette/index.php
 * Colors palette generator, get colors of an arbitrary image.
 *
 * Other colors to consider: http://chessos.com/, higher contrast
 *  http://chessteacher.110mb.com/, much lighter
 * But I like these, gives it a nice wooden feel. Could also
 * use green for a tournament-style board.
 */
td.white { background-color: #ffce9e; }
td.black { background-color: #d18b47; }

/* TODO: check out what colors Chess with Friends uses */
td.legal-move-white { background-color: #cf9e6e; }
td.legal-move-black { background-color: #a15b17; }


/* Would be cool to use CSS3 expressions to make the pattern, but they're not in
 * Firefox 3.0.8, maybe in Firefox 3.1. Safari has them though! 
 * If do this, would need to remember to shift nth-child per ranks. 
/*td:nth-child(2n) { background-color: green } */

</style>
<script src="http://www.google.com/jsapi"></script>
<script language="javascript">
if (!window.google) {
    alert("Google was not found. Nothing will work.");
}

google.load("prototype", "1.6.0.3");
google.load("scriptaculous", "1.8.2");

var GAME_STATE = {
    // Whose turn it is
    active_color: 'w',
    
    // Castling privileges
    white_castle_short: true,
    white_castle_long: true,
    black_castle_short: true,
    black_castle_long: true,
    enpassant_target: null,

    halfmove_clock: 0,    // Ply since last pawn advance / capture
    fullmove_number: 1,    // Increment after black moves

    // Not game state, but other globals
    dragging: false
};    

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;            // Keyed by filerank of source, array of [[x,y,flags]] destinations
var VALID_ALGEBRAIC_MOVES = null;    // Map algebraic -> [piece, square]
var ALL_DROP_TARGETS = [];              // Droppables for UI

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
// TODO: make this into a proper class/hash, where pieces have not only movements
// but HTML code to represent black and white (img, or Unicode character) pieces,
// and codes for FEN notation of initial board positions, also black and white

    // Keys:
    // parlett: movement of piece in extended Parlett notation
    // letter: uppercase character representing the piece in FEN
    // alg_letter: uppercase character for algebraic notation [defaults to FEN letter]
    // TODO: html
    // TODO: royal: if true, if checked, must make move that unthreatens, otherwise checkmate

    // Standard international chess pieces
    king: {parlett: "1*", letter: "K", royal: true},    // TODO: royal
    // TODO: imR2=, make 'm' move another piece adjacent, for castling, on initial (king+rook) move
    //king: "~1/1, ~1/0",    // equivalent hippogonal leaper
    queen: {parlett: "n*", letter: "Q"},
    bishop: {parlett: "nX", letter: "B"},
    rook: {parlett: "n+", letter: "R"},
    pawn: {parlett: "o1>, c1X>, oi2>", letter: "P", alg_letter: "", promote: ["queen", "knight", "rook", "bishop"]},
    knight: {parlett: "~1/2", letter: "N"},

    // Other hippogonals, good for testing
    giraffe: {parlett: "~1/4"},
    camel: {parlett: "~1/3"},
    zebra: {parlett:"~2/3"},
    squirrel: {parlett: "~0/2, ~1/2, ~2/2"},
    zero: {parlett: "~0/0"},
    man: {parlett: "1*"},    // same as king, but not royale

    // Combined pieces of internal chess
    cardinal: {parlett: "nX, ~1/2"},
    empress: {parlett: "n+, ~1/2"},
    amazon: {parlett: "n*, ~1/2"},
    colonel: {parlett: "n>, n=, 2/1> 1*"},

    // More complex fairy / non-intl chess pieces
    // See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
    murray_lion: {parlett: "~0/2, ~2/2, c1*"},
    lion: {parlett: "~n*"},
    alfil: {parlett: "~2X"},
    dabbaba: {parlett: "~2+"},
    berolina_pawn: {parlett: "o1X>, c1>, io2X>"},
    superpawn: {parlett: "on>, cnX>"},
    elephant: {parlett: "2X"},
    khohn: {parlett: "1X, 1>"},
    fers: {parlett: "1X"},
    wazir: {parlett: "1+"},

    // Pieces that probably won't be supported without significant coding
    leo: {parlett: "on*, c^&"},        // no & support, whatever that is
    kraken: {parlett: "~n/m"},         // no n support in hippogonal (just allow any square)
    knightrider: {parlett: "n(1/2)"},  // no grouping support, sadly
    checker: {parlett: "cn(^2X>), o1X> pD", promote: "checker_kinged"},  // no grouping
    checker_kinged: {parlett: "cn(^2X), o1x"},
    spy: {parlett: "2>, 2=, (1/1)>"}  // no grouping
    // pieces with no notation. WinChloe supports 1400 pieces.
};

google.setOnLoadCallback(function() {
    /* Safari & IE7: Disable text selection to stop interfering with dragging */
    enable_document_selection(false);    
    name_squares();    

        
    //load_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    //load_fen("rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2");
    //load_fen("rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2");
    //load_fen("rnbqkb1r/pp1ppppp/5n2/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 1 2");
    load_fen("7K/8/k1P5/7p/8/8/8/8 w KQkq - 42 42");

});

//// USER FUNCTIONS

// Convenience function to move given algebraic notation, for use within
// JavaScript console (Develop -> Show Error Console in Safari) if you want
// a command-line instead of a GUI.
function mv(alg_move)
{
    var piece_square, piece, square;

    if (!alg_move) {
        return VALID_ALGEBRAIC_MOVES.keys();
    }

    piece_square = VALID_ALGEBRAIC_MOVES.get(alg_move);
    assert(piece_square, "mv(" + alg_move + "): illegal move");

    piece = piece_square[0];
    square = piece_square[1];

    // TODO: do some Effect.Move animation, optionally (make two functions)

    move_piece_to_square(piece, square);
}

//// SPECIAL MOVE FUNCTIONS

// Return whether a piece should be promoted
function should_promote(piece)
{
    var square;

    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    square = sq(piece);

    // Is it on the last rank?
    if (GAME_STATE.active_color === "white") {
        return square.y === 0;    // 8th rank
    } else if (GAME_STATE.active_color === "black") {
        return square.y === 7;    // 1st rank
    } else {
        assert(false, "should_promote(" + piece + "): unknown active color");
    }
}

// Change a piece to whatever it promotes to.
function promote(piece)
{
    var promotes_to;

    //console.log("promotion");

    // TODO: give option to what to promote to, if more than one.
    // Click/tap piece to change it, after moved? Cycle through?
    promotes_to = PIECE_TYPES[piece.type].promote[0];

    piece.src = image_path_for(PIECE_TYPES[promotes_to].letter,
                piece.hasClassName("white") ? "white" : "black");

    piece.type = promotes_to;
}

//// VALID MOVE FUNCTIONS

// After the board changes and it is the next person's turn, calculate what the next possible allowable moves are.
function calculate_valid_moves()
{
    VALID_MOVES = new Hash();
    VALID_ALGEBRAIC_MOVES = new Hash();


    // Look at all the active pieces
    $$("img.active-color").each(function(piece) { 
        var filerank;
        var moves = filtered_moves(piece);

        // Convert xy to filerank notation (a string), so it can be easily used
        // as a hash key (that's the only reason)
        filerank = sq(piece).filerank;

        // Create drop targets for the valid destinations, linking
        // the draggables to droppables using piece- + source square.
        piece.addClassName("piece-" + filerank);
        piece.prior_position = filerank;    // for removal
        moves.each(function(move) {
            var square = sq(move[0], move[1]);
            var algebraic = algebraic_piece_prefix(piece) + xy2filerank(move[0], move[1]);

            // Store algebraic notation -> [piece, square] map for understanding the notation
            VALID_ALGEBRAIC_MOVES.set(algebraic, [piece, square]);

            ALL_DROP_TARGETS.push(square); // for removal

            Droppables.add(square, {
                accept: "piece-" + filerank,
                onDrop: move_dropped_piece,
                hoverclass: 'hover'});
        });

        // Store valid moves for mouseovers etc.
        VALID_MOVES.set(filerank, moves);
        //console.log(filerank, moves);
    });

    // AI - artificial intelligence    
    // TODO: options human vs. computer, computer vs. human, h vs. h, c vs. c
    if (GAME_STATE.active_color === "black") {
        // simply choose a random move
        // TODO: weak AI, take most valuable piece, checkmate if can, check if can,
        //     fork if can.. something to entertain a beginner
        var keys = VALID_ALGEBRAIC_MOVES.keys();
        var alg_move = keys[randint(0, keys.length - 1)];

        var piece_square = VALID_ALGEBRAIC_MOVES.get(alg_move);

        // TODO: detect stalemate, checkmate, for both players (set_turn probably)

        mv(alg_move);
    }
}

// Compute legal moves for a piece, removing illegal moves. This
// takes a while, so it is only done once when the board changes.
// Use VALID_MOVES otherwise.
function filtered_moves(piece)
{
    var xy = piece_location(piece);    // TODO: OO
    var x = xy[0], y = xy[1];
    var parlett = PIECE_TYPES[piece.type].parlett;
    var filtered;

    var unfiltered = unfiltered_moves(parlett, xy);

    filtered = unfiltered.select(function(move) {
        var allowed = true;
                var piece_under;

        if (move[2].initial_only) {
            // Can only move if have not moved this piece yet
            if (pawn_moved(piece)) {
                allowed = false;
            }
        }

        if (move[2].capture_only) {
            // Destination square must be occupied by enemy piece
            // TODO: non-royal (can't capture king)
            piece_under = pc(move[0], move[1]);
            if (!piece_under) {
                allowed = false;    // needs something to capture
            }
        }
        
        if (move[2].no_capture) {
            // Can only move if unoccupied, not to capture
            piece_under = pc(move[0], move[1]);
            if (piece_under) {
                allowed = false;    // can't capture, man
            }
        }

        return allowed;
    });

    // TODO: check if puts in check

    return filtered;
}

// Return whether a pawn has moved from its initial position. Unfortunately,
// the starting ranks of black and white pawns are hardcoded, so that games
// in-progress can be loaded and pawns that have moved, but we haven't seen move,
// are recognized as in fact having moved. Other games with pawns in ranks other
// than 2nd and 7th (Chinese Chess, etc.) will need to have this modified.
// TODO: store initial rank in piece information
function pawn_moved(piece)
{
    if (piece.hasClassName("white")) {
        return sq(piece).y !== 6;    // 2nd rank
    } else if (piece.hasClassName("black")) {
        return sq(piece).y !== 1;    // 7th rank
    } else {
        assert("pawn_not_moved(" + piece + "): neither white nor black");
    }
}

// Convert relative move destinations (0,0 = where the piece is,
// the coordinates are +/-) to absolute (0,0 = top-left board).
// Note: Coordinates out of bounds *are* discarded, but not those that
// land on an existing piece (one's own or the enemy's).
// Note2: moves must be array of [x,y,flags]; the third element is required
function move_rel2abs(xy_location, moves)
{
    var absolutes = [];

    for (var i = 0; i < moves.length; ++i) {
        var rel = moves[i];
        var flags = rel[2];
        var x = xy_location[0] + rel[0];
        var y = xy_location[1] + rel[1];

        // TODO: stop hardcoding dimensions
        if (x < 0 || x > 7 || y < 0 || y > 7) {
            //console.log("reject", x, y);
            continue;    // off board, TODO: option for chess variants to wrap around?
        }

        var abs = [x, y, flags];

        absolutes.push(abs);
    }

    return absolutes;
}

//// PARLETT NOTATION FUNCTIONS

// Get unfiltered (might be occupied by own piece, cause to put in check) 
/// list of moves for a piece, with Parlett moves given, at given location
function unfiltered_moves(parlett, xy)
{
    var choice_groups, moves;

    moves = [];

    // Mutually exclusive choices
    choice_groups = parlett.split(", ");

    //console.log(choice_groups);
    for (var i = 0; i < choice_groups.length; ++i) {
            // For each group, gather the move options. 
            // (Would be nice if JavaScript arrays had a Python-like .extend)
            moves = moves.concat(decode_one_parlett(choice_groups[i], xy));
    }    

    // Last step: remove duplicates. Maybe the caller should do this.
    moves = without_dupes(moves);

    return moves;
}

// Decode a Parlett direction character, or return a false value if that is not what it is.
// Returns an 2-element array:
// 0th element: array of two-element arrays of direction vectors.
// 1st element: true if ch2 was consumed, false if only ch was used
function decode_direction(ch, ch2)
{
    var forward, backward;

    // What way pieces go when they move forwards. Remember, these are x,y
    // vectors so negative is up, positive is down.
    if (GAME_STATE.active_color === "white") {
        forward = -1;
    } else if (GAME_STATE.active_color === "black") {
        forward = 1;
    } else {
        assert(false, "decode_direction(" + ch + "): bad active color: " + GAME_STATE.active_color);
    }
    backward = -forward;

    if (ch === "+") { 
        // orthogonally four possible directions
        return [include_reversed(times_each([1, 0], [1, -1])), false];
    } else if (ch === "=") {
        // orthogonally sideways
        return [[[1, 0], [-1, 0]], false];
    } else if (ch === ">") {
        if (ch2 === "=") {
            // >= orthogonally forwards or sideways
            return [decode_direction(">")[0].concat(decode_direction("=")[0]), true];
        } else {
            // = orthogonally forward
            return [[[0, forward]], false];
        }
    } else if (ch === "<") {
        if (ch2 === ">") {
            // <> orthogonally forwards and backwards
            return [[[0, forward], [0, backward]], true];
        } else if (ch2 === "=") {
            // <= orthogonally backwards or sideways
            return [decode_direction("<")[0].concat(decode_direction("=")[0]), true];
        } else {
            // < orthogonally backwards
            return [[[0, backward]], false];
        }
    } else if (ch === "X") { 
        if (ch2 === ">") {
            // X> diagonally forwards
            return [[[1, forward], [-1, forward]], true];
        } else if (ch2 === "<") {
            // X< diagonally backwards
            return [[[1, backwards], [-1, backwards]], true];
        } else {
            // X diagonally four possible directions
            return [include_reversed(times_each([1, 1], [1, -1])), false];
        }
    } else if (ch === "*") {    
        // orthogonally or diagonally (eight possible directions)
        return [decode_direction("+")[0].concat(decode_direction("X")[0]), false];
    } else {
        return null;
    }
}

// Decode a single group in extended Parlett notation into unfiltered absolute moves
// See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notations
function decode_one_parlett(parlett, xy)
{
    var movement, hippogonal;
    var distances, directions, flags, maybe_directions;

    assert(xy, "decode_one_parlett("+ parlett + ", " + xy + "): piece xy not given");

    flags = {};
    distances = [];

    for (var i = 0; i < parlett.length; ++i) {
        var ch = parlett[i];

        if (ch === "~") {
            // Moves by leaping to a fixed number (well, it can be
            // reduced later) of relative positions, jumping over
            // pieces if needed, capturing where it ends up. 
            // ex: knight = (2,1)leaper, king (1,0)+(1,1)leaper
            movement = "leaper";

        // Conditional modifiers that all returned moves should note.
        // Additions to Parlett, documented on http://en.wikipedia.org/wiki/Fairy_chess_piece#Additions_to_Parlett.27s
        } else if (ch === "i") { 
            // Initial move: Can only if the piece is in its original position
            // (pawn's 2 move forward)
            flags.initial_only = true;
        } else if (ch === "c") {
            // Capture only: may only be used if destination is occupied by enemy piece
            // (pawn's diagnal capture)
            flags.capture_only = true;
        } else if (ch === "o") {
            // Can not capture: destination square must be unoccupied; since by default, piece
            // can move to enemy square in order to capture it
            // (pawn's forward move)
            flags.no_capture = true;

        // Extended Parlett, my own extensions 
        } else if (ch === "m") {
            // TODO: multi-move other pieces, castling: mR2=
            
        // Standard Parlett
        } else if (/[0-9]/.test(ch)) {
            distances.push(parseInt(ch, 10));
        } else if (ch === "n") {
            distances.push(Infinity);
        } else if (ch === "/") {
            hippogonal = true;
        } else {
            maybe_directions = decode_direction(ch, parlett[i + 1]);
            if (maybe_directions) {
                directions = maybe_directions[0];
                if (maybe_directions[1]) {
                    i += 1; // two-character direction
                }
            } else {
                assert(false, "decode_one_parlett(" + parlett + "): unsupported: " + ch);
            }
        }
    }
    if (!movement) {
        // Move unlimited distance in one direction, as long as its not blocked
        // rook = (1,0)rider, bishop = (1,1)rider, queen (1,1)+(1,0)rider
        movement = "rider";
    }

    //console.log("movement=",movement);
    //console.log("directions=",directions);

    if (hippogonal) {
        assert(movement === "leaper", "decode_one_parlett(" + parlett + 
            "): only hippogonals that are leapers are currently supported");

        // First get valid destinations, then convert to absolute coordinates.
        // Relatively easy, since with leapers, can disregard pieces on the path
        var rel_moves = add_flags(expand_hippogonal(distances), flags);

        moves = move_rel2abs(xy, rel_moves).reject(function(xy) {
            var piece = pc(xy[0], xy[1]);
            if (!piece) {
                return false;    // unoccupied, good
            }

            // skip squares that are occupied by friendly pieces
            return piece.hasClassName("active-color");
        });

    } else if (movement === "leaper") {
        assert(false, "decode_one_parlett(" + parlett + 
            "): only leapers that are hippogonals are currently supported");
    } else if (movement === "rider") {
        var limit;

        assert(distances.length === 1, "decode_one_parlett(" + parlett + 
            "): for non-hippogonal parletts, must have exactly one distance, not: " +
            distances);

        // The distance is the move limit (1 for king, "infinity" for Q, B, R).
        limit = distances[0];

        moves = add_flags(expand_rider(limit, directions, xy), flags);
    } else {
        assert(false, "decode_one_parlett(" + parlett + "): unsupported movement");
    }

    return moves;
}

// Get the absolute moves for a "rider" piece. It
// can move up to limit steps, in the direction vectors given,
// starting at the given location -- but it will be blocked by
// an occupied square. Note that there could be pieces that move
// in this way, but won't be blocked (leapers, locusts), but they
// are not supported here.
function expand_rider(limit, directions, xy)
{
    var moves = [];

    //console.log("expand_rider",limit, directions, xy);

    directions.each(function(direction) {
        moves = moves.concat(expand_direction(limit, direction, xy));
    });

    return without_dupes(moves);
}

// Iterate up to limit steps (may be Infinity), in the direction 
// vector, starting at start_xy. Stop when reaching the end of the
// board, on an enemy piece, or before a friendly piece.
function expand_direction(limit, direction, start_xy)
{
    var x, y, moves;

    moves = [];

    x = start_xy[0];
    y = start_xy[1];

    for (var i = 0; i < limit; ++i) {
        var piece;

        x += direction[0];
        y += direction[1];

        if (x < 0 || x > 7 || y < 0 || y > 7) {
            break;
        }

        piece = pc(x, y);
        if (piece) {
            if (piece.hasClassName("active-color")) {
                // blocked by own piece, can't move on top
                break;
            } else {
                // can capture enemy piece
                moves.push([x, y]);
                break;
            }
        }

        //console.log(xy2filerank(x,y));    
        moves.push([x, y]);
    }

    return moves;
}

// Add a third element to a list of moves, extra "flags" that describe
// under what conditions the move is valid. 
//     add_flags([[7,2],[4,1],[5,2]], "hi") === [[7,2,"hi"],[[4,1,"hi"], etc.
// but the flags should be something useful: a dictionary
function add_flags(moves, flags)
{
    var new_moves = [];

    for (var i = 0; i < moves.length; ++i) {
        var move = moves[i];

        new_moves.push([move[0], move[1], flags]);
    }

    return new_moves;
}

// Expand the shorthand for hippogonal moves, such as the knight:
//     expand_hippogonal([1,2]) -> [[1, 2], [2, 1], [-1, 2], [2, -1], [1, -2], [-2, 1], [-1, -2], [-2, -1]]
// Requires constants, so for example it can't represent the
// Kraken fairy chess piece, with Parlett notation ~n/m, but there are probably easier
// ways to handle that, if I get that far (it leaps to any square on the board).
function expand_hippogonal(a)
{
    return include_reversed(times_each(a, [1, -1]));
}

// Return a list of lists, where each element in the first is multiplied
// by each combination of the second. For example, to implement +/-:
//     times_each([1,2], [1,-1]) === [[1,2], [1,-2], [-1,2], [-1,2]]
// This is not the cross product or Cartesian product, something else.
function times_each(a, b)
{
    // Maybe there is a more elegant way to do this, with
    // arbitrary array sizes..
    return [
        [a[0] * b[0], a[1] * b[0]],
        [a[0] * b[0], a[1] * b[1]],
        [a[0] * b[1], a[1] * b[0]],
        [a[0] * b[1], a[1] * b[1]]
    ];

}

// Include reversed pairs of nested lists, example:
//     include_reversed([[1,2], [1,0]]) === [[1,2], [2,1], [1,0], [0,1]]
// Removes duplicates.
function include_reversed(a)
{
    var all = [];

    for (var i = 0; i < a.length; ++i)
    {
        var element = a[i];
        var reversed, flags;

        all.push(element);

        // Need to clone before reversing, to not modify original
        assert(element.clone, "include_reversed(" + a + "): no clone property (is Prototype loaded?) on element: " + element);

        all.push(element.clone().reverse());
    }

    return without_dupes(all);
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//    [1,2] in [[1,2], [3,4]]
// is false, since 
//    [1,2] === [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
function without_dupes(a)
{
    var hash = new Hash();
    var result = [];

    for (var i = 0; i < a.length; ++i) {
        // Add if not a dupe
        if (!hash.get(a[i])) {
            result.push(a[i]);
        }

        // Record that this element was added. Converts to a string,
        // unfortunately, so can't just use hash.keys() after filling 
        // in the hash.
        hash.set(a[i], true);
    }

    return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
    var opposite = {white: "black", black: "white"}[color];

    assert(opposite === "black" || opposite === "white", "opposite_color(" + color + "): bad color");

    return opposite;
}

// Set the active color to white or black, or go to the next color (toggling)
function set_turn(color)
{
    var new_color, active_pieces;

    assert(color === "white" || color === "black" || color === "next", "set_turn(" + color + "): invalid color");

    if (color === "next") {
        new_color = opposite_color(GAME_STATE.active_color);
    } else {
        new_color = color;
    }

    // Class to tell droppables that they can accept these pieces.
    $$("img." + new_color).each(function(piece) {
        piece.addClassName("active-color");
    });

    $$("img." + opposite_color(new_color)).each(function(piece) {
        piece.removeClassName("active-color");
    });

    $("status").innerHTML = ucfirst(new_color) + "'s Turn";

    GAME_STATE.active_color = new_color;

    // Note: this takes some time... is there any way to run it right AFTER the piece has
    // gone through the endeffect? This is called in onDrop.
    // TODO: find out how to run something *after* the endeffect, for smoother UI.
    calculate_valid_moves();
}

//// BOARD FUNCTIONS

// Internally name the square cells with their (x,y) coordinates
// and filerank notation, once when the page loads. This is only code so I
// don't have to manually type <td x=0 y=0 filerank=a8> etc. in all the cells.
function name_squares()
{
    for (var x = 0; x < 8; ++x){
        for (var y = 0; y < 8; ++y) {
            var square = sq(x, y);

            square.x = x;
            square.y = y;
            square.filerank = xy2filerank(x, y);
            //console.log(square);
        }
    }
}

// Manipulate the DOM nodes to move the piece to its new location,
// and advance to the next move. Does not do anything graphical
// with dragging.
function move_piece_to_square(piece, square)
{
    assert(piece, "move_piece_to_square(" + piece + ", " + square + "): piece is false");
    assert(square, "move_piece_to_square(" + piece + ", " + square + "): square is false");

    // Capture piece(s) on destination square
    while (square.firstChild)
        square.removeChild(square.firstChild);

    // Move to new square
    if (piece.parentNode) {
        piece.parentNode.removeChild(piece);
    }

    square.appendChild(piece);


    if (should_promote(piece)) {
        promote(piece);
    }

    // TODO: record move in algebraic notation, and how about descriptive too?

    set_turn("next");

}

// Handle graphically moving of a piece, dropping it to its new location
function move_dropped_piece(piece, square, event)
{    
    //console.log(piece);
    //console.log(square);

    // TODO: do some cool effects when a piece is captured, but not too cool
    //if (square.firstChild) {
    //   new Effect.Squish(pc(square));
    // }

    // Can't drop this piece anywhere anymore.
    piece.removeClassName("piece-" + piece.prior_position);
    ALL_DROP_TARGETS.each(function(square) {
        Droppables.remove(square);
    });
    ALL_DROP_TARGETS = [];

    unhighlight_all();

    move_piece_to_square(piece, square);
}

// Load board state
function load_fen(fen)
{
    var parts, castling;

    parts = fen.split(" ");
    load_starting_position(parts[0]);

    assert(/^[wb]$/.test(parts[1]), "load_fen(" + fen + "): bad active color: " + parts[1]);
    set_turn({w:"white", b:"black"}[parts[1]]);

    castling = parts[2];
    GAME_STATE.white_castle_short = /K/.test(castling);
    GAME_STATE.white_castle_long = /Q/.test(castling);
    GAME_STATE.black_castle_short = /k/.test(castling);
    GAME_STATE.black__castle_long = /q/.test(castling);

    if (parts[3] === "-") {
        GAME_STATE.enpassant_target = null;
    } else {
        GAME_STATE.enpassant_target = parts[3]; // for sq()
    }

    GAME_STATE.halfmove_clock = parseInt(parts[4], 10);
    GAME_STATE.fullmove_number = parseInt(parts[5], 10);
}

// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR
function load_starting_position(fen)
{
    var i, x, y, code;

    // Note that ranks and files internally are represented here by
    // x,y coordinates, so a8 = 0,0. That is where FEN starts.
    x = y = 0;
    for (i = 0; i < fen.length; ++i) {
        code = fen.charAt(i);
        if (/[a-zA-Z]/.test(code)) {
            sq(x, y).appendChild(create_piece(code));
            ++x;
        } else if (code === "/") {
            x = 0;
            ++y;
        } else if (/[0-9]/.test(code)) {
            x += code.charCodeAt(0) - "0".charCodeAt(0);
        } else if (code === " ") {
            break;
        } else {
            assert("load_starting_position(" + fen + "): unknown code: " + code);
        }
    }
}

//// PIECE FUNCTIONS

// Given a letter, find the name of the piece (R = rook, etc.). The letter
// can either be for FEN (P = pawn), or algebraic notation (blank = pawn);
// both are recognized.
var cache_letter2name;
function piece_letter2name(letter)
{
    letter = letter.toUpperCase();

    if (!cache_letter2name) {
        cache_letter2name = new Hash();

        for (var name in PIECE_TYPES) {
            var info = PIECE_TYPES[name];

            if (info.letter !== undefined) {
                cache_letter2name.set(info.letter, name);
            } if (info.alg_letter !== undefined) {
                cache_letter2name.set(info.alg_letter, name);
            }
        }
    }

    return cache_letter2name.get(letter.toUpperCase());
}

// Return algebraic prefix for a piece. May return an empty 
// string (for pawns, for example).
function algebraic_piece_prefix(piece)
{
    if (PIECE_TYPES[piece.type].letter !== undefined) {
        return PIECE_TYPES[piece.type].letter;
    } else if (PIECE_TYPES[piece.type].alg_letter !== undefined) {
        return PIECE_TYPES[piece.type].alg_letter;
    }

    assert(false, "algebraic_piece_prefix(" + piece + "): unrecognized piece");
}



// Return an existing piece somewhere (or a false value), given:
// - (x,y) coordinates, like (0,0)
// - location in filerank notation, like "a8"
// - a square, from sq()
function pc(x, y)
{
    if (x.hasClassName && x.hasClassName("square")) {
        return x.childNodes[0];
    }

    var square = sq(x, y);

    return square.childNodes[0];
}

// Get (x,y) of piece. For filerank notation, use xy2filerank on this.
function piece_location(piece)
{
    assert(piece, "piece_location(" + piece + "): piece is false");
    assert(piece.parentNode, "piece_location(" + piece + "): piece.parentNode is false");

    return [piece.parentNode.x, piece.parentNode.y];
}

// Return the path to an image for the piece of that color
function image_path_for(letter, color)
{
    // TODO: pngs
    // TODO: even better, use Unicode characters in a span!! How cool would that be? Infinite resolution.
    // See for example http://en.wikipedia.org/wiki/Knight_(chess)
    // Unfortunately, MSIE doesn't seem to support it, though it should..different font?
    return "images/" + {white:"w", black:"b"}[color] + letter + ".gif";
}

// Create a new piece or pawn, given the name in
// Forsyth-Edwards Notation, for example:
//  r = black rook, R = white rook, N = white knight
// TODO: make this a class so you can do new Piece().
function create_piece(name)
{
    var color, filename, piece, letter, type;

    // In FEN, uppercase=white, lower=black
    if (/^[A-Z]/.test(name)) {
        color = "white";
    } else if (/^[a-z]/.test(name)) {
        color = "black";
    } else {
        assert("create_piece(" + name + "): not a letter");
    }
    letter = name.toLowerCase();
    type = piece_letter2name(letter);

    // TODO: catch invalid letters, lookup PIECE_TYPES

    filename = image_path_for(letter, color);

    piece = Builder.node('img', {'src': filename, 'class': "piece " + color});

    // Property will tell name of piece. To tell what color, or if it is
    // a piece in the first place, check the class names.
    piece.type = type;

    // Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
    // Yahoo Games does this too, but uses a yellow outline.
    Event.observe(piece, 'mouseover', function() {
            highlight_moves(piece, true);
            // for debugging
            //piece.setStyle({border: '1px solid black'});
        });
    Event.observe(piece, 'mouseout', function() {
            highlight_moves(piece, false);
            //piece.setStyle({border: 'none'});
        });

    // Make all new pieces draggable. I tried only making the active color's
    // pieces draggable, but then in Safari they can still be selected like text,
    // even with enable_document_selection(false), maybe I need to enable it on the
    // images too, but it wasn't appealing. In Firefox, the images can be dragged
    // as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
    // if they are the active colors move. The player can drag the opponent's pieces
    // around but not drop anywhere.

    // TODO: instead of reverting, check if valid move
    // TODO: Figure out how to fix how the draggable jumps, by the amount it moved,
    // when being dropped. http://www.tutorialspoint.com/cgi-bin/practice.cgi?file=scriptaculous_12 
    // does this too. reverteffect defaults to Effect.Move, and it reverts back to *something*,
    // figure this point.

    // Note: http://www.jslint.com/ stops here for some reason
    new Draggable(piece, { 
        revert: true, 
        starteffect: undefined, 
        endeffect: undefined,
        onStart: function() { GAME_STATE.dragging = true; },
        onEnd: function() { GAME_STATE.dragging = false; }
     });


    return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
function highlight_moves(piece, enable)
{
    var from_square, moves;

    // If player is dragging a piece over another piece, don't show
    // legal moves for the piece under it.
    if (GAME_STATE.dragging) {
        return;
        }

    // If not this player's turn, no legal moves
    if (!piece.hasClassName(GAME_STATE.active_color)) {
        return [];
        }

    from_square = sq(piece);

    //console.log(from_square.filerank);
    moves = VALID_MOVES.get(from_square.filerank);
    //console.log(moves);
    if (!moves) {
        return;    
        }

    moves.each(function(move) {
        var x, y, flags, to_square;
        
        x = move[0];
        y = move[1];
        flags = move[2];
        to_square = sq(x, y);

        if (enable) {
            if (to_square.hasClassName("white")) {
                to_square.addClassName("legal-move-white");
                        } else {
                to_square.addClassName("legal-move-black");
                        }
        } else {
                to_square.removeClassName("legal-move-white");
                to_square.removeClassName("legal-move-black");
        }
    });
}

// Unhighlight all highlighted black/white squares. Used in onEnd draggable, for
// some reason, highlight_moves(piece, false) does not unhighlight, maybe the piece changed..
function unhighlight_all()
{
    $$("td.legal-move-white", "td.legal-move-black").each(function(square) {
        square.removeClassName("legal-move-white");
        square.removeClassName("legal-move-black");
    });
}

//// SQUARE FUNCTIONS / FILE-RANK NOTATION

// Convert filerank f8 to the x,y coordinate [5,0], etc. These coordinates
// are used internally, but filerank notation is useful for human consumption
// (though I actually think better in descriptive notation, but maybe I'm in the minority there)
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// zero-based table cell with (0,0) at the top-left. In filerank notation, this
// square is labeled a8. The bottom-right square (7,7) is filerank's h1.
function filerank2xy(code)
{
    assert(code, "filerank2xy(" + code + "): is false");
    assert(code.charCodeAt, "filerank2xy(" + code +"): is missing charCodeAt, is it a string?");

    var x = code.charCodeAt(0) - "a".charCodeAt(0);        // corresponds to file (horizontal)
    var y = 8 - (code.charCodeAt(1) - "0".charCodeAt(0));    // corresponds to rank (vertical)

    assert(x >= 0 && x <= 7, "filerank2xy(" + code + "): bad x: " + x);
    assert(y >= 0 && y <= 7, "filerank2xy(" + code + "): bad y: " + y);

    return [x, y];
}

// Convert from x,y coordinates to filerank notation for human consumption. Can either pass
// xy2filerank(0, 0) === "a8"
// xy2filerank([0, 0]) === "a8"
function xy2filerank(x, y)
{
    var filerank;

    if (y === undefined) {
        // Passed array
        y = x[1];
        x = x[0];
    }

    assert(x >= 0 && x <= 7, "xy2filerank(" + x + ", " + y + "): bad x: " + x);
    assert(y >= 0 && y <= 7, "xy2filerank(" + x + ", " + y + "): bad y: " + y);

    filerank = String.fromCharCode(x + "a".charCodeAt(0));
    filerank += String.fromCharCode((8 - y) + "0".charCodeAt(0));

    return filerank;
}

// Get a square cell, given location in either
// - filerank notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 0,0)
// - a piece, returned by pc(), will return the enclosing square
function sq(code, extra)
{
    var x, y;

    // Accept pieces, too. TODO: update if change piece from <img>
    if (code.constructor && /HTMLImageElement/.test(code.constructor.toString())) {
        var xy = piece_location(code);

        x = xy[0];
        y = xy[1];
    } else if (extra !== undefined) {
        x = code;
        y = extra;
    } else {
        var xy = filerank2xy(code);

        // TODO: can JS do list element assignment like x,y=...?    
        x = xy[0];
        y = xy[1];
    }

    assert(x >= 0 && x <= 7 && y >= 0 && y <= 7, "sq(" + code + ", " + extra + 
        "): out of range (" + x + ", " + y + ")");

    return $('board-body').childNodes[y].childNodes[x];
}

//// LOW-LEVEL FUNCTIONS

// Random integer within range
function randint(minimum, maximum)
{
    return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}

// Uppercase first character, like in Perl
function ucfirst(s)
{
    return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
    return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
    if (!expression) {
        alert(message);
        throw new AssertException(message);
    }
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
function enable_document_selection(enable) {
    if(enable) {
        document.onselectstart = _original_onselectstart;
    } else {
        _original_onselectstart = document.onselectstart;
        document.onselectstart = function() { return false; }
    }
}

</script>
</head>

<body>
<table id="outer">
 <tr>
  <td>
<table class="board" id="board">
<tbody id="board-body"
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
></tbody
></table>


 </td><td valign="top">
  <p id="status"></p>
 </td>
</tr>
</table>

</body>
</html>
