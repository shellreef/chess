<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Chess</title>
<style>
img.piece
{ 
 border: none;
 margin: 0px;
}

img.black {}
img.white {}

img.rook {}
img.knight {}
img.bishop {}
img.queen {}
img.king {}
img.pawn {}

table.board
{
 border: 2px solid black;
 border-collapse: collapse; 	/* cellspacing=0 cellpadding=0 */

 /* Firefox: disable text selection when dragging */
 -moz-user-select: none;
}

td.square
{
 border-style: none;
 //border: 1px solid black;
 padding: 0em;
 margin: 0em;
 width: 53px;
 height: 53px;
}

td.hover 
{ 
 //border: 1px solid black;
 //background: url("images/wk.gif");
 background-color: blue !important;
}


/* Colors based on http://en.wikipedia.org/wiki/Chessboard
 * Useful site: http://www.cssdrive.com/imagepalette/index.php
 * Colors palette generator, get colors of an arbitrary image.
 *
 * Other colors to consider: http://chessos.com/, higher contrast
 *  http://chessteacher.110mb.com/, much lighter
 * But I like these, gives it a nice wooden feel. Could also
 * use green for a tournament-style board.
 */
td.white { background-color: #ffce9e; }
td.black { background-color: #d18b47; }

/* TODO: check out what colors Chess with Friends uses */
td.legal-move-white { background-color: #cf9e6e; }
td.legal-move-black { background-color: #a15b17; }


/* Would be cool to use CSS3 expressions to make the pattern, but they're not in
 * Firefox 3.0.8, maybe in Firefox 3.1. Safari has them though! 
 * If do this, would need to remember to shift nth-child per ranks. 
/*td:nth-child(2n) { background-color: green } */

</style>
<script src="http://www.google.com/jsapi"></script>
<script language="javascript">
if (!window.google)
	alert("Google was not found. Nothing will work.");
	// Let fall through and error out

google.load("prototype", "1.6.0.3");
google.load("scriptaculous", "1.8.2");

var GAME_STATE = {
	// Whose turn it is
	active_color: 'w',
	
	// Castling privileges
	white_castle_short: true,
	white_castle_long: true,
	black_castle_short: true,
	black_castle_long: true,
	enpassant_target: null,

	halfmove_clock: 0,	// Ply since last pawn advance / capture
	fullmove_number: 1,	// Increment after black moves

	// Not game state, but other globals
	dragging: false
};	

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
// TODO: make this into a proper class/hash, where pieces have not only movements
// but HTML code to represent black and white (img, or Unicode character) pieces,
// and codes for FEN notation of initial board positions, also black and white

	// Standard international chess pieces

	//king: "1*",		// TODO: royal, and this notation
	king: "~1/1, ~1/0",	// equivalent hippogonal leaper
	queen: "n*",
	bishop: "nX",
	rook: "n+",
	pawn: "o1>, c1X>, oi2>",
	knight: "~1/2",

	// Other hippogonals, good for testing
	giraffe: "~1/4",
	camel: "~1/3",
	zebra: "~2/3",
	squirrel: "~0/2, ~1/2, ~2/2",
	zero: "~0/0",
	man: "~1/1, ~1/0",	// same as king, but not royale

	// Combined pieces of internal chess
	cardinal: "nX, ~1/2",
	empress: "n+, ~1/2",
	amazon: "n*, ~1/2",	
	colonel: "n>, n=, 2/1> 1*",

	// More complex fairy / non-intl chess pieces
	// See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
	murray_lion: "~0/2, ~2/2, c1*",
	lion: "~n*",
	alfil: "~2X",
	dabbaba: "~2+",
	superpawn: "~on>, cnX>",
	berolina_pawn: "o1X>, c1>, io2X>",
	colonel: "n>, n=, 2/1>, 1*",	
	superpawn: "on>, cnX>",
	elephant: "2X",
	khohn: "1X, 1>",
	fers: "1X",
	wazir: "1+",

	// Pieces that probably won't be supported without significant coding
	leo: "on*, c^&",	// no & support, whatever that is
	kraken: "~n/m",		// no n support in hippogonal (just allow any square)
	knightrider: "n(1/2)",	// no grouping support, sadly
	checker: "cn(^2X>), o1X> King: cn(^2X), o1x",	// no grouping, kinging
	spy: "2>, 2=, (1/1)>",	// no grouping
	// pieces with no notation
};	

google.setOnLoadCallback(function() {
	/* Safari & IE7: Disable text selection to stop interfering with dragging */
	enable_document_selection(false);	
	name_squares();	
	
	//load_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
	//load_fen("rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2");
	load_fen("rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2");

	// TODO: only add droppables for valid squares? Actually, probably just want to change class.
	$$(".square").each(function(square) {
		Droppables.add(square, {accept:"active-color", onDrop: move_dropped_piece, hoverclass: 'hover'});
	});
});

//// VALID MOVE FUNCTIONS

// After the board changes and it is the next person's turn, calculate what the next possible allowable moves are.
function calculate_valid_moves()
{
	VALID_MOVES = {};

	// Look at all the active pieces
	$$("img.active-color").each(function(piece) { 
		var type = piece_type(piece);
		var xy = piece_location(piece);	// TODO: OO
		var parlett = PIECE_TYPES[type];
		var moves, pgn;
	
		if (type != "knight") return;	// TODO: all
	
		var moves = unfiltered_moves(parlett);
		moves = move_rel2abs(xy,moves);

		// Convert xy to PGN, so it can be easily used
		// as a hash key.
		pgn = xy2pgn(xy);

		// Store valid moves for mouseovers etc.
		VALID_MOVES[pgn] = moves;
		console.log(pgn, moves);
	});
}

// Convert relative move destinations (0,0 = where the piece is,
// the coordinates are +/-) to absolute (0,0 = top-left board).
// Note: Coordinates out of bounds *are* discarded, but not those that
// land on an existing piece (one's own or the enemy's).
// Note2: moves must be array of [x,y,flags]; the third element is required
// A fourth element, the actual square element, is added for convenience.
function move_rel2abs(xy_location, moves)
{
	var absolutes = new Array();

	for (var i = 0; i < moves.length; ++i) {
		var rel = moves[i];
		var flags = rel[2];
		var x = xy_location[0] + rel[0];
		var y = xy_location[1] + rel[1];

		// TODO: stop hardcoding dimensions
		if (x < 0 || x > 7 || y < 0 || y > 7)
			continue;	// off board

		var square = sq(x, y);

		var abs = [x, y, flags, square];

		absolutes.push(abs);
	}

	return absolutes;
}

//// PARLETT NOTATION FUNCTIONS (get the unrestricted, relative valid moves for a piece)
function unfiltered_moves(parlett)
{
	var choice_groups, moves;

	moves = new Array();

	// Mutually exclusive choices
	choice_groups = parlett.split(", ");

	console.log(choice_groups);
	for (var i = 0; i < choice_groups.length; ++i) {
		// For each group, gather the move options. 
		// (Would be nice if JavaScript arrays had a Python-like .extend)
		moves = moves.concat(decode_one_parlett(choice_groups[i]));
	}	

	// Last step: remove duplicates. Maybe the caller should do this.
	moves = without_dupes(moves);

	return moves;
}

// Decode a single group in extended Parlett notation into unfiltered relative moves
// See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notations
function decode_one_parlett(parlett)
{
	var movement, initial_only, capture_only, no_capture, hippogonal;
	var distances, directions, flags;

	flags = {};
	distances = new Array();

	for (var i = 0; i < parlett.length; ++i) {
		var ch = parlett[i];

		if (ch == "~") {
			// Moves by leaping to a fixed number (well, it can be
			// reduced later) of relative positions, jumping over
			// pieces if needed, capturing where it ends up. 
			// ex: knight = (2,1)leaper, king (1,0)+(1,1)leaper
			movement = "leaper";

		// Conditional modifiers that all returned moves should note.
		} else if (ch == "i") { 
			// Initial move: Can only if the piece is in its original position
			// (pawn's 2 move forward)
			flags.initial_only = true;
		} else if (ch == "c") {
			// Capture only: may only be used if destination is occupied by enemy piece
			// (pawn's diagnal capture)
			flags.capture_only = true;
		} else if (ch == "o") {
			// Can not capture: destination square must be unoccupied; since by default, piece
			// can move to enemy square in order to capture it
			// (pawn's forward move)
			flags.no_capture = true;

		} else if (/[0-9]/.test(ch)) {
			distances.push(parseInt(ch));
		} else if (ch == "n") {
			distance.push(Infinity)
		} else if (ch == "/") {
			hippogonal = true;

		// TODO: directions

		} else {
			assert(false, "decode_one_parlett(" + parlett + "): unknown character: " + ch);
		}
	}
	if (!movement)
		// Move unlimited distance in one direction, as long as its not blocked
		// rook = (1,0)rider, bishop = (1,1)rider, queen (1,1)+(1,0)rider
		movement = "rider";

	if (hippogonal)
		moves = expand_hippogonal(distances);
	else
		assert(false, "decode_one_parlett TODO: implement parlett " + parlett);

	moves = add_flags(moves, flags);

	return moves;
}

// Add a third element to a list of moves, extra "flags" that describe
// under what conditions the move is valid. 
// 	add_flags([[7,2],[4,1],[5,2]], "hi") == [[7,2,"hi"],[[4,1,"hi"], etc.
// but the flags should be something useful: a dictionary
function add_flags(moves, flags)
{
	var new_moves = new Array();

	for (var i = 0; i < moves.length; ++i) {
		var move = moves[i];

		new_moves.push([move[0], move[1], flags]);
	}

	return new_moves;
}

// Expand the shorthand for hippogonal moves, such as the knight:
// 	expand_hippogonal([1,2]) -> [[1, 2], [2, 1], [1, -2], [-2, 1], [-1, 2], [2, -1]]
// Requires q and p to be constant, so for example it can't represent the
// Kraken fairy chess piece, with Parlett notation ~n/m, but there are probably easier
// ways to handle that, if I get that far (it leaps to any square on the board).
function expand_hippogonal(a)
{
	return include_reversed(times_each(a, [1, -1]));
}

// Return a list of lists, where each element in the first is multiplied
// by each combination of the second. For example, to implement +/-:
// 	times_each([1,2], [1,-1]) == [[1,2], [1,-2], [-1,2], [-1,2]]
// This is not the cross product or Cartesian product, something else.
function times_each(a, b)
{
	// Maybe there is a more elegant way to do this, with
	// arbitrary array sizes..
	return [
		[a[0] * b[0], a[1] * b[0]],
		[a[0] * b[0], a[1] * b[1]],
		[a[0] * b[1], a[1] * b[0]],
		[a[0] * b[1], a[1] * b[0]]
	];

}

// Include reversed pairs of nested lists, example:
// 	include_reversed([[1,2], [1,0]]) == [[1,2], [2,1], [1,0], [0,1]]
// Removes duplicates.
function include_reversed(a)
{
	var all = [];

	for (var i = 0; i < a.length; ++i)
	{
		var element = a[i];
		var reversed, flags;

		all.push(element);

		// Need to clone before reversing, to not modify original
		assert(element.clone, "include_reversed(" + a + "): no clone property (is Prototype loaded?) on element: " + element);

		all.push(element.clone().reverse());
	}

	return without_dupes(all);
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//	[1,2] in [[1,2], [3,4]]
// is false, since 
//	[1,2] == [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
function without_dupes(a)
{
	var hash = new Hash();
	var result = new Array();

	for (var i = 0; i < a.length; ++i) {
		// Add if not a dupe
		if (!hash.get(a[i]))
			result.push(a[i]);

		// Record that this element was added. Converts to a string,
		// unfortunately, so can't just use hash.keys() after filling 
		// in the hash.
		hash.set(a[i], true);
	}

	return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
	var opposite = {white: "black", black: "white"}[color];

	assert(opposite == "black" || opposite == "white", "opposite_color(" + color + "): bad color");

	return opposite;
}

// Set the active color to white or black, or go to the next color (toggling)
function set_turn(color)
{
	var new_color, active_pieces;

	assert(color == "white" || color == "black" || color == "next", "set_turn(" + color + "): invalid color");

	if (color == "next") {
		new_color = opposite_color(GAME_STATE.active_color);
	} else {
		new_color = color;
	}

	// Class to tell droppables that they can accept these pieces.
	$$("img." + new_color).each(function(piece) {
		piece.addClassName("active-color");
	});

	$$("img." + opposite_color(new_color)).each(function(piece) {
		piece.removeClassName("active-color");
	});

	$("status").innerHTML = ucfirst(new_color) + "'s Turn";


	GAME_STATE.active_color = new_color;
	calculate_valid_moves();
}

//// BOARD FUNCTIONS

// Internally name the square cells with their (x,y) coordinates
// and PGN notation, once when the page loads. This is only code so I
// don't have to manually type <td x=0 y=0 pgn=a8> etc. in all the cells.
function name_squares()
{
	for (var x = 0; x < 8; ++x){
		for (var y = 0; y < 8; ++y) {
			var square = sq(x, y);

			square.x = x;
			square.y = y;
			square.pgn = xy2pgn(x, y);
			console.log(square);
		}
	}
}	

// Move a piece
function move_dropped_piece(piece, square, event)
{	
	//console.log(piece);
	//console.log(square);

	// TODO: do some cool effects when a piece is captured, but not too cool
	//new Effect.Squish(square.firstChild);

	// TODO: unhighlight all moves, better
	highlight_moves(piece, false);

	// Capture piece on destination square
	while (square.firstChild)
		square.removeChild(square.firstChild);

	// Move to new square
	if (piece.parentNode)
		piece.parentNode.removeChild(piece);

	square.appendChild(piece);

	// TODO: only next if move was successful, or only have droppables for
	// legal moves?
	set_turn("next");
}

// Load board state
function load_fen(fen)
{
	var parts, castling;

	parts = fen.split(" ");
	load_starting_position(parts[0]);

	assert(/^[wb]$/.test(parts[1]), "load_fen(" + fen + "): bad active color: " + parts[1]);
	set_turn({w:"white", b:"black"}[parts[1]]);

	castling = parts[2];
	GAME_STATE.white_castle_short = /K/.test(castling);
	GAME_STATE.white_castle_long = /Q/.test(castling);
	GAME_STATE.black_castle_short = /k/.test(castling);
	GAME_STATE.black__castle_long = /q/.test(castling);

	if (parts[3] == "-") {
		GAME_STATE.enpassant_target = null;
	} else {
		GAME_STATE.enpassant_target = parts[3]; // for sq()
	}

	GAME_STATE.halfmove_clock = parseInt(parts[4]);
	GAME_STATE.fullmove_number = parseInt(parts[5]);
}

// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR
function load_starting_position(fen)
{
	var i, x, y, code;

	// Note that ranks and files internally are represented here by
	// x,y coordinates, so a8 = 0,0. That is where FEN starts.
	x = y = 0;
	for (i = 0; i < fen.length; ++i) {
		code = fen.charAt(i);
		if (/[a-zA-Z]/.test(code)) {
			sq(x, y).appendChild(new_piece(code));
			++x;
		} else if (code == "/") {
			x = 0;
			++y;
		} else if (/[0-9]/.test(code)) {
			x += code.charCodeAt(0) - "0".charCodeAt(0);
		} else if (code == " ") {
			break;
		} else {
			assert("load_starting_position(" + fen + "): unknown code: " + code);
		}
	}
}

//// PIECE FUNCTIONS

// Return an existing piece, given:
// - (x,y) coordinates, like (0,0)
// - location in algebraic notation, like "a8"
// - a square, from sq()
function pc(x, y)
{
	if (x.hasClassName && x.hasClassName("square"))
		return x.childNodes[0];

	var square = sq(x, y);

	return square.childNodes[0];
}

// Return the type of a piece node (rook, bishop, etc.), or a false value
function piece_type(piece)
{
	if (!piece || !piece.classNames)
		return undefined;	// or should it be null, false?

	var classes = piece.classNames();
	var type;

	// Loop through all the classes applied to this piece, finding
	// one that is a valid piece type. Not terribly elegant, but 
	// for now the type is stored as a class, instead of an attribute
	// with a value you can directly lookup.
	classes.each(function(className) {
		if (PIECE_TYPES[className] !== undefined) {
			type = className;
			// TODO: way to break out of the each? Just curious.
		}
	});

	return type;
}

// Get (x,y) of piece. For PGN notation, use xy2pgn on this.
function piece_location(piece)
{
	return [piece.parentNode.x, piece.parentNode.y];
}

// Create a new piece or pawn, given the name in
// Forsyth-Edwards Notation, for example:
//  r = black rook, R = white rook, N = white knight
// TODO: make this a class so you can do new Piece().
function new_piece(name)
{
	var color, filename, piece, type, classes;

	classes = "piece";	

	// In FEN, uppercase=white, lower=black
	if (/^[RNBQKP]/.test(name)) {
		color = "w";
		classes += " white";
	} else if (/^[rnbqkp]/.test(name)) {
		color = "b";
		classes += " black";
	} else {
		assert("new_piece(" + name + "): unrecognized");
	}
	type = name.toLowerCase();

	classes += " " + {r: 'rook', n: 'knight', b: 'bishop', q: 'queen', k: 'king', p: 'pawn'}[type];

	// TODO: pngs
	// TODO: even better, use Unicode characters in a span!! How cool would that be? Infinite resolution.
	// See for example http://en.wikipedia.org/wiki/Knight_(chess)
	filename = 'images/' + color + type + '.gif';


	piece = Builder.node('img', {'src': filename, 'class': classes});

	// Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
	// Yahoo Games does this too, but uses a yellow outline.
	// TODO: something is wrong, get only one mouseover per file!
	Event.observe(piece, 'mouseover', function() {
			highlight_moves(piece, true);
		});
	Event.observe(piece, 'mouseout', function() {
			highlight_moves(piece, false);
		});

	// Make all new pieces draggable. I tried only making the active color's
	// pieces draggable, but then in Safari they can still be selected like text,
	// even with enable_document_selection(false), maybe I need to enable it on the
	// images too, but it wasn't appealing. In Firefox, the images can be dragged
	// as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
	// if they are the active colors move. The player can drag the opponent's pieces
	// around but not drop anywhere.

	// TODO: instead of reverting, check if valid move
	// TODO: Figure out how to fix how the draggable jumps, by the amount it moved,
	// when being dropped. http://www.tutorialspoint.com/cgi-bin/practice.cgi?file=scriptaculous_12 
	// does this too. reverteffect defaults to Effect.Move, and it reverts back to *something*,
	// figure this point.
	new Draggable(piece, { 
		revert: true, 
		starteffect: undefined, 
		endeffect: undefined,
		onStart: function() { GAME_STATE.dragging = true; },
		onEnd: function() { GAME_STATE.dragging = false; },
	 });



	return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
function highlight_moves(piece, enable)
{
	var from_square, moves;

	// If player is dragging a piece over another piece, don't show
	// legal moves for the piece under it.
	if (GAME_STATE.dragging)
		return;

	// If not this player's turn, no legal moves
	if (!piece.hasClassName(GAME_STATE.active_color))
		return [];

	from_square = sq(piece);

	console.log(from_square.pgn);
	moves = VALID_MOVES[from_square.pgn];
	console.log(moves);
	if (!moves)
		return;	

	moves.each(function(move) {
		var x, y, flags, to_square;
		
		x = move[0];
		y = move[1];
		flags = move[2];
		to_square = move[3];

		if (enable) {
			if (to_square.hasClassName("white"))
				to_square.addClassName("legal-move-white");
			else
				to_square.addClassName("legal-move-black");
		} else {
				to_square.removeClassName("legal-move-white");
				to_square.removeClassName("legal-move-black");
		}
	});
}


//// SQUARE FUNCTIONS

// Convert PGN notation f8 to the x,y coordinate [5,0], etc. These coordinates
// are used internally, but PGN notation is useful for human consumption.
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// zero-based table cell with (0,0) at the top-left. In PGN, this
// square is labeled a8. The bottom-right square (7,7) is PGN's h1.
function pgn2xy(code)
{
	var x = code.charCodeAt(0) - "a".charCodeAt(0);		// corresponds to file (horizontal)
	var y = 8 - (code.charCodeAt(1) - "0".charCodeAt(0));	// corresponds to rank (vertical)

	assert(x >= 0 && x <= 7, "pgn2xy(" + code + "): bad x: " + x);
	assert(y >= 0 && y <= 7, "pgn2xy(" + code + "): bad y: " + y);

	return [x, y];
}

// Convert from x,y coordinates to PGN for human consumption. Can either pass
// xy2pgn(0, 0) == "a8"
// xy2pgn([0, 0]) == "a8"
function xy2pgn(x, y)
{
	var pgn;

	if (y === undefined) {
		// Passed array
		y = x[1];
		x = x[0];
	}

	assert(x >= 0 && x <= 7, "xy2pgn(" + x + ", " + y + "): bad x: " + x);
	assert(y >= 0 && y <= 7, "xy2pgn(" + x + ", " + y + "): bad y: " + y);

	pgn = String.fromCharCode(x + "a".charCodeAt(0));
	pgn += String.fromCharCode((8 - y) + "0".charCodeAt(0));

	return pgn;
}

// Get a square cell, given location in either
// - algebraic notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 0,0)
function sq(code, extra)
{
	var x, y;

	// Accept pieces, too. TODO: update if change piece from <img>
	if (code.constructor && /HTMLImageElement/.test(code.constructor.toString())) {
		var xy = piece_location(code);

		x = xy[0];
		y = xy[0];
	} else if (extra !== undefined) {
		x = code;
		y = extra;
	} else {
		var xy = pgn2xy(code);

		// TODO: can JS do list element assignment like x,y=...?	
		x = xy[0];
		y = xy[1];
	}

	return $('board-body').childNodes[y].childNodes[x];
}

//// LOW-LEVEL FUNCTIONS

// Uppercase first character, like in Perl
function ucfirst(s)
{
	return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
	return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
	if (!expression) 
		throw new AssertException(message);
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
function enable_document_selection(enable) {
  if(enable) {
    document.onselectstart = _original_onselectstart;
  }
  else {
    _original_onselectstart = document.onselectstart;
    document.onselectstart = function() { return false; }
  }
}


</script>
</head>

<body>
<table id="outer">
 <tr>
  <td>
<table class="board" id="board">
<tbody id="board-body"
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
><tr
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
></tr
><tr
 ><td id=y class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
></tr
></tbody
></table>


 </td><td valign="top">
  <p id="status"></p>
 </td>
</tr>
</table>

</body>
</html>
