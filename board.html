<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Chess by Jeff</title>
<!-- Copyright (C) 2009 Jeff Connelly -->
<!-- Created:20090411 -->
<style>
img.piece
{ 
 border: none;
 margin: 0px;
}

img.black {}
img.white {}

table.board
{
 /*border: 2px solid black;*/

/* This is like cellspacing=0 cellpadding=0 */
 border-collapse: collapse;

/* Firefox: disable text selection when dragging */
 -moz-user-select: none;
}

td.square
{
 border-style: none;
 /* border: 1px solid black; */
 padding: 0em;
 margin: 0em;
 width: 50px;
 height: 50px;
}

td.label { text-align: center; }
td.file { border-bottom: 2px solid black; }
td.rank { border-right: 2px solid black; padding-right: 5px; }
td.right-edge { border-right: 2px solid black; }
td.bottom-edge { border-bottom: 2px solid black; }

td.hover 
{ 
 /* border: 1px solid black; */
 background-color: blue !important;
}


/* Colors based on http://en.wikipedia.org/wiki/Chessboard
 * Useful site: http://www.cssdrive.com/imagepalette/index.php
 * Colors palette generator, get colors of an arbitrary image.
 *
 * Other colors to consider: http://chessos.com/, higher contrast
 *  http://chessteacher.110mb.com/, much lighter
 * But I like these, gives it a nice wooden feel. Could also
 * use green for a tournament-style board.
 */
td.white { background-color: #ffce9e; }
td.black { background-color: #d18b47; }

/* TODO: check out what colors Chess with Friends uses */
td.legal-move-white { background-color: #cf9e6e; }
td.legal-move-black { background-color: #a15b17; }


/* Would be cool to use CSS3 expressions to make the pattern, but they're not in
 * Firefox 3.0.8, maybe in Firefox 3.1. Safari has them though! 
 * If do this, would need to remember to shift nth-child per ranks. 
/*td:nth-child(2n) { background-color: green } */

</style>
<script src="http://www.google.com/jsapi"></script>
<script language="javascript">
if (!window.google) {
    alert("Google was not found. Nothing will work.");
}

/* TODO: why aren't these miniifed? http://code.google.com/apis/ajaxlibs/documentation/index.html#prototype has
 * direct paths but neither prototype nor scriptaculous are minified.. others are though. */
google.load("prototype", "1.6.0.3");
google.load("scriptaculous", "1.8.2");

var GAME_STATE = {
    // Whose turn it is
    active_color: 'w',
    
    // Castling privileges
    can_castle: {white: {short: true, long: true}, black: {short: true, long: true}},

    enpassant_target: null,

    halfmove_clock: 0,    // Ply since last pawn advance / capture
    fullmove_number: 1,    // Increment after black moves

    // Not game state, but other globals
    dragging: false
};    

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;            // Keyed by filerank of source, array of [[x,y,flags]] destinations
var VALID_ALGEBRAIC_MOVES = null;    // Map algebraic -> [piece, square]
var ALL_DROP_TARGETS = [];              // Droppables for UI

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
// TODO: make this into a proper class/hash, where pieces have not only movements
// but HTML code to represent black and white (img, or Unicode character) pieces,
// and codes for FEN notation of initial board positions, also black and white

    // Keys:
    // parlett: movement of piece in extended Parlett notation
    // letter: uppercase character representing the piece in FEN
    // alg_letter: uppercase character for algebraic notation [defaults to FEN letter]
    // TODO: html
    // TODO: royal: if true, if checked, must make move that unthreatens, otherwise checkmate

    // Standard international chess pieces
    king: {parlett: "1*, imR2=e", letter: "K", royal: true},    // TODO: royal
    // TODO: imR2=e, make 'm' move another piece adjacent, for castling, on initial (king+rook) move
    //king: "~1/1, ~1/0",    // equivalent hippogonal leaper
    queen: {parlett: "n*", letter: "Q"},
    bishop: {parlett: "nX", letter: "B"},
    rook: {parlett: "n+", letter: "R"},
    // P allows for moving to GAME_STATE.enpassant_target square
    pawn: {parlett: "o1>, c1X>, oi2>, P", letter: "P", alg_letter: "", promote: ["queen", "knight", "rook", "bishop"]},
    knight: {parlett: "~1/2", letter: "N"},

    // Other hippogonals, good for testing
    zero: {parlett: "~0/0", letter: "O"},
    dababba: {parlett: "~2/0", letter: "D"},    // or ~2+
    alfil: {parlett: "~2X", letter: "A"},    // or ~2/2
    alibaba: {parlett: "~2/0 ~2X", letter: "L"},
    squirrel: {parlett: "~0/2, ~1/2, ~2/2", letter: "S"},
    threeleaper: {parlett: "~3/0", letter: "H"},
    tripper: {parlett: "~3/3", letter: "T"},
    camel: {parlett: "~1/3", letter: "C"},
    zebra: {parlett:"~2/3", letter: "Z"},
    man: {parlett: "1*", letter: "M"},    // same as king, but not royale
    frog: {parlett: "~1/1, ~0/3", letter: "F"},   // amphibian
    giraffe: {parlett: "~1/4", letter: "G"},

    // Combined pieces of internal chess
    cardinal: {parlett: "nX, ~1/2"},
    empress: {parlett: "n+, ~1/2", letter: "E"},
    amazon: {parlett: "n*, ~1/2"},
    colonel: {parlett: "n>, n=, 2/1> 1*"},

    // More complex fairy / non-intl chess pieces
    // See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
    murray_lion: {parlett: "~0/2, ~2/2, c1*"},
    lion: {parlett: "~n*"},
    berolina_pawn: {parlett: "o1X>, c1>, io2X>"},
    superpawn: {parlett: "on>, cnX>"},
    elephant: {parlett: "2X"},
    khohn: {parlett: "1X, 1>"},
    fers: {parlett: "1X"},
    wazir: {parlett: "1+"},

    // Pieces that probably won't be supported without significant coding
    leo: {parlett: "on*, c^&"},        // no & support, whatever that is
    kraken: {parlett: "~n/m"},         // no n support in hippogonal (just allow any square)
    knightrider: {parlett: "n(1/2)"},  // no grouping support, sadly
    checker: {parlett: "cn(^2X>), o1X>", promote: "checker_kinged"},  // no grouping
    checker_kinged: {parlett: "cn(^2X), o1x"},
    spy: {parlett: "2>, 2=, (1/1)>"}  // no grouping
    // pieces with no notation. WinChloe supports 1400 pieces.
};

google.setOnLoadCallback(function() {
    /* Safari & IE7: Disable text selection to stop interfering with dragging */
    enable_document_selection(false);    
    name_squares();    

        
    //load_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    //load_fen("rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2");
    //load_fen("rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2");
    //load_fen("rnbqkb1r/pp1ppppp/5n2/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 1 3");
    //load_fen("7K/8/k1P5/7p/8/8/8/8 w KQkq - 42 42");
    //load_fen("r1bqkb1r/pp1ppppp/2n2n2/2p5/2B2P3/5N2/PPPP1PPP/RN1QK2R w KQkq - 1 3");
    load_fen("rnbqkbnr/ppp2ppp/8/3pP3/3Qn/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5");
});

//// USER FUNCTIONS

// TOOD: support Smith notation, https://www.chessclub.com/chessviewer/smith.html

// Convenience function to move given algebraic notation, for use within
// JavaScript console (Develop -> Show Error Console in Safari) if you want
// a command-line instead of a GUI. Computer move also uses this function, but it is
// not used for drag-and-drop.
function mv(alg_move)
{
    var piece_square, piece, square;

    if (!alg_move) {
        return VALID_ALGEBRAIC_MOVES.keys();
    }

    piece_square = VALID_ALGEBRAIC_MOVES.get(alg_move);
    assert(piece_square, "mv(" + alg_move + "): illegal move");

    piece = piece_square[0];
    square = piece_square[1];

    // TODO: do some Effect.Move animation, optionally (make two functions)
    //new Effect.Move(piece, { x: 10, y: 20, mode: 'relative' });

    move_piece_to_square(piece, square);
}

//// SPECIAL MOVE FUNCTIONS

// Return whether a piece should be promoted
function should_promote(piece)
{
    var square;

    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    square = sq(piece);

    // Is it on the last rank?
    if (GAME_STATE.active_color === "white") {
        return square.y === 0;    // 8th rank
    } else if (GAME_STATE.active_color === "black") {
        return square.y === 7;    // 1st rank
    } else {
        assert(false, "should_promote(" + piece + "): unknown active color");
    }
}

// Change a piece to whatever it promotes to.
function promote(piece)
{
    var promotes_to;

    //console.log("promotion");

    // TODO: give option to what to promote to, if more than one.
    // Click/tap piece to change it, after moved? Cycle through?
    promotes_to = PIECE_TYPES[piece.type].promote[0];

    piece.src = image_path_for(PIECE_TYPES[promotes_to].letter,
                piece.hasClassName("white") ? "white" : "black");

    piece.type = promotes_to;
}

//// VALID MOVE FUNCTIONS

// After the board changes and it is the next person's turn, calculate what the next possible allowable moves are.
function calculate_valid_moves(color)
{
    VALID_MOVES = new Hash();
    VALID_ALGEBRAIC_MOVES = new Hash();

    // Look at all the active pieces
    $$("img." + color).each(function(piece) { 
        var filerank;

        var moves = filtered_moves(piece, color);

        // Convert xy to filerank notation (a string), so it can be easily used
        // as a hash key (that's the only reason)
        filerank = sq(piece).filerank;

        // Create drop targets for the valid destinations, linking
        // the draggables to droppables using piece- + source square.
        piece.addClassName("piece-" + filerank);
        piece.prior_position = filerank;    // for removal
        moves.each(function(move) {
            var square = sq(move[0], move[1]);
            var algebraic = algebraic_piece_prefix(piece) + xy2filerank(move[0], move[1]);

            // Store algebraic notation -> [piece, square] map for understanding the notation
            // TODO: May need to disambiguate moves. Sometimes the same type of piece can
            // move to the same square. Fun. Or use long algebraic notation.
            VALID_ALGEBRAIC_MOVES.set(algebraic, [piece, square]);

            ALL_DROP_TARGETS.push(square); // for removal

            Droppables.add(square, {
                accept: "piece-" + filerank,
                onDrop: move_dropped_piece,
                hoverclass: 'hover'});
        });

        // Store valid moves for mouseovers etc.
        VALID_MOVES.set(filerank, moves);
        //console.log(filerank, moves);
    });

    if (VALID_MOVES.keys().length === 0) {
        $("status").innerHTML = ucfirst(color) + " is stalemated";
        // TODO: some way to note this, show a draw? 1/2-1/2
        return;
    }

}

// Make a move as the computer, if we're supposed to.
function computer_move_if_applicable()
{
    if ($F(GAME_STATE.active_color + "_player") !== "computer") {
        return;
    }

    // simply choose a random move
    // TODO: weak AI, take most valuable piece, checkmate if can, check if can,
    //     fork if can.. something to entertain a beginner. Or better yet,
    // plugin to a remote network server.
    var keys = VALID_ALGEBRAIC_MOVES.keys();
    var alg_move = keys[randint(0, keys.length - 1)];

    var piece_square = VALID_ALGEBRAIC_MOVES.get(alg_move);

    // TODO: do some animation when moving, Effect.Move, to slow it down so we can see it.
    mv(alg_move);
}

// Compute legal moves for a piece, removing illegal moves. This
// takes a while, so it is only done once when the board changes.
// Use VALID_MOVES otherwise.
function filtered_moves(piece, color)
{
    var xy = piece_location(piece);    // TODO: OO
    var x = xy[0], y = xy[1];
    var parlett = PIECE_TYPES[piece.type].parlett;
    var filtered;

    var unfiltered = unfiltered_moves(parlett, xy, color);

    filtered = unfiltered.select(function(move) {
        var allowed = true;
        var piece_under;

        // If castle move, check if castling allowed
        if (move[2].castle) {
            var castle;

            // If king moved, won't be able to castle on either side, don't need name
            if (GAME_STATE.can_castle[color].long === false &&
                GAME_STATE.can_castle[color].short === false) {
                allowed = false;
            } else {
                // Otherwise, need to find if short/long castle
                if (move[0] === 6) {
                    castle = "short";
                } else if (move[0] === 2) {
                    castle = "long";
                } else {
                    assert(false, "filtered_moves(" + piece + "): unknown name of castling to x="+x+", not long/short. " +
                        "filerank = " + xy2filerank([move[0], move[1]]) + ", piece = " + piece);
                }

                if (castle && !GAME_STATE.can_castle[color][castle])
                    allowed = false;
            }

            // If intervening pieces, do not allow castling.
            if (allowed && castle) { // so far..
                var first_rank = (color === "white" ? 7 : 0);
            
                if (castle === "short") {
                    if (pc(5, first_rank) || pc(6, first_rank)) {
                        allowed = false;
                    } 
                } else if (castle === "long") {
                    if (pc(1, first_rank) || pc(2, first_rank) || pc(3, first_rank)) {
                        allowed = false;
                    }
                } else {
                    assert(false, "filtered_moves: checking intervening pieces, castle wasn't long short: " + castle);
                }
            }
        }

        if (move[2].initial_only) {
            // Can only move if have not moved this piece yet
            if (piece.type === "pawn" && pawn_moved(piece)) {
                allowed = false;
            } 

            assert(piece.type === "pawn" || piece.type === "king", 
                "filtered_moves(" + piece + "): parlett " + parlett + " said this move " +
                    move + " was valid only on initial moves, but couldn't find out if piece " + 
                    piece.type + " moved, not a king or pawn");
        }

        if (move[2].capture_only) {
            // Destination square must be occupied by enemy piece
            // TODO: non-royal (can't capture king)
            piece_under = pc(move[0], move[1]);
            if (!piece_under) {
                allowed = false;    // needs something to capture
            }
        }
        
        if (move[2].no_capture) {
            // Can only move if unoccupied, not to capture
            piece_under = pc(move[0], move[1]);
            if (piece_under) {
                allowed = false;    // can't capture, man
            }
        }

        return allowed;
    });

    // TODO: check if puts in check

    return filtered;
}

// Return whether a pawn has moved from its initial position. Unfortunately,
// the starting ranks of black and white pawns are hardcoded, so that games
// in-progress can be loaded and pawns that have moved, but we haven't seen move,
// are recognized as in fact having moved. Other games with pawns in ranks other
// than 2nd and 7th (Chinese Chess, etc.) will need to have this modified.
// TODO: store initial rank in piece information
function pawn_moved(piece)
{
    if (piece.hasClassName("white")) {
        return sq(piece).y !== 6;    // 2nd rank
    } else if (piece.hasClassName("black")) {
        return sq(piece).y !== 1;    // 7th rank
    } else {
        assert("pawn_moved(" + piece + "): neither white nor black");
    }
}

// Convert relative move destinations (0,0 = where the piece is,
// the coordinates are +/-) to absolute (0,0 = top-left board).
// Note: Coordinates out of bounds *are* discarded, but not those that
// land on an existing piece (one's own or the enemy's).
// Note2: moves must be array of [x,y,flags]; the third element is required
function move_rel2abs(xy_location, moves)
{
    var absolutes = [];

    for (var i = 0; i < moves.length; ++i) {
        var rel = moves[i];
        var flags = rel[2];
        var x = xy_location[0] + rel[0];
        var y = xy_location[1] + rel[1];

        // TODO: stop hardcoding dimensions
        if (x < 0 || x > 7 || y < 0 || y > 7) {
            //console.log("reject", x, y);
            continue;    // off board, TODO: option for chess variants to wrap around?
        }

        var abs = [x, y, flags];

        absolutes.push(abs);
    }

    return absolutes;
}

//// PARLETT NOTATION FUNCTIONS

// Get unfiltered (might be occupied by own piece, cause to put in check) 
/// list of moves for a piece, with Parlett moves given, at given location
function unfiltered_moves(parlett, xy, color)
{
    var choice_groups, moves;

    moves = [];

    // Mutually exclusive choices
    choice_groups = parlett.split(", ");

    //console.log(choice_groups);
    for (var i = 0; i < choice_groups.length; ++i) {
            // For each group, gather the move options. 
            // (Would be nice if JavaScript arrays had a Python-like .extend)
            moves = moves.concat(decode_one_parlett(choice_groups[i], xy, color));
    }    

    // Last step: remove duplicates. Maybe the caller should do this.
    moves = without_dupes(moves);

    return moves;
}

// Decode a Parlett direction character, or return a false value if that is not what it is.
// Returns an 2-element array:
// 0th element: array of two-element arrays of direction vectors.
// 1st element: true if ch2 was consumed, false if only ch was used
function decode_direction(ch, ch2, color)
{
    var forward, backward;

    // What way pieces go when they move forwards. Remember, these are x,y
    // vectors so negative is up, positive is down.
    if (color === "white") {
        forward = -1;
    } else if (color === "black") {
        forward = 1;
    } else {
        assert(false, "decode_direction(" + ch + "): bad active color: " + color);
    }
    backward = -forward;

    if (ch === "+") { 
        // orthogonally four possible directions
        return [include_reversed(times_each([1, 0], [1, -1])), false];
    } else if (ch === "=") {
        // orthogonally sideways
        return [[[1, 0], [-1, 0]], false];
    } else if (ch === ">") {
        if (ch2 === "=") {
            // >= orthogonally forwards or sideways
            return [decode_direction(">", undefined, color)[0].concat(decode_direction("=", undefined, color)[0]), true];
        } else {
            // = orthogonally forward
            return [[[0, forward]], false];
        }
    } else if (ch === "<") {
        if (ch2 === ">") {
            // <> orthogonally forwards and backwards
            return [[[0, forward], [0, backward]], true];
        } else if (ch2 === "=") {
            // <= orthogonally backwards or sideways
            return [decode_direction("<", undefined, color)[0].concat(decode_direction("=", undefined, color)[0]), true];
        } else {
            // < orthogonally backwards
            return [[[0, backward]], false];
        }
    } else if (ch === "X") { 
        if (ch2 === ">") {
            // X> diagonally forwards
            return [[[1, forward], [-1, forward]], true];
        } else if (ch2 === "<") {
            // X< diagonally backwards
            return [[[1, backwards], [-1, backwards]], true];
        } else {
            // X diagonally four possible directions
            return [include_reversed(times_each([1, 1], [1, -1])), false];
        }
    } else if (ch === "*") {    
        // orthogonally or diagonally (eight possible directions)
        return [decode_direction("+", undefined, color)[0].concat(decode_direction("X", undefined, color)[0]), false];
    } else {
        return null;
    }
}

// Decode a single group in extended Parlett notation into unfiltered absolute moves
// See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notations
function decode_one_parlett(parlett, xy, color)
{
    var movement, hippogonal;
    var distances, directions, flags, maybe_directions, extremities;

    assert(xy, "decode_one_parlett("+ parlett + ", " + xy + "): piece xy not given");

    flags = {};
    distances = [];

    for (var i = 0; i < parlett.length; ++i) {
        // Btw, MSIE doesn't support [] for indexing into strings.. I never knew.
        var ch = parlett.substr(i, 1);

        if (ch === "~") {
            // Moves by leaping to a fixed number (well, it can be
            // reduced later) of relative positions, jumping over
            // pieces if needed, capturing where it ends up. 
            // ex: knight = (2,1)leaper, king (1,0)+(1,1)leaper
            movement = "leaper";

        // Conditional modifiers that all returned moves should note.
        // Additions to Parlett, documented on http://en.wikipedia.org/wiki/Fairy_chess_piece#Additions_to_Parlett.27s
        } else if (ch === "i") { 
            // Initial move: Can only if the piece is in its original position
            // (pawn's 2 move forward)
            flags.initial_only = true;
        } else if (ch === "c") {
            // Capture only: may only be used if destination is occupied by enemy piece
            // (pawn's diagnal capture)
            flags.capture_only = true;
        } else if (ch === "o") {
            // Can not capture: destination square must be unoccupied; since by default, piece
            // can move to enemy square in order to capture it
            // (pawn's forward move)
            flags.no_capture = true;

        // Multi-move, my own extension for castling
        } else if (ch === "m") {
            // TODO: multi-move other pieces, castling: imR2=e, more generic
            var letter = parlett.substr(i + 1, 1);
            var type = piece_letter2name(letter);
            assert(type, "decode_one_parlett(" + parlett + "): multimove letter " + letter + 
                    " piece type not found");
            i += 1;
            assert(type === "rook", "sorry, only castling with rooks currently supported");

            flags.castle = type;
        } else if (ch === "e") {
            // Riders can only go to the max, not any place in between
            // So 2= means can go two spaces sideways, but not one space sideways.
            extremities = true;
        } else if (ch === "P") {
            var ep_moves;

            // If en passant target square is available, allow it.
            // XXX TODO: Only for the valid pawn. But it does it for all but that pawn!
            /*console.log(GAME_STATE.enpassant_target);
            if (GAME_STATE.enpassant_target) {
                ep_moves = [GAME_STATE.enpassant_target];
            } else {*/
                ep_moves = [];
            //}

            return add_flags(ep_moves, flags);
        // Standard Parlett
        } else if (/[0-9]/.test(ch)) {
            distances.push(parseInt(ch, 10));
        } else if (ch === "n") {
            distances.push(Infinity);
        } else if (ch === "/") {
            hippogonal = true;

        } else if (ch == " ") {
            assert(false, "decode_one_parlett(" + parlett + "): whitespace encountered, did you forget a comma?");
        } else {
            maybe_directions = decode_direction(ch, parlett.substr(i + 1, 1), color);
            if (maybe_directions) {
                directions = maybe_directions[0];
                if (maybe_directions[1]) {
                    i += 1; // two-character direction
                }
            } else {
                assert(false, "decode_one_parlett(" + parlett + "): unsupported: '" + ch + "'");
            }
        }
    }
    if (!movement) {
        // Move unlimited distance in one direction, as long as its not blocked
        // rook = (1,0)rider, bishop = (1,1)rider, queen (1,1)+(1,0)rider
        movement = "rider";
    }

    //console.log("movement=",movement);
    //console.log("directions=",directions);

    if (hippogonal) {
        assert(movement === "leaper", "decode_one_parlett(" + parlett + 
            "): only hippogonals that are leapers are currently supported");

        // First get valid destinations, then convert to absolute coordinates.
        // Relatively easy, since with leapers, can disregard pieces on the path
        var rel_moves = add_flags(expand_hippogonal(distances), flags);

        moves = move_rel2abs(xy, rel_moves).reject(function(xy) {
            var piece = pc(xy[0], xy[1]);
            if (!piece) {
                return false;    // unoccupied, good
            }

            // skip squares that are occupied by friendly pieces
            return piece.hasClassName(color);
        });

    } else if (movement === "leaper") {
        assert(false, "decode_one_parlett(" + parlett + 
            "): only leapers that are hippogonals are currently supported");
    } else if (movement === "rider") {
        var limit;

        assert(distances.length === 1, "decode_one_parlett(" + parlett + 
            "): for non-hippogonal parletts, must have exactly one distance, not: " +
            distances);

        // The distance is the move limit (1 for king, "infinity" for Q, B, R).
        limit = distances[0];

        moves = add_flags(expand_rider(limit, directions, xy, extremities, color), flags);
    } else {
        assert(false, "decode_one_parlett(" + parlett + "): unsupported movement");
    }

    return moves;
}

// Get the absolute moves for a "rider" piece. It
// can move up to limit steps, in the direction vectors given,
// starting at the given location -- but it will be blocked by
// an occupied square. Note that there could be pieces that move
// in this way, but won't be blocked (leapers, locusts), but they
// are not supported here.
function expand_rider(limit, directions, xy, extremities, color)
{
    var moves = [];

    //console.log("expand_rider",limit, directions, xy);

    directions.each(function(direction) {
        moves = moves.concat(expand_direction(limit, direction, xy, extremities, color));
    });

    return without_dupes(moves);
}

// Iterate up to limit steps (may be Infinity), in the direction 
// vector, starting at start_xy. Stop when reaching the end of the
// board, on an enemy piece, or before a friendly piece.
// If extremities is true, only add square at end of the direction.
function expand_direction(limit, direction, start_xy, extremities, color)
{
    var x, y, moves;

    moves = [];

    x = start_xy[0];
    y = start_xy[1];

    for (var i = 0; i < limit; ++i) {
        var piece;

        x += direction[0];
        y += direction[1];

        if (x < 0 || x > 7 || y < 0 || y > 7) {
            break;
        }

        piece = pc(x, y);
        if (piece) {
            if (piece.hasClassName(color)) {
                // blocked by own piece, can't move on top
                break;
            } else {
                // can capture enemy piece
                moves.push([x, y]);
                break;
            }
        }

        //console.log(xy2filerank(x,y));    
        moves.push([x, y]);
    }

    if (extremities) {
        // End only. Allows using 2=, for example, to move
        // two spaces sideways, without going 1 space sideways.
        var end_move = moves[moves.length - 1];
        if (end_move) {
            return [end_move];
        } else {
            return [];
       }
    }

    return moves;
}

// Add a third element to a list of moves, extra "flags" that describe
// under what conditions the move is valid. 
//     add_flags([[7,2],[4,1],[5,2]], "hi") === [[7,2,"hi"],[[4,1,"hi"], etc.
// but the flags should be something useful: a dictionary
function add_flags(moves, flags)
{
    var new_moves = [];

    for (var i = 0; i < moves.length; ++i) {
        var move = moves[i];

        new_moves.push([move[0], move[1], flags]);
    }

    return new_moves;
}

// Expand the shorthand for hippogonal moves, such as the knight:
//     expand_hippogonal([1,2]) -> [[1, 2], [2, 1], [-1, 2], [2, -1], [1, -2], [-2, 1], [-1, -2], [-2, -1]]
// Requires constants, so for example it can't represent the
// Kraken fairy chess piece, with Parlett notation ~n/m, but there are probably easier
// ways to handle that, if I get that far (it leaps to any square on the board).
function expand_hippogonal(a)
{
    return include_reversed(times_each(a, [1, -1]));
}

// Return a list of lists, where each element in the first is multiplied
// by each combination of the second. For example, to implement +/-:
//     times_each([1,2], [1,-1]) === [[1,2], [1,-2], [-1,2], [-1,2]]
// This is not the cross product or Cartesian product, something else.
function times_each(a, b)
{
    // Maybe there is a more elegant way to do this, with
    // arbitrary array sizes..
    return [
        [a[0] * b[0], a[1] * b[0]],
        [a[0] * b[0], a[1] * b[1]],
        [a[0] * b[1], a[1] * b[0]],
        [a[0] * b[1], a[1] * b[1]]
    ];

}

// Include reversed pairs of nested lists, example:
//     include_reversed([[1,2], [1,0]]) === [[1,2], [2,1], [1,0], [0,1]]
// Removes duplicates.
function include_reversed(a)
{
    var all = [];

    for (var i = 0; i < a.length; ++i)
    {
        var element = a[i];
        var reversed, flags;

        all.push(element);

        // Need to clone before reversing, to not modify original
        assert(element.clone, "include_reversed(" + a + "): no clone property (is Prototype loaded?) on element: " + element);

        all.push(element.clone().reverse());
    }

    return without_dupes(all);
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//    [1,2] in [[1,2], [3,4]]
// is false, since 
//    [1,2] === [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
function without_dupes(a)
{
    var hash = new Hash();
    var result = [];

    for (var i = 0; i < a.length; ++i) {
        // Add if not a dupe
        if (!hash.get(a[i])) {
            result.push(a[i]);
        }

        // Record that this element was added. Converts to a string,
        // unfortunately, so can't just use hash.keys() after filling 
        // in the hash.
        hash.set(a[i], true);
    }

    return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
    var opposite = {white: "black", black: "white"}[color];

    assert(opposite === "black" || opposite === "white", "opposite_color(" + color + "): bad color");

    return opposite;
}

// Set the active color to white or black, or go to the next color (toggling)
function set_turn(color)
{
    var new_color, active_pieces;

    assert(color === "white" || color === "black" || color === "next", "set_turn(" + color + "): invalid color");

    if (color === "next") {
        new_color = opposite_color(GAME_STATE.active_color);
    } else {
        new_color = color;
    }

    $("status").innerHTML = ucfirst(new_color) + "'s Turn";

    // Move number is incremented after black moves, according to rules.
    if (GAME_STATE.active_color === "black") {
        GAME_STATE.fullmove_number += 1;
    }

    GAME_STATE.active_color = new_color;
    // Note: this takes some time... is there any way to run it right AFTER the piece has
    // gone through the endeffect? This is called in onDrop.
    // TODO: find out how to run something *after* the endeffect, for smoother UI.
    calculate_valid_moves(GAME_STATE.active_color);

    // AI - artificial intelligence 
    computer_move_if_applicable();
}

//// BOARD FUNCTIONS

// TODO: a "board lab", where can drag pieces onto board in arbitrary
// positions, or drag off (with an Effect.Puff), to load arbitrary fen.

// Internally name the square cells with their (x,y) coordinates
// and filerank notation, once when the page loads. This is only code so I
// don't have to manually type <td x=0 y=0 filerank=a8> etc. in all the cells.
function name_squares()
{
    for (var x = 0; x < 8; ++x){
        for (var y = 0; y < 8; ++y) {
            var square = sq(x, y);

            square.x = x;
            square.y = y;
            square.filerank = xy2filerank(x, y);
            //console.log(square);
        }
    }
}

// Acknowledge that a piece was captured. Called by move_piece_to_square(), which
// does all the DOM manipulation.
function capture_piece(piece)
{
    //console.log("capture " + piece.type);

    // If rook captured, remove castling privileges
    if (piece.type === "rook") {
        // Note that this is the first rank of the *other* player
        var opponent = opposite_color(GAME_STATE.active_color);
        var first_rank = opponent === "white" ? 7 : 0;
        var square = sq(piece);
        
        // TODO: really would like to not have to hardcode this
        if (square.y === first_rank) {
            if (square.x === 0) {
                GAME_STATE.can_castle[opponent].long = false;
                console.log("no more long");
            } else if (square.x === 7) {
                GAME_STATE.can_castle[opponent].short = false;
                console.log("no more short");
            }
        }
    }

    // TODO: show as captured, somewhere with icons
}

// Manipulate the DOM nodes to move the piece to its new location,
// and advance to the next move. Does not do anything graphical
// with dragging.
// If suppress is true, this is an internal move part of another move
// (castling) so it shouldn't be logged.
function move_piece_to_square(piece, square, suppress)
{
    var from_square, move_text, castle_move_text;

    assert(piece, "move_piece_to_square(" + piece + ", " + square + "): piece is false");
    assert(square, "move_piece_to_square(" + piece + ", " + square + "): square is false");

    from_square = sq(piece);

    // Moving king makes it ineligible for castling
    if (piece.type === "king") {
        GAME_STATE.can_castle[GAME_STATE.active_color].short = false;
        GAME_STATE.can_castle[GAME_STATE.active_color].long = false;
    } else if (piece.type === "rook") {
        // TODO: More generic, so will work with chess960 or 480
        // If moved either rook, can't castle on that side.
        if (from_square.x == 7)
            GAME_STATE.can_castle[GAME_STATE.active_color].short = false;
        else if (from_square.x == 0)
            GAME_STATE.can_castle[GAME_STATE.active_color].long = false;
    }

    // If castling, move the rook in place. Ugly hardcoded.
    if (piece.type === "king") {
        var first_rank = (GAME_STATE.active_color === "white" ? 7 : 0);
        if (from_square.x === 4) {
            if (square.x === 6) {
                // TODO: actually calculate square moved over, then move rook there
                // (instead of hardcoding). Short.
                move_piece_to_square(pc(7, first_rank), sq(5, first_rank), true);
                castle_move_text = "O-O";
            } else if (square.x === 2) {
                // Castle long.
                move_piece_to_square(pc(0, first_rank), sq(3, first_rank), true);
                castle_move_text = "O-O-O";
            }
        }
    }

    // Generate algebraic move notation
    move_text = algebraic_letter(piece.type);

    // Capture piece(s) on destination square. Multiple pieces
    // are supported here, but not elsewhere in the code (yet). Might be
    // an interesting variation to have multiple pieces occupy same square.
    while (square.firstChild) {

        // If pawn was capturing, need to show file it came from.
        if (piece.type === "pawn") {
            move_text += xy2filerank([from_square.x, from_square.y]).substr(0, 1);
        }

        move_text += "x";

        capture_piece(square.firstChild);
        square.removeChild(square.firstChild);


    }

    move_text += xy2filerank([square.x, square.y]);

    // Move to new square
    if (piece.parentNode) {
        piece.parentNode.removeChild(piece);
    }

    square.appendChild(piece);

    if (should_promote(piece)) {
        promote(piece);

        move_text += "=Q";  // TODO: get return value from promote(), different values. Maybe need a callback, user interaction.
    }

    if (castle_move_text) {
        move_text = castle_move_text;
    }

    // TODO: record move in algebraic notation, and how about descriptive too?
    // TODO: also, CRAN (Concise Reversible Algebraic Notation, see http://www.chessville.com/reviews/PlayStrongerChessExaminingChess960.htm )

    // If not a multi-move (moving rook in castling), log and go to next turn
    if (!suppress) {
        // TODO: ellipsis if black is first recorded move
        //var alg_move = GAME_STATE.fullmove_number + ". " + (GAME_STATE.active_color === "black" ? " ... " : "") + move_text;
        var alg_move = (GAME_STATE.active_color === "white" ? GAME_STATE.fullmove_number + ". " : " ") + move_text + 
                       (GAME_STATE.active_color === "black" ? "\n" : "");

        $("moves").value += alg_move;
        set_turn("next");
    }
}

// Handle graphically moving of a piece, dropping it to its new location
function move_dropped_piece(piece, square, event)
{    
    //console.log(piece);
    //console.log(square);

    // TODO: do some cool effects when a piece is captured, but not too cool
    // Any way to finish running the code AFTER the effect finishes? New effect?
    //if (square.firstChild) {
    //   new Effect.Squish(pc(square));
    //}

    // Can't drop this piece anywhere anymore.
    piece.removeClassName("piece-" + piece.prior_position);
    ALL_DROP_TARGETS.each(function(square) {
        Droppables.remove(square);
    });
    ALL_DROP_TARGETS = [];

    unhighlight_all();

    move_piece_to_square(piece, square);
}

// TODO: save_fen
//
// Load board state
function load_fen(fen)
{
    var parts, castling;

    parts = fen.split(" ");
    load_starting_position(parts[0]);

    assert(/^[wb]$/.test(parts[1]), "load_fen(" + fen + "): bad active color: " + parts[1]);

    castling = parts[2];
    GAME_STATE.can_castle.white.short = /K/.test(castling);
    GAME_STATE.can_castle.white.long = /Q/.test(castling);
    GAME_STATE.can_castle.black.short = /k/.test(castling);
    GAME_STATE.can_castle.white.short = /q/.test(castling);

    if (parts[3] === "-") {
        GAME_STATE.enpassant_target = null;
    } else {
        GAME_STATE.enpassant_target = filerank2xy(parts[3]);
    }

    GAME_STATE.halfmove_clock = parseInt(parts[4], 10);
    GAME_STATE.fullmove_number = parseInt(parts[5], 10);

    // Now that everything is loaded, set the turn.
    set_turn({w:"white", b:"black"}[parts[1]]);
}

// Remove all pieces from the board.
function clear_board()
{
    for (var x = 0; x < 8; ++x) {
        for (var y = 0; y < 8; ++y) {
            var square = sq(x, y);
            while(square.firstChild) {
                square.removeChild(square.firstChild);
            }
        }
    }
}

// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR
function load_starting_position(fen)
{
    var i, x, y, code, square;

    clear_board();

    // Note that ranks and files internally are represented here by
    // x,y coordinates, so a8 = 0,0. That is where FEN starts.
    x = y = 0;
    for (i = 0; i < fen.length; ++i) {
        code = fen.charAt(i);
        if (/[a-zA-Z]/.test(code)) {
            sq(x, y).appendChild(create_piece(code));
            ++x;
        } else if (code === "/") {
            x = 0;
            ++y;
        } else if (/[0-9]/.test(code)) {
            x += code.charCodeAt(0) - "0".charCodeAt(0);
        } else if (code === " ") {
            break;
        } else {
            assert("load_starting_position(" + fen + "): unknown code: " + code);
        }
    }
}

//// PIECE FUNCTIONS

/// TODO: a "piece lab", where can dynamically create new pieces,
// browse existing pieces. Show piece on board by itself, highlighting 
// valid moves, update when change Parlett movement types, allow to operate
// the piece and see how it behaves. Then return to the main board.

// Return the letter, if any, used for representing the piece type (name)
// in algebraic notation.
function algebraic_letter(type)
{
    if (PIECE_TYPES[type].alg_letter !== undefined)
        return PIECE_TYPES[type].alg_letter;
    else
        return PIECE_TYPES[type].letter;
}

// Given a letter, find the name of the piece (R = rook, etc.). The letter
// can either be for FEN (P = pawn), or algebraic notation (blank = pawn);
// both are recognized.
var cache_letter2name;
function piece_letter2name(letter)
{
    letter = letter.toUpperCase();

    if (!cache_letter2name) {
        cache_letter2name = new Hash();

        for (var name in PIECE_TYPES) {
            var info = PIECE_TYPES[name];

            if (info.letter !== undefined) {
                cache_letter2name.set(info.letter, name);
            } if (info.alg_letter !== undefined) {
                cache_letter2name.set(info.alg_letter, name);
            }
        }
    }

    return cache_letter2name.get(letter.toUpperCase());
}

// Return algebraic prefix for a piece. May return an empty 
// string (for pawns, for example).
function algebraic_piece_prefix(piece)
{
    if (PIECE_TYPES[piece.type].letter !== undefined) {
        return PIECE_TYPES[piece.type].letter;
    } else if (PIECE_TYPES[piece.type].alg_letter !== undefined) {
        return PIECE_TYPES[piece.type].alg_letter;
    }

    assert(false, "algebraic_piece_prefix(" + piece + "): unrecognized piece");
}



// Return an existing piece somewhere (or a false value), given:
// - (x,y) coordinates, like (0,0)
// - location in filerank notation, like "a8"
// - a square, from sq()
function pc(x, y)
{
    if (x.hasClassName && x.hasClassName("square")) {
        return x.childNodes[0];
    }

    var square = sq(x, y);

    return square.childNodes[0];
}

// Get (x,y) of piece. For filerank notation, use xy2filerank on this.
function piece_location(piece)
{
    assert(piece, "piece_location(" + piece + "): piece is false");
    assert(piece.parentNode, "piece_location(" + piece + "): piece.parentNode is false, callee=" + arguments.callee);

    return [piece.parentNode.x, piece.parentNode.y];
}

// Return the path to an image for the piece of that color
function image_path_for(letter, color)
{
    // TODO: pngs
    // TODO: even better, use Unicode characters in a span!! How cool would that be? Infinite resolution.
    // See for example http://en.wikipedia.org/wiki/Knight_(chess)
    // Unfortunately, MSIE doesn't seem to support it, though it should..different font?
    return "images/" + {white:"w", black:"b"}[color] + letter.toLowerCase() + ".gif";
}

// Create a new piece or pawn, given the name in
// Forsyth-Edwards Notation, for example:
//  r = black rook, R = white rook, N = white knight
// TODO: make this a class so you can do new Piece().
function create_piece(name)
{
    var color, filename, piece, letter, type;

    // In FEN, uppercase=white, lower=black
    if (/^[A-Z]/.test(name)) {
        color = "white";
    } else if (/^[a-z]/.test(name)) {
        color = "black";
    } else {
        assert("create_piece(" + name + "): not a letter");
    }
    letter = name.toLowerCase();
    type = piece_letter2name(letter);

    // TODO: catch invalid letters, lookup PIECE_TYPES

    filename = image_path_for(letter, color);

    piece = Builder.node('img', {'src': filename, 'class': "piece " + color + " " + type});

    // Property will tell name of piece. To tell what color, or if it is
    // a piece in the first place, check the class names.
    piece.type = type;

    // Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
    // Yahoo Games does this too, but uses a yellow outline.
    Event.observe(piece, 'mouseover', function() {
            highlight_moves(piece, true);
            // for debugging
            //piece.setStyle({border: '1px solid black'});
        });
    Event.observe(piece, 'mouseout', function() {
            highlight_moves(piece, false);
            //piece.setStyle({border: 'none'});
        });

    // Make all new pieces draggable. I tried only making the active color's
    // pieces draggable, but then in Safari they can still be selected like text,
    // even with enable_document_selection(false), maybe I need to enable it on the
    // images too, but it wasn't appealing. In Firefox, the images can be dragged
    // as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
    // if they are the active colors move. The player can drag the opponent's pieces
    // around but not drop anywhere.

    // TODO: instead of reverting, check if valid move
    // TODO: Figure out how to fix how the draggable jumps, by the amount it moved,
    // when being dropped. http://www.tutorialspoint.com/cgi-bin/practice.cgi?file=scriptaculous_12 
    // does this too. reverteffect defaults to Effect.Move, and it reverts back to *something*,
    // figure this point.

    // Note: http://www.jslint.com/ stops here for some reason
    new Draggable(piece, { 
        revert: true, 
        starteffect: undefined, 
        endeffect: undefined,
        onStart: function() { GAME_STATE.dragging = true; },
        onEnd: function() { GAME_STATE.dragging = false; }
        // TODO: figure out why on IE7, dragged pieces are below the highlighted squares!
        // even with zindex: 1001
     });


    return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
function highlight_moves(piece, enable)
{
    var from_square, moves;

    // If player is dragging a piece over another piece, don't show
    // legal moves for the piece under it.
    if (GAME_STATE.dragging) {
        return;
        }

    // If not this player's turn, no legal moves
    if (!piece.hasClassName(GAME_STATE.active_color)) {
        return [];
    }

    from_square = sq(piece);

    //console.log(from_square.filerank);
    moves = VALID_MOVES.get(from_square.filerank);
    //console.log(moves);
    if (!moves) {
        return;    
        }

    moves.each(function(move) {
        var x, y, flags, to_square;
        
        x = move[0];
        y = move[1];
        flags = move[2];
        to_square = sq(x, y);

        if (enable) {
            if (to_square.hasClassName("white")) {
                to_square.addClassName("legal-move-white");
                        } else {
                to_square.addClassName("legal-move-black");
                        }
        } else {
                to_square.removeClassName("legal-move-white");
                to_square.removeClassName("legal-move-black");
        }
    });
}

// Unhighlight all highlighted black/white squares. Used in onEnd draggable, for
// some reason, highlight_moves(piece, false) does not unhighlight, maybe the piece changed..
function unhighlight_all()
{
    $$("td.legal-move-white", "td.legal-move-black").each(function(square) {
        square.removeClassName("legal-move-white");
        square.removeClassName("legal-move-black");
    });
}

//// SQUARE FUNCTIONS / FILE-RANK NOTATION

// Convert filerank f8 to the x,y coordinate [5,0], etc. These coordinates
// are used internally, but filerank notation is useful for human consumption
// (though I actually think better in descriptive notation, but maybe I'm in the minority there)
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// zero-based table cell with (0,0) at the top-left. In filerank notation, this
// square is labeled a8. The bottom-right square (7,7) is filerank's h1.
function filerank2xy(code)
{
    assert(code, "filerank2xy(" + code + "): is false");
    assert(code.charCodeAt, "filerank2xy(" + code +"): is missing charCodeAt, is it a string?" +
            " code.className=" + code.className);

    var x = code.charCodeAt(0) - "a".charCodeAt(0);        // corresponds to file (horizontal)
    var y = 8 - (code.charCodeAt(1) - "0".charCodeAt(0));    // corresponds to rank (vertical)

    assert(x >= 0 && x <= 7, "filerank2xy(" + code + "): bad x: " + x);
    assert(y >= 0 && y <= 7, "filerank2xy(" + code + "): bad y: " + y);

    return [x, y];
}

// Convert from x,y coordinates to filerank notation for human consumption. Can either pass
// xy2filerank(0, 0) === "a8"
// xy2filerank([0, 0]) === "a8"
function xy2filerank(x, y)
{
    var filerank;

    if (y === undefined) {
        // Passed array
        y = x[1];
        x = x[0];
    }

    assert(x >= 0 && x <= 7, "xy2filerank(" + x + ", " + y + "): bad x: " + x);
    assert(y >= 0 && y <= 7, "xy2filerank(" + x + ", " + y + "): bad y: " + y);

    filerank = String.fromCharCode(x + "a".charCodeAt(0));
    filerank += String.fromCharCode((8 - y) + "0".charCodeAt(0));

    return filerank;
}

// Get a square cell, given location in either
// - filerank notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 0,0)
// - a piece, returned by pc(), will return the enclosing square
function sq(code, extra)
{
    var x, y;

    // Is it a piece?
    if (code.hasClassName && code.hasClassName("piece")) {
        var xy = piece_location(code);

        x = xy[0];
        y = xy[1];
    // Is it x,y passed as separate parameters?
    } else if (extra !== undefined) {
        x = code;
        y = extra;
    // Is it a string in algebraic notation that can be converted?
    } else if (code.charCodeAt) {
        var xy = filerank2xy(code);

        // TODO: can JS do list element assignment like x,y=...?    
        x = xy[0];
        y = xy[1];
    } else {
        assert(false, "sq(" + code + ", " + extra + "): couldn't find out arguments");
    }

    assert(x >= 0 && x <= 7 && y >= 0 && y <= 7, "sq(" + code + ", " + extra + 
        "): out of range (" + x + ", " + y + ")");

    return $('board-body').childNodes[y + 1].childNodes[x + 1];
}

//// LOW-LEVEL FUNCTIONS

// Random integer within range
function randint(minimum, maximum)
{
    return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}

// Uppercase first character, like in Perl
function ucfirst(s)
{
    return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
    return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
    if (!expression) {
        alert(message);
        throw new AssertException(message);
    }
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
function enable_document_selection(enable) {
    if(enable) {
        document.onselectstart = _original_onselectstart;
    } else {
        _original_onselectstart = document.onselectstart;
        document.onselectstart = function() { return false; }
    }
}

</script>
</head>

<body>
<table id="outer">
 <tr>
  <td>
<table class="board" id="board">
<tbody id="board-body"
><tr
  ><td></td
  ><td class="file label">a</td
  ><td class="file label">b</td
  ><td class="file label">c</td
  ><td class="file label">d</td
  ><td class="file label">e</td
  ><td class="file label">f</td
  ><td class="file label">g</td
  ><td class="file label">h</td
></tr
><tr
  ><td class="rank label">8</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">7</td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square right-edge"></td
></tr
><tr
  ><td class="rank label">6</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">5</td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square right-edge"></td
></tr
><tr
  ><td class="rank label">4</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">3</td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square right-edge"></td
></tr
><tr
  ><td class="rank label">2</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">1</td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge"></td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge"></td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge"></td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge right-edge"></td
></tr
></tbody
></table>

 </td><td style="vertical-align: top">
  <select name="white_player" id="white_player" onchange="computer_move_if_applicable()">
   <option value="human">Human</option>
   <option value="computer">Computer</option>
   <option value="network" title="TODO: allow playing with a remote user, either human (running this web app) or a computer (chess engine)">Network</option>
  </select>
  vs.
   <select name="black_player" id="black_player" onchange="computer_move_if_applicable()">
   <option value="human">Human</option>
   <option value="computer" selected>Computer</option>
   <option value="network">Network</option>
  </select>
 
  <p id="status"></p>

  <textarea name="moves" id="moves" rows="20"></textarea>

  <!-- TODO: give current FEN from save_fen(), so can edit -->
  <p><a href="javascript:load_fen(prompt('Enter game state in FEN notation:'))">Load FEN</a>
 </td>
</tr>
</table>

</body>
</html>
