<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<!-- TODO: set to 0.4 onchangeorientation to landscape -->
<meta name="viewport" content="width=device-width; initial-scale=0.65; maximum-scale=0.65; user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<!-- TODO <base href="http://xyzzy.freeshell.org/chess/"> -->
<title>Chess by Jeff</title>
<!-- Copyright (C) 2009-2011 Jeff Connelly -->
<!-- Created:20090411 -->
<style type="text/css">

/* Do not wrap game browser opening content. */
.dojoxGridCell { white-space: nowrap; }

body {
    font: medium 'Gill Sans', sans-serif;
    line-height: 1.3;
    word-spacing: 0.1em;
    margin: 0;
    padding: 0;
    border: 0;
}

/* Header */
span.players { font-size: large; }
span.player_name { font-weight: bold; }
span.player_elo { font-size: small; }

#status { font-weight: bold; }
#opening_name { font-size: small; }

/* PGN */
span.fmvn { font-weight: bold; }
span.move_annotation { font: medium 'Times'; }
a { text-decoration: none; border: 1px solid #fff; }
/* Yellow highlights and borders - inspired by http://www.chess.com/emboard.html?id=353899 */
a:hover { color: #060; background-color: #ff9; border-bottom: 1px dotted; }
a.active_move { border-bottom: 1px dashed; background-color: #ff0; border: 1px solid #fc0; }
/*a.repeated_move { text-decoration: underline; }*/     /* goes well with dots and dashes */
/*a.repeated_move { background-color: yellow; }*/   /* highlight */

/* Element that can be dragged */
.draggable { position: absolute; cursor: move; }

/* Piece object - for flexibility, this is a <div> with a CSS background-image, instead of an <img> */
div.piece
{ 
 border: none;
 margin: 0px;


 /* Note: images might not actually all be this size, but should be close (TODO: resize them all!) */
 width: 49px;
 height: 49px;

 /* Scale to fit.. important for miniature (captured) piece images, otherwise they'll be clipped */
 /* Note this is a CSS3 property */
 background-size: 100%;

 /* Make captured pieces (smaller) look better on IE7+. See
  * http://www.gabrielweinberg.com/blog/2009/06/things-about-web-images-i-just-learned.html
  */
 -ms-interpolation-mode: bicubic;

 /* TODO: Transition when promote, would be nice to be
  * able to do with a CSS transition, but img src is not
  * a CSS property, but a tag attribute. And even if tried to animate
  * background-image, it wouldn't work until 6806248 is fixed.
  *
  * Or could have two images and change their opacity, see
  * http://www.the-art-of-web.com/css/timing-function/ section 4, but
  * that is even worse. */
 /*-webkit-transition: background 1s linear;*/


 /* For optional textContents overlaid on image */
 text-align: center;  
 font-weight: bold;
 line-height: 49px;     /* center, by matching to div height */
}

div.captured
{
 width: 25px;
 height: 25px;
 position: static;
 float: left;
}

div.black 
{ 
    /* Text color, easier to read on dark background */
    color: white; 
}
div.white {}
div.neutral {}

.canvas-board
{
/* Disable text selection when dragging */
/* http://www.w3.org/TR/1999/WD-css3-userint-19990916#user-select */
 -moz-user-select: none;
 -webkit-user-select: none;
 user-select: none;
}

td.square
{
 border-style: none;
 padding: 0em;
 margin: 0em;
 width: 55px; min-width: 55px;
 height: 55px; min-height: 55px;
 text-align: center;

 /* So absolutely positioned images in cell are not misaligned */
 vertical-align: top;
 text-align: left;
}

#piece-inspector {
    position: absolute; 
    border: 1px solid black; 
    background-color: #d3d3d3;
    /* Need to make this large, so king's movement doesn't extend beyond box. 
     * Would like to have the movement wrap, but I guess ; is not a word-breaking
     * character, so could use &shy;, works on Safari, and supposedly IE7 and Firefox.
     */
    width: 600px;

    /* Had to set this explicitly since inspector-diagram is positioned relatively
     * and won't expand the cell. */
    height: 450px;

    -webkit-box-shadow: 0 1px 20px rgba(0, 0, 0, 0.9); 
}

#inspector-diagram {
    margin-top: 10pt;
    font-family: Courier, Courier New; 
    font-size: 7pt;
    position: relative;
}

div.inspector-diagram-cell {
    width: 10px; 
    height: 10px; 
    position: absolute; 
    /*TODO: : 1px solid white;*/
}

</style>
<!--<script type='text/javascript' src='http://getfirebug.com/releases/lite/1.2/firebug-lite-compressed.js'></script>-->
<!--<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js.uncompressed.js"></script>-->

<script src="dojo.xd.js"></script>

<!--<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js" djConfig="parseOnLoad: true"></script>-->

<script type="text/javascript">
/*jslint bitwise: true, browser: true, eqeqeq: true, immed: true, newcap: true, nomen: true, plusplus: true, regexp: true, undef: true*/
/*global window google form_value Hash $break Event*/

// Chess movement notations, in descending precedence. 
// For more info see http://en.wikipedia.org/wiki/Chess_notation
var AVAILABLE_NOTATIONS = {
    // Acronym: full name                               examples
    SAN:  "Standard Algebraic Notation",//              Bxc6        e5
    LAN:  "Long Algebraic Notation",//                  Bb5xc6      e7-e5
    MAN:  "Minimal Algebraic Notation",//               Bc6         e5
    RAN:  "Reversible Algebraic Notation",//            Bb5xNc6     e7-e5
    CRAN: "Concise Reversible Algebraic Notation",//    Bb5:Nc6     e75
    FAN:  "Figurine Algebraic Notation",//              ♗xc6        ♟e5
    ICCF: "ICCF Numeric Notation",//                    2536        5755
    coord:"Computer Coordinate Notation",// aka CCN     B5-C6       E7-E5
    smith:"Smith Notation",//                           b5c6n       e7e5
    descr:"English Descriptive Notation",// aka EDN     BxN         P-K4
    adesc:"Algebraic Descriptive Notation",//           BxN         P-e4
    wxf:  "World Xiangqi Federation Notation",//        C2=5        H8+7
    xq:   "Traditional Chinese Xiangqi"//               車二平五    馬8進7
    // TODO: http://en.wikipedia.org/wiki/Xiangqi#Notational_system_1 and http://en.wikipedia.org/wiki/Xiangqi#Notational_system_3_.28unofficial.2C_for_players_of_Western_Chess.29
    // TODO: http://en.wikipedia.org/wiki/Taikyoku_shogi#Game_notation
};

// Preferences, not game state.
var PREFS = {
    revert_time: 350,               // ms to take to revert
    movement_animation_time: 100,   // ms to animate moving of pieces

    input_notation: "SAN",          // Move list menu
    output_notation: "SAN",         // Move history

    image_root: "images/",
    //image_root: "http://camelpawn.appspot.com/images/",    // on Google App Engine (TODO: update)
    // What piece images to use
    image_set: "alfaerieomega", image_extension: ".gif",   // most comprehensive
    //image_set: "ariel", image_extension: ".gif",         // based on Ariel Unicode MS
    //image_set: "chessos", image_extension: ".gif",
    //image_set: "classic", image_extension: ".png",
    image_prefixes: {white:"w", black:"b", neutral:"e"},
    
    server: "http://chess.heroku.com/",           // Remote backend game server (note: actually overwritten from document.location!)

    engine: "http://jeff.tk:81/chess/crafty.cgi",
    skill: 0,                                     // engine strength, 0-100

    flipped: false,             // True if from black's perspective instead of white
    rank_label_style: "Arabic", // "Arabic" (1-8) or "Roman" (i-x) numerals
    file_label_style: "Latin",  // "Latin" (a-z) or "Arabic"
    setup_mode: false,          // Setup pieces, instead of playing game

    saved_games_path: "games/",

    show_castling_impediments:false,    // Highlight squares preventing castling
    variant_generator:null              // Setup function for randomized games

};

// Board display and drawing settings
var DISPLAY = {
    board_top:26,
    file_labels_top:19,
    file_labels_left:25,
    label_font:"12pt Gill Sans",
    board_left:20,
    rank_labels_left:10,
    rank_labels_top:4,
    board_border:2,

    // TODO: support smaller squares for larger boards like Taikyoku Shogi (36x36)? 
    // It is possible to zoom out with Cmd-(-), but only to an extent
    square_width:55,
    square_height:55,

    // for 'classic' piece set
    /*square_width:50,
    square_height:50,*/

    // Colors
 /* TODO: yellow - piece to promote
 * green - legal moves
 * red - blocked moves (when shift-hover), guarded squares
 * blue - move opponent just made
 */


   
    // Squares
    black:"#d18b47", white:"#ffce9e", // a pleasant tan

    // Use Applications/Utilities/DigitalColor Meter to get hex colors
    
    // From Chess.com
    //black: "#739254", white:"#e9e9ce",  // soft green
    //black: "#4d6d92", white:"#ebebd6",  // soft blue

    // From ExaChess
    //black:"#9999ff", white:"#ffffcc", // light blue
    //black:"#cc9966", white:"#ffdcab", // light brown
    //black:"#bbbbbb", white:"#eeeeee", // light gray
    //black:"#339933", white:"#eeeeee", // light green

    // From Chess with Friends (but has shadows)
    //black:"#8b8bb1", white:"#ecece7", // medium blue

    // Shredder, Yahoo Chess use textured boards
    // (would require images)
    

    //black:"#000000", white:"#ffffff",     // monochrome
    //black:"#00bb00", white:"#ffffcc",     // medium green (Wikipedia)
    //black:"#996600", white:"#cccc66",     // medium brown (ChessOS)

    // Highlighting of legal moves on mouseover
    legal_move_white: "seagreen",
    legal_move_black: "green",

    // Highlighting blocked moves on shift-mouseover
    blocked_move_white: "indianred",
    blocked_move_black: "firebrick",

    // Source move, when already moved a piece from this square, and mousing over when about to
    recent_move_white: "blue",
    recent_move_black: "blue",

    highlights: {},    // Color of legal move highlighted squares, for restoring color on drop over
    native_square_images:{}, // Image of square without any highlights (includes color and borders)

    text_color:"black",
    feature_border_width:3,

    canvas:null,        // The HTML canvas element
    context:null,       // 2D drawing context
    clean_board:null    // Image data of a clean, unmarked board
};


// Predefined game rules for rs EPD opcode, makes it more compact to store non-FIDE games
var RULE_SETS = {
    shatranj: { 
        uncheckered: true, 
        ruled: true, 
        stalemate: "win" 
    },

    // King moves three squares instead of two, useful for 8x10 board
    triple_castle: {
        castle_moves: {
            clong: {castle_to: 4, king_to: 3},
            cshort: {castle_to: 8, king_to: 9}
        },
    },

    // ... and four squares
    quad_castle: {
        castle_moves: {
            clong: {castle_to: 4, king_to: 3},
            cshort: {castle_to: 9, king_to: 8}
        },
    },


    // Xiangqi where pieces are on intersections
    xiangqi: {
        on_intersections:true,

        ranks:10, 
        files:9,
      
        // piece movement restrictions
        bounds1:"river,1,1,10,5,elephant", 
        bounds2:"palace,4,1,6,3,general,ferz",

        // Graphical board features to show piece movement restrictions
        features:[
            {fill:true, color:"lightblue", file:1, rank:5, width:9, height:5},      // background
            {over:true, fill: true, color:"lightblue", file:1, rank:6, width:9, height:1, shift_y:true}, // river

            // palace
            {cross:true, over:true, color:"black", file:4, rank:3, width:2, height:2, shift_y:true, shift_x:true},
        ],

        PREFS:{ // TODO: need defaults for non-wxf prefs
            input_notation:"wxf",
            output_notation:"wxf",
            rank_label_style:"Roman",
            file_label_style:"Arabic"
        },

        //TODO: player_colors:{"red", "green"},

        ruled:true,
        uncheckered:true
        // TODO: decorations around some points, like on http://www.goddesschess.com/graphics/xiangqi1.jpg
     },

     // "Westernized" Xiangqi, where pieces sit on squares
     xiangqiw: {
        ranks:10, 
        files:9,
      
        // piece movement restrictions
        bounds1:"river,1,1,10,5,elephant", 
        bounds2:"palace,4,1,6,3,general,ferz",

        // Graphical board features to show piece movement restrictions
        features:[
            // Karakus' Xiangqi westernization using lines and outlines to indicate features on a checkered board
            // http://www.chessvariants.com/xiangqi.dir/xiangqiwest.html
            // Draw these over the board (after the original lines are drawn)
            {over:true, color:"yellow", file:4, rank:3, width:3, height:3},    // palace
            {over:true, color:"blue", file:1, rank:5, width:9, height:5},      // river

            // Crockford's Xiangqi westernization using square color to indicate features on an uncheckered board
            // http://www.crockford.com/chess/xiangqi.html
            {fill:true, color:"same", file:1, rank:5, width:9, height:5},        // sides of river
            {fill:true, color:"opposite", file:4, rank:3, width:3, height:3},    // palace
        ],


        ruled:true,
        transparent:true
    }
};

// Info about the game
var GAME_STATE = null;
var GAME_STATE_DEFAULT = {
    // Whose turn it is
    active_color: '',
    //TODO: player_colors: ["white", "black"],
    
    // Castling privileges, keyed by file of castle (a or h for chess1)
    can_castle: {white: {}, black: {}},

    // Where the kings and castles are moved to when castling. 
    // Here, long means a-side (O-O-O) and short h-side (O-O).
    castle_moves: {
        clong: {castle_to: 4, king_to: 3},
        cshort: {castle_to: 6, king_to: 7}
    },

    ep_target: null,

    hmvc: 0,                    // Halfmove clock: Ply since last pawn advance / capture
    fmvn: 0,                    // Fullmove number: Increment after black moves

    position_moves: {},         // Board position -> move IDs, for 3n move repetition
    position_after: [],         // Board positions at each move, for quick playback
    made_moves: [],             // Piece, square and each move notation for past moves
    annotations: [],            // Array of arrays of optional notes about each move
    ended: false,               // Game is done (drawn, won)
    captured: {white:[], black:[]}, // Captured pieces

    boundaries: {},             // Board restrictions that bound piece movement
    transparent:false,          // Squares empty, otherwise are filled in
    uncheckered:false,          // Squares all white, otherwise alternating colors
    ruled:false,                // Squares have borders (useful for non-checkered boards)
    ranks:8,                    // Number of ranks
    files:8,                    // Number of files
 
    // Not game state, but other globals
    dragging: false,
    active_in_check: false,
    last_captured: null,        // export_captured() string _before_ current move 
    piece_under: null,          // Piece under cursor for piece inspector
    shift: false,               // Whether shift key is pressed
    update_custom: false,       // Whether custom movement field is focused and being typed in
    update_piece_query: false,  // Whether piece library query field is focused & being typed in
    alert_assert: true          // Whether to alert assertion errors
}; 

var SESSION = {
    logged_in: false
};

/// Drag and drop globals
var DRAG = 
{
    start_x: 0,
    start_y: 0,
    offset_x: 0,        
    offset_y: 0,
    element_m: null,    // what is being dragged by the mouse
    element_t: null,    // by the touch interface
    old_zindex: 0,      // z-index of dragging element to restore
    touching: false,    // whether something is being touched
    dragging: false     // whether a drag is in progress
};

var DROP = {
    area: {},           // box to detect drop areas in
    square: null,       // square dropping over 
    offboard: false     // whether dropping offboard or not
};

var ANNOTATIONS = {
    "!": "Good move",
    "?": "Poor move",
    "!!": "Brilliant move",
    "??": "Very poor move",
    "!?": "Speculative move",
    "?!": "Questionable move",

    "=": "Equal chances, quiet position",
    "+=": "White has a slight advantage",
    "=+": "Black has a slight advantage",
    "+/-": "White has a moderate advantage",
    "-/+": "Black has a moderate advantage",
    "+-": "White has a decisive advantage",
    "-+": "Black has a decisive advantage",
    "+--": "White has a crushing advantage",
    "--+": "Black has a crushing advantage",

    "(oo)": "Unclear",
    "(N)": "Novelty",
    "(&)": "Compensation",
    "(<->)": "With counterplay",
    "(^)": "With initiative",
    "(->)": "With attack",
    "(tm)": "Time trouble",
    "([])": "Only move",
    "(=)": "Draw offered"
};

// Numerical Annotation GlyphsNAG for "only move", see http://www.markalowery.net/Chess/Notation/NAG.html
var NAGS = [
    "Null",
    "!",
    "?",
    "!!",
    "??",
    "!?",
    "?!",

    "Forced move (all others lose quickly)",
    "Singular move (no reasonable alternatives)",
    "Worst move",
    "Drawish position",
    "Equal chances, quiet position",
    "Equal chances, active position",
    "Unclear position",
    "White has a slight advantage (+=)",
    "Black has a slight advantage (=+)",
    "White has a moderate advantage (+/-)",
    "Black has a moderate advantage (-/+)",
    "White has a decisive advantage (+-)",
    "Black has a decisive advantage (-+)",
    "White has a crushing advantage (+--)",
    "Black has a crushing advantage (--+)",
    "White is in zugzwang",
    "Black is in zugzwang",
    "White has a slight space advantage",
    "Black has a slight space advantage",
    "White has a moderate space advantage",
    "Black has a moderate space advantage",
    "White has a decisive space advantage",
    "Black has a decisive space advantage",
    "White has a slight time (development) advantage",
    "Black has a slight time (development) advantage",
    "White has a moderate time (development) advantage",
    "Black has a moderate time (development) advantage",
    "White has a decisive time (development) advantage",
    "Black has a decisive time (development) advantage",
    "White has the initiative",
    "Black has the initiative",
    "White has a lasting initiative",
    "Black has a lasting initiative",
    "White has the attack",
    "Black has the attack",
    "White has insufficient compensation for material deficit",
    "Black has insufficient compensation for material deficit",
    "White has sufficient compensation for material deficit",
    "Black has sufficient compensation for material deficit",
    "White has more than adequate compensation for material deficit",
    "Black has more than adequate compensation for material deficit",
    "White has a slight center control advantage",
    "Black has a slight center control advantage",
    "White has a moderate center control advantage",
    "Black has a moderate center control advantage",
    "White has a decisive center control advantage",
    "Black has a decisive center control advantage",
    "White has a slight kingside control advantage",
    "Black has a slight kingside control advantage",
    "White has a moderate kingside control advantage",
    "Black has a moderate kingside control advantage",
    "White has a decisive kingside control advantage",
    "Black has a decisive kingside control advantage",
    "White has a slight queenside control advantage",
    "Black has a slight queenside control advantage",
    "White has a moderate queenside control advantage",
    "Black has a moderate queenside control advantage",
    "White has a decisive queenside control advantage",
    "Black has a decisive queenside control advantage",
    "White has a vulnerable first rank",
    "Black has a vulnerable first rank",
    "White has a well-protected first rank",
    "Black has a well-protected first rank",
    "White has a poorly protected king",
    "Black has a poorly protected king",
    "White has a well-protected king",
    "Black has a well-protected king",
    "White has a poorly placed king",
    "Black has a poorly placed king",
    "White has a well-placed king",
    "Black has a well-placed king",
    "White has a very weak pawn structure",
    "Black has a very weak pawn structure",
    "White has a moderately weak pawn structure",
    "Black has a moderately weak pawn structure",
    "White has a moderately strong pawn structure",
    "Black has a moderately strong pawn structure",
    "White has a very strong pawn structure",
    "Black has a very strong pawn structure",
    "White has poor knight placement",
    "Black has poor knight placement",
    "White has good knight placement",
    "Black has good knight placement",
    "White has poor bishop placement",
    "Black has poor bishop placement",
    "White has good bishop placement",
    "Black has good bishop placement",
    "White has poor rook placement",
    "Black has poor rook placement",
    "White has good rook placement",
    "Black has good rook placement",
    "White has poor queen placement",
    "Black has poor queen placement",
    "White has good queen placement",
    "Black has good queen placement",
    "White has poor piece coordination",
    "Black has poor piece coordination",
    "White has good piece coordination",
    "Black has good piece coordination",
    "White has played the opening very poorly",
    "Black has played the opening very poorly",
    "White has played the opening poorly",
    "Black has played the opening poorly",
    "White has played the opening well",
    "Black has played the opening well",
    "White has played the opening very well",
    "Black has played the opening very well",
    "White has played the middlegame very poorly",
    "Black has played the middlegame very poorly",
    "White has played the middlegame poorly",
    "Black has played the middlegame poorly",
    "White has played the middlegame well",
    "Black has played the middlegame well",
    "White has played the middlegame very well",
    "Black has played the middlegame very well",
    "White has played the ending very poorly",
    "Black has played the ending very poorly",
    "White has played the ending poorly",
    "Black has played the ending poorly",
    "White has played the ending well",
    "Black has played the ending well",
    "White has played the ending very well",
    "Black has played the ending very well",
    "White has slight counterplay",
    "Black has slight counterplay",
    "White has moderate counterplay",
    "Black has moderate counterplay",
    "White has decisive counterplay",
    "Black has decisive counterplay",
    "White has moderate time control pressure",
    "Black has moderate time control pressure",
    "White has severe time control pressure",
    "Black has severe time control pressure"        // $139
];

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;             // Keyed by filerank of source, array of moves, x, y and any flags
var IS_VALID_MOVE = null;           // Keyed by filerank of source, then filerank of dest
var BLOCKED_MOVES = null;           // Moves that would be valid except they're blocked
var VALID_MOVES_OPP = null;         // Moves opponent could make, if it was their turn (attacking)
var BLOCKED_MOVES_OPP = null;       // Opponent's blocked moves
var VALID_MOVE_NOTATIONS = null;    // Map SAN, LAN, MAN, RAN, CRAN, FAN, coord, desc, Smith etc. -> [piece, square]
var ALT_MOVE_NOTATIONS = null;      // Same as above, but non-canonical, longer forms (Nb1c3 when Nc3 would do, etc.)


// Board 
var VBOARD = null;                  // Virtual in-memory board

var AMP = String.fromCharCode(38);  // To avoid "not well-formed"

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
    // Keys:
    // parlett: movement of piece in extended Parlett notation
    // letter: uppercase character representing the piece in FEN
    // alg_letter: uppercase character for algebraic notation [defaults to FEN letter]
    // wxf_letter: uppercase character for WXF notation
    // cn_letter: Chinese letter for Xiangqi, either a string or 2-element array for first and second players
    // figurines: [white, black] Unicode strings for Figurine Algebraic Notation
    // hex: plane 1 (or higher) Unicode hex string, one character representing the piece
    //   U+#####. This is not a \u escape because that only accepts 4 hex digits!
    //   Also note, it is only one character, not two because there is not black/white (as with the figurines)
    //   (Not yet used, but intended to allow using arbitrary Unicode characters as pieces)
    //   Lots of interesting symbols at http://www.unicode.org/charts/PDF/Unicode-6.0/U60-1F300.pdf
    // iccf_number: number for ICCF Numberic Notation
    // royal: if true, if checked, must make move that unthreatens, otherwise checkmate
    // resets_50move: if true, resets the counter for the 50-move rule (pawns)
    // castles_with: piece to move in conjunction with this piece if castling
    // castle: if true, this piece can be moved during castling
    // promote: array of piece names that this piece can promote to, in order of preference

    // Standard international chess piece
    
    // TODO: @ for absolute, @3,0 and @4,0 short, then @7,0 for @6,0, in order to allow
    // Chess960 orthodox castling when rooks &amp; kings are not at known positions.
    king: {parlett: "1*, " +     // or ~0/1, ~1/1
             "[3,0;absolute_x;if_can_castle=long], " +
             "[7,0;absolute_x;if_can_castle=short]",
          royal: true, letter: "K", figurines: ["\u2654", "\u265a"],
          castles_with: "rook", url:"pc:king", tags:"fide "},
    queen: {parlett: "n*", letter: "Q", figurines: ["\u2655", "\u265b"], iccf_number: 1, url:"pc:queen", tags:"fide ", tags:"dame"},
    rook: {parlett: "n+", letter: "R", castle: true, figurines: ["\u2656", "\u265c"], iccf_number: 2, url:"pc:rook", aka:["chariot", "car"], tags:"fide ", cn_letter:"車"},
    bishop: {parlett: "nX", letter: "B", figurines: ["\u2657", "\u265d"], iccf_number: 3, url:"pc:bishop", aka:["courier", "alfieri"], tags:"fide "},
    knight: {parlett: "~1/2", letter: "N", figurines: ["\u2658", "\u265e"], iccf_number: 4, url:"pc:knight", tags:"fide ", aka:"cavalier"},


    // Pawns
    pawn: {parlett: 
        "o1>, c1X>, " + 
        "oi[0,2;if_unblocked=0,1;mark_ep_target=0,1], " +
        "[-1,1;if_ep_target;capture_at=-1,0], [1,1;if_ep_target;capture_at=-1,0]",

        image: "pawn",
        promote: ["queen", "knight", "rook", "bishop"],
        figurines: ["\u2659", "\u265f"],
        letter: "P",
        alg_letter: "",
        resets_50move: true,     // a pawn move resets the halfmove counter for the 50-move rule
        url: "pc:pawn",
        tags:"fide ",
        aka:"bauer"
    },
    optingpawn: {parlett:    // can make double-move on any rank
        "o1>, c1X>, " + 
        "o[0,2;if_unblocked=0,1;mark_ep_target=0,1], " +
        "[-1,1;if_ep_target;capture_at=-1,0], [1,1;if_ep_target;capture_at=-1,0]",
        promote: ["queen", "knight", "rook", "bishop"],
        url:"akm"
    },

    weakpawn: {parlett: "o1>, c1X>"},   // No double move, no promotion
    losalamospawn: {parlett: "o1>, c1X>", promote: ["queen", "rook", "knight"]},
    shatranjpawn: {parlett: "#weakpawn", promote:["ferz"], url:"http://en.wikipedia.org/wiki/Shatranj#Rules"},
    makrukpawn: {parlett: "#weakpawn", promote:["ferz"], promotion_rank:6, url:"http://en.wikipedia.org/wiki/Makruk#Pieces"},
    superpawn: {parlett: "on>, cnX>", letter: "XP", image:"quickpawn"},
    berolinapawn: {parlett: "o1X>, c1>, io2X>", letter: "XB", resets_50move: true, url:"pc:berolina"},
    leftberolinapawn: {parlett: "o1↖, c1>, io2↖", letter: "XB", resets_50move: true},
    rightberolinapawn: {parlett: "o1↗, c1>, io2↗", letter: "XB", resets_50move: true},
    berolinapluspawn: {parlett: "#berolinapawn, c1=", url:"pc:berolina-plus"}, 
    
    dragon: {parlett: "#pawn, #knight", image: ["dragon", "dragon2", "knightpawn", "pawnknight"], url:"pc:dragon", hex:"U+1F409"},   

    // TODO: support Arimaa pieces: camel, horse, dog, cat, rabbits - harder than chess
    // http://en.wikipedia.org/wiki/Arimaa and http://arvindn.livejournal.com/129555.html
    // David's pawn
    dog: {parlett: "#pawn, c#rook", aka:["pawnattackrook", "davidspawn"], promote: ["dragon", "rookpawn"]},

    breakthru: {parlett: "o1>, 1X>", promote:["universal_leaper"], image:"pawn135ccw", url:"http://en.wikipedia.org/wiki/Breakthrough_(board_game)"},
    
    sergeant: {parlett: "#berolinapawn, #pawn", promote:["queen", "knight", "rook", "bishop"], resets_50move:true, url:"pc:sergeant", aka:["grazpawn"]},

    steward: {parlett: "o1+, c1X", aka:["fusilier", "quadrapawn", "walker"]},
    liapawn: {parlett: "o1>, o1=, c1X, io2>"},

    fiveriderpawn: {parlett: "#pawn", promote: ["rook", "bishop", "nightrider", "camelrider", "zebrarider"], url:"akm"},
    //freeleaperpawn: {parlett: "#pawn", promote: ["wazir", "knight", "zebra", "giraffe", "antelope"], url:"akm"}, // TODO: requires antelope
    ccpawn: {parlett: "#pawn", promote: ["archbishop", "bede", "waffle", "fad"]},
    rrpawn: {parlett: "#pawn", promote: ["chancellor", "r4", "woodyrook", "halfduck"]},
    nnpawn: {parlett: "#pawn", promote: ["colonel", "chargingrook", "fibnif", "chargingknight"]},
    pkpawn: {parlett: "#pawn", promote: ["pepperoni", "sausage", "mushroom", "meatball"]},
 

    // Hippogonal leapers
    // See also: ~0/1 is wazir
    warmachine: {parlett: "~0/2", letter: "D", url:"pc:dabbabah"},  // or ~2+
    threeheadmonster: {parlett: "~0/3", aka:"threeleaper", hex:"U+1F47E"},
    fourleaper: {parlett: "~0/4", url:"http://www.ktn.freeuk.com/9a.htm#(2)"},
    fieldmouse: {parlett: "~0/5"},
    mouse: {parlett: "~0/6"},
    rat: {parlett: "~0/7"},
    // See also: ~1/1 is ferz; ~1/2 is knight
    camel: {parlett: "~1/3", letter: "W", image:["camel", "camel2", "camelrev2"], url:"pc:camel", hex:"U+1F42A"/*dromedary*/},  // TODO: Timur's game
    giraffe: {parlett: "~1/4", letter: "XG", url:"pc:giraffe"},
    blowfish: {parlett: "~1/5"},
    flamingo: {parlett: "~1/6", url:"pc:flamingo"},
    fish: {parlett: "~1/7", image:"fish"},
    alfil: {parlett: "~2/2", letter: "Y", image:["elephant2", "elephantrev2", "elephant"], url:"pc:alfil"},       //  or ~2X
    zebra: {parlett:"~2/3", letter: "Z", url:"pc:zebra"},
    lancer: {parlett: "~2/4",url:"http://www.ktn.freeuk.com/9a.htm#(2)", image:"lance2"}, 
    // TODO: ~2/5
    // TODO: ~2/6
    // TODO: ~2/7
    bird: {parlett: "~3/3", letter: "XT", image:["bird", "bird2"], aka:"tripper", hex:"U+1F426"},
    //antelope: {parlett: "~3/4", url:"pc:antelope"},    // TODO: image
    // TODO: ~3/5
    // TODO: ~3/6
    // TODO: ~3/7
    //commuter: {parlett: "~4/4", url:"http://www.ktn.freeuk.com/9a.htm#(2)"}, // TODO: image
    // TODO: ~4/5
    // TODO: ~4/6
    brontosaurus: {parlett: "~4/7"},
    // TODO: ~5/5
    // TODO: ~5/6
    // TODO: ~5/7
    // TODO: ~6/6
    // TODO: ~6/7
    // TODO: ~7/7

    // Amphibians (combined leapers)
    // "31 Basic Pieces" from http://chessvariants.wikidot.com/31-basic-pieces
    // dababa,knight,alfil,wazir,ferz
    //    1     2     3     4     5
    /*12345*/
    /*    5*/ // see ferz
    /*    4*/ // see wazir 
    /*   45*/ // see guard
    /*  3  */ // see alfil
    /*  3 5*/ //alfilferz:{parlett:"#alfil, #ferz", url:"http://chessvariants.wikidot.com/31-basic-pieces"},  // TODO: image
    /*  34 */ waffle: {parlett: "#wazir, #alfil", image:"elephantwazir", aka:"phoenix", url:"pc:waffle", aka:["WA"]},
    /*  345*/ //guardalfil:{parlett: "#man, #alfil", url:"http://chessvariants.wikidot.com/31-basic-pieces"},  // TODO: image
    /* 2   */ // see knight
    /* 2  5*/ prince: {parlett: "~1/1, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:["prince", "knightferz"]},
    /* 2 4 */ knightwazir: {parlett: "#knight, #wazir", url:"http://chessvariants.wikidot.com/31-basic-pieces"},
    /* 2 45*/ centaur: {parlett: "#knight, #man", aka:"crownedknight", url:"pc:centaur"},         // not royal, so not an equesrex  (also, ~0/1, ~1/1, ~1/2. K+N)
    /* 23  */ kangaroo: {parlett: "#knight, #alfil", aka:["newton", "knightalfil"], url:"pc:cangaroo"},  // Newton kangaroo, different than pc:kangaroo
    /* 23 5*/ highpriestness: {parlett: "#knight, #alfil, #ferz", image:["highpriestess2", "highpriestess"], url:"http://chessvariants.wikidot.com/31-basic-pieces"},
    /* 234 */ //alfilknightwazir: {"#alfil, #knight, #wazir", url:"http://chessvariants.wikidot.com/31-basic-pieces"}, // TODO: image
    /* 2345*/ //crownedknightalfil: {"#alfil, #knight, #man"}, // TODO: image
    /*1    */ // see dababba
    /*1   5*/ //ferzwarmachine: {"#ferz, #warmachine"}, // TODO: image
    /*1  4 */ woodyrook: {parlett: "#warmachine, #wazir", image:"warmachinewazir", url:"http://www.chessvariants.com/d.betza/chessvar/dan/rookies.html", aka:["WD"]},
    /*1  45*/ //guardwarmachine: {"#man, #warmachine"}, // TODO: image
    /*1   5*/ alibaba: {parlett: "~2*", letter: "L", image:"elephantwarmachine", url:"pc:alibaba", aka:"deacon"},   // or: #alfil, #warmachine = ~0/2, ~2/2
    /*1 3 5*/ //alibabaferz: {parlett: "#alibaba, #ferz", url:"http://chessvariants.wikidot.com/31-basic-pieces"}, // TODO: image
    /*1 34 */ //alibabawazir: {parlett: "#alibaba, #wazir", url:"http://chessvariants.wikidot.com/31-basic-pieces"}, // TODO: image
    /*1 345*/ jumpinggeneral: {parlett: "#warmachine, #alfil, #man", url:"http://chessvariants.wikidot.com/31-basic-pieces", image:["jumpinggeneral2", "jumpinggeneral"]}, // this is a leaper, versus "mastodon" which is a rider
    /*12   */ carpenter: {parlett: "#knight, #warmachine", image:["knightwarmachine2", "knightwarmachine"], aka:"knightwarmachine", url:"pc:carpentr"},
    /*12  5*/ knightwarmachineferz: {parlett: "#knight, #warmachine, #ferz", image:"knightdababaferz"},
    /*12 4 */ minister: {parlett: "#knight, #warmachine, #wazir", image:["minister", "knightwarmachinewazir2", "knightwarmachinewazir", "knightwazirwarmachine"], url:"http://chessvariants.wikidot.com/31-basic-pieces"}, // http://chessvariants.wikidot.com/31-basic-pieces calls "minister", but conflicts with http://chessvariants.wikidot.com/pcp-am:minister
    /*12 45*/ //ministerferz: {parlett: "TODO"}, // TODO: image and movement
    /*123  */ squirrel: {parlett: "~0/2, ~1/2, ~2/2", aka:["centurion", "castle"], letter: "S", url:"pc:squirrel"},
    /*123 5*/ //squirrelferz: {parlett: "#squirrel, #ferz", url:"http://chessvariants.wikidot.com/31-basic-pieces"}, // TODO: image
    /*1234 */ //squirrelwazir: {parlett: "#squirrel, #wazir", url:"http://chessvariants.wikidot.com/31-basic-pieces"}, // TODO: image
    /*12345*/ squire: {parlett: "#man, #squirrel"},       // haha.. man + squirrel. Actually defined as 2 squares, any direction. http://chessvariants.wikidot.com/31-basic-pieces calls this a "lion" but that piece is too overloaded

    dolphin: {parlett: "~7/7, ~0/7, ~0/6, ~6/6"},
    bat: {parlett: "~1/8, ~7/4", url:"http://www.quadibloc.com/chess/ch0201.htm"},
    frog: {parlett: "~1/1, ~0/3", letter: "F", hex:"U+1F438"},     
    duke: {parlett: "~0/2, ~1/1", url:"akm"},      // #ferz, #warmachine
    bison: {parlett: "~1/3, ~2/3", url:"pc:bison"},
    gnu: {parlett: "~1/2, ~1/3", image:"knightcamel", url:"pc:gnus", aka:["wildebeest"]},
    rootfiftyleaper: {parlett: "~5/5, ~7/1", url:"pc:root50"},
    fiveleaper: {parlett: "~0/5, ~3/4", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"butterfly"},
    // TODO: root-65 leaper, bat, see http://members.shaw.ca/quadibloc/chess/ch03.htm
    buffalo: {parlett: "~1/2, ~1/3, ~2/3", url:"pc:buffalo", hex:"U+1F403"},
    //wazaba: {parlett: "~0/1, ~0/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    diamond: {parlett: "~1/1, ~0/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"square45"},
    emperor: {parlett: "~0/1, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"knightwazir"}, 
    templar: {parlett: "~0/2, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:["templar2", "templar"]},
    //ferfil: {parlett: "~1/1, ~2/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    man: {parlett: "1*", letter: "M", image:["mann2", "man", "guard", "wazirferz"], url:"pc:man", hex:"U+1F468"},    // same as king, but not royale (also known as commoner, guard), or: ~0/1, ~1/1
    // http://www.ktn.freeuk.com/9a.htm#(3) says caliph is ~0/1, ~2/2 (wazir + alfil), but Piececlopedia says it is camel+bishop
    hospitaler: {parlett: "~1/2, ~2/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"},
    // http://www.ktn.freeuk.com/9a.htm#(3) says caliph is ~0/1, ~2/2 (wazir + alfil)
    //pterodactyl: {parlett: "~3/3, ~5/5, ~0/15", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    halfduck: {parlett: "~1/1, ~0/2, ~0/3", url:"http://www.chessvariants.com/d.betza/chessvar/dan/rookies.html", image:["greatwarmachinewazir"]}, 

    // Royal pieces
    royalknight: {parlett: "#knight", letter: "XR", royal: true, image:["bigknightking", "royalknight"]},
    royalpawn: {parlett: "#pawn", royal: true},
    royalrook: {parlett: "#rook", royal: true},
    royalbishop: {parlett: "#bishop", royal: true},
    royalqueen: {parlett: "#queen", royal: true},
    maharajah: {parlett: "#amazon", letter: "XJ", royal: true, image:"paladin", url:"http://www.chessvariants.org/unequal.dir/maharaja.html"},   // Q+N+K, Maharajah chess TODO: crown amazon?
    supermaharajah: {parlett: "#amazon, #camel", royal: true, image:"supermaharajaschah"},
    kingpawn: {parlett: "#king, #pawn", royal: true},
    kingrook: {parlett: "#king, #rook", royal: true},
    kingknight: {parlett: "#king, #knight", royal:true, image:"kingknight2"},

    // Generals from http://www.mayhematics.com/v/gm.htm
    // and some names from http://filer.case.edu/org/cwrums/games/chu-pieces.html#hiroku
    //   2 1 2   1X>  1>  1X>
    //   3 * 3    1=      1=
    //   4 5 4   1X<  1<  1X<
    /*1*/ soldier: {parlett: "1>", url:"http://en.wikipedia.org/wiki/Shogi", image:"shogipawn", aka:["shogipawn", "fu"]/*, promotion_rank:9*/, tags:"generals "}, // TODO: optional promotion
    chinesepawn: {image:["circle#兵"], parlett: "1>", url:"pc:pawn-xiangqi", aka:["chinesepawn", "fu"], 
	// 1>, but when crosses "river", promotes and can move 1=
	promote:["advancedsoldier"], promotion_rank:6, tags:"generals ", wxf_letter:"P", cn_letter:["兵", "卒"]}, 
    /*2*/ goose: {parlett: "o1X>", url:"akm", image:"goose", tags:"generals "},
    swan: {parlett: "1X>", image:"ferzf", tags:"generals "},
    /*3*/ drunk: {parlett: "1=", url:"akm", image:["drunk", "pawn90cw", "pawn90ccw"], tags:"generals "},
    /*4*/ sailor: {parlett: "1X<", image:["ship", "ferzb"], url:"akm", tags:"generals "}, 
    /*5*/ backslider: {parlett: "1<", url:"akm", tags:"generals "}, 
    /*12*/ plasticgeneral: {parlett: "1>, 1X>", aka:"notcoppergeneral", url:"akm", tags:"generals "},     // akm says coppergeneral can't move backwards, but shogi disagrees, so I call it plasticgeneral
    /*13*/ advancedsoldier: {parlett: "1>, 1=", url:"akm", aka:["drunkensoldier", "rivercrossedpawn"], wxf_letter:"P", cn_letter:["兵", "卒"], tags:"generals "},  // for Xiangqi after passing the river
    /*14*/ marine: {parlett: "1X<, 1>", url:"akm", aka:"wazirferzhunter", tags:"generals "}, 
    /*15*/ adjutant: {parlett: "1>, 1<", url:"akm", aka:["tsiu-yin", "chuuuin", "gobetween", "doublefootsoldier"], image:"general3", tags:"generals "}, 
    /*23*/ sidewinder: {parlett: "1X>, 1=", url:"akm", tags:"generals "}, 
    /*24*/ ferz: {parlett: "1X", letter: "XF", image:["ferz", "ferz2", "1bishop", "1bishop2"], url:"pc:ferz", aka:["adviser", "firzin"], tags:"generals ", wxf_letter:"A", cn_letter:"士"}, // or ~1/1
    /*25*/ //ferzwazirhunter: {parlett: "1<, 1X>", url:"akm", tags:"generals "}, // TODO: image
    /*34*/ drunkensailor: {parlett: "1=, 1X<", image:"shipinv", url:"akm", tags:"generals "}, 
    /*35*/ drunkenbackslider: {parlett: "1=, 1<", url:"akm", aka:["reversesoldier"], tags:"generals ", image:["drunkbackslider2", "drunkbackslider"]},
    /*45*/ deserter: {parlett: "1<, 1X<", aka:"backwardpawn", url:"akm", image:"pawninv", tags:"generals "}, 
    /*123*/ pikeman: {parlett: "1>, 1X>, 1=", url:"akm", aka:"drunkenpawn", image:"ganypikeman", tags:"generals "}, 
    /*124*/ silvergeneral: {parlett: "1>, 1X", url:"pc:silvergeneral",aka:["gin-sho", "khohn"], tags:"generals "},
    /*125*/ //yale: {parlett: "1>, 1X>, 1<"}, // TODO: image
    /*134*/ drunkenmarine: {parlett: "1>, 1=, 1X<", tags:"generals "},
    /*135*/ wazir: {parlett: "1+", letter: "I", aka:"drunkenadjuant", url:"pc:wazir", image:["wazir", "1rook2"], tags:"generals "},    // or ~0/1
    /*145*/ //gorilla: {parlett: "1=, 1X<, 1<", aka:"guerilla", url:"akm", tags:"generals "}, // TODO: image
    /*234*/ diabolo: {parlett: "1X, 1=", url:"akm", aka:"drunkenferz", tags:"generals ", image:"daemon"},
    /*235*/ coppergeneral: {parlett: "1X>, 1=, 1<", image:["coppergeneral", "yen"], aka:["yen", "dou-sho", "drunkenyale"], url:"http://filer.case.edu/org/cwrums/games/chu-pieces.html#dou", tags:"generals "},
    /*245*/ invertedsilver: {parlett: "1X+, 1<", aka:"backwardelephant", url:"akm", image:"backwardssilvergeneral", tags:"generals "},
    /*345*/ //drunkendeserter: {parlett: "1=, 1X<, 1<", url:"akm", tags:"generals "}, // TODO: image
    /*1234*/ drunkenelephant: {parlett: "1X, 1>, 1=", url:"akm", aka:"siu-zo", image:["drunkelephant", "drunkelephant2"], aka:["suizo"], tags:"generals "},
    /*1235*/ goldgeneral: {parlett: "1+, 1X>, 1=, 1<", url:"pc:goldgeneral", aka:["kin-sho", "tokin", "goldengeneral"], tags:"generals "},  // or: #wazir, [1,1], [-1,1]
    /*1245*/ ferociousleopard: {parlett: "1+, 1>, 1<", url:"akm", aka:["crane", "horriblepanther", "mau-hau", "mohyou"], image:"mohyo_ferociousleopard", tags:"generals "}, // TODO: image
    /*1345*/ //drunkengorilla: {parlett: "1>, 1X<, 1=, 1<", url:"akm", tags:"generals "}, // TODO: image
    /*2345*/ blindtiger: {parlett: "1X, 1=, 1<", url:"akm", image:["blindtiger2", "blindtiger", "moko_blindtiger"], aka:["reversegold", "mouko"], tags:"generals "}, 
    /*12345*/ lord: {parlett: "1*", royal: true, url:"http://en.wikipedia.org/wiki/Shatranj#Rules", aka:["shah", "khun", "o-sho", "jeweledgeneral"], tags:"diminished "},  // like a king, but no castling 

    // Asymmetric generals
    rightpawn: {parlett: "[1,0]", image:"pawn45cw", tags:"asymmetric "},
    leftpawn: {parlett: "[-1,0]", image:"pawn45ccw", tags:"asymmetric "},

    "2moveferz": {parlett: "2X, 2+"},       // one move like a ferz, then another from that square
    "2movewazir": {parlett: "2+, 1*"},      // ..
    "2movewazirferz": {parlett: "#2moveferz, #2movewazir"},
    //"oliphant": {parlett: "TODO", url:"http://chessvariants.wikidot.com/pcp-ao:oliphant"},

    // Diminished pieces
    b3: {parlett: "nX.3", tags:"diminished "},
    b4: {parlett: "nX.4", image:["b4", "halfbishop"], tags:"diminished "},
    b4wazir: {parlett: "#b4, #wazir", tags:"diminished "},
    b4nd: {parlett: "#b4, #elephant", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/b4nd.html", tags:"diminished "},
    bw3: {parlett: "#b3, #wazir", tags:"diminished "},
    r2: {parlett: "n+.2", image:"1rook", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/shortrook.html", tags:"diminished "},
    r3: {parlett: "n+.3", tags:"diminished "},
    r4: {parlett: "n+.4", castle: true, image:["r4", "halfrook"], tags:"diminished "},
    r5: {parlett: "n+.5", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/shortrook.html", tags:"diminished "},
    r6: {parlett: "n+.6", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/shortrook.html", tags:"diminished "},
    fourfer: {parlett: "#r4, 1X", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/fr4.html", tags:"diminished "},
    narrowknight: {parlett: "[1,2], [1,-2], [-1,2], [-1,-2]", tags:"diminished "},
    wideknight: {parlett: "[2,1], [2,-1], [-2,1], [-2,-1]", tags:"diminished "},
    // Like knight, but can be blocked on orthogonal. 
    // Can almost do with this with n+.2\\45\\ or 1X(1+), but not quite (extra moves in intervening squares).
    // Would be really nice if could offset moves, blockable, in that way, though.
    horse: {parlett: "[1,2;if_unblocked=0,1], [-1,2;if_unblocked=0,1], " +
        "[2,1;if_unblocked=1,0], [2,-1;if_unblocked=1,0], " +
        "[1,-2;if_unblocked=0,-1], [-1,-2;if_unblocked=0,-1], " +
        "[-2,1;if_unblocked=-1,0], [-2,-1;if_unblocked=-1,0]",
        image:["horse", "mao"], url:"pc:mao", letter:"H", aka:["ma", "mare"], tags:"diminished ", cn_letter:"馬"},
    moa: {parlett: "[1,2;if_unblocked=1,1], [2,1;if_unblocked=1,1], " +
        "[2,-1;if_unblocked=1,-1], [1,-2;if_unblocked=1,-1], " +
        "[-1,-2;if_unblocked=-1,-1], [-2,-1;if_unblocked=-1,-1], " +
        "[-2,1;if_unblocked=-1,1], [-1,2;if_unblocked=-1,1]", tags:"diminished "
    },
    moo: {parlett: "#horse, #moa", url:"http://chessvariants.wikidot.com/pcp-am:moo", tags:"diminished "}, 

    r4ferz: {parlett: "#r4, #ferz", tags:"diminished ", },
    n2r4: {parlett: "#r4, 2(~1/2)", tags:"diminished "},
    rookish: {parlett: "#alfil, #r4", tags:"diminished ", image:["alfilr4", "onediamondrook"], url:"http://chessvariants.wikidot.com/8x8-variants"},
    mastodon: {parlett: "n*.2", url:"http://www.quadibloc.com/chess/ch0502.htm", tags:"diminished "},
    q3: {parlett: "n*.3", tags:"diminished "},
    q4: {parlett: "n*.4", image:["q4", "halfqueen"], tags:"diminished "},

    // Compound pieces (combined pieces)
    // TODO: aanca http://chessvariants.wikidot.com/pcp-aa:aanca
    // From piececlopedia http://www.chessvariants.org/index/mainquery.php?type=Piececlopedia&orderby=LinkText&displayauthor=1&displayinventor=1&usethisheading=Piececlopedia
    // or http://members.shaw.ca/quadibloc/chess/ch03.htm or 
    // http://www.chessvariants.com/graphics.dir/alfaerie/
    equesrex: {parlett: "#king, #knight", image:"equesrex", royal: true},
    amazon: {parlett: "#queen, #knight", letter: "XV", url:"pc:amazon", image:["amazon", "queenknight2"], aka:["superqueen", "queenknight", "knightedqueen"]},
    amazonrider: {parlett: "#queen, #nightrider", aka:["queenofthenight"]},
    banshee: {parlett: "#bishop, #nightrider", url:"akm"},
    chancellor: {parlett: "#rook, #knight", letter: "C", image:["chancellor", "chancellor1", "empress2", "marshal2", "rookknight2"], url:"pc:rook-knight", aka:["empress", "marshal", "NR"]},   // R+N
    chancellorrider: {parlett: "#rook, #nightrider", aka:["raven"]},
    chancellorwazir: {parlett: "#chancellor, #wazir"},
    archbishop: {parlett: "#bishop, #knight", letter: "A", image: ["cardinal", "cardinal1", "cardinal2", "princess", "bishopknight2"], url:"pc:bishop-knight", aka:["cardinal", "princess", "janus", "NB"], hex:"U+1F478"}, // B+N
    archbishoprider: {parlett: "#archbishop, #nightrider", image:"cardinalrider"},
    cardinalferz: {parlett: "#archbishop, #ferz"},
    dragonhorse: {parlett: "#bishop, #wazir", image: "promotedbishop", url:"pc:dragonhorse"},
    //berse: {parlett: "#rook, #ferz", image: "promtoedrook", aka:["dragonking"]},    // TODO: image
    caliph: {parlett: "#camel, #bishop", image: "camelbishop", url:"pc:caliph"},
    pope: {parlett: "#king, #bishop", image:"kingbishop"},  // http://www.chessvariants.com/difftaking.dir/thunder.html 
    dragonking: {parlett: "#king, #rook", royal: true, url:"pc:dragonking", image:"turtle"},
    alfilbishop: {parlett: "#alfil, #bishop"},
    bishoppawn: {parlett: "#bishop, #pawn"},
    crookedbishopwazir: {parlett: "#crookedbishop, #wazir"},
    duchess: {parlett: "#bishop, #warmachinerider", image:["duchess", "bishopwarmachinerider"], url:"akm"},
    elephantwarmachine: {parlett: "#elephant, #warmachine"},
    elephantwarmachinewazir: {parlett: "#elephant, #warmachine, #wazir"},
    elephantwarmachinewizard: {parlett: "#elephant, #warmachine, #wizard", image:"elephantwarmachinezzmoon"},
    dayrider: {parlett: "#alfilrider, #warmachinerider", image:"elephantwarmachinerider", aka:["alibabarider", "skipqueen"]},
    duck: {parlett: "#ferz, #warmachinerider"}, 
    rookpawn: {parlett: "#rook, #pawn"},
    knightwizard: {parlett: "#knight, #wizard", image:"horsezzmoon"},
    horsewazir: {parlett: "#honorablehorse, #wazir"},  
    guardknight: {parlett: "#knight, #man", image:["guardknight2", "guardknight"], hex:"U+1F482"}, 
    elephantwazir: {parlett: "#elephant, #wazir"},
    elephantferzwarmachine: {parlett: "#elephant, #ferz, #warmachine"},
    camelferz: {parlett: "#camel, #ferz", image:["camelferz", "camel2ferz"]},
    camelqueen: {parlett: "#camel, #queen"},
    camelwarmachine: {parlett: "#camel, #warmachine"},
    camelwazir: {parlett: "#camel, #wazir", image:["camelwazir", "camel2wazir"]},
    camelbishoprider: {parlett: "#camelrider, #bishop"},
    starrider: {parlett: "#camelrider, #knight, #antelope", url:"akm", image:"knightzzstar"}, 
    camelpawn: {parlett: "#camel, #pawn"},
    camelwarmachinerider: {parlett: "#camel, #warmachinerider"},
    camelopard: {parlett: "#camelrider, #fiveleaper", url:"akm"}, // TODO: is this supposed to be "cameleopard"?
    crabalfil: {parlett: "#crab, #alfil"},
    crabwarmachine: {parlett: "#crab, #warmachine", image:"crabdabbaba"},
    crabferz: {parlett: "#crab, #ferz"},
    crabwazir: {parlett: "#crab, #wazir"},
    crabshortrook: {parlett: "#crab, #r4"},
    elephantcamel: {parlett: "#elephant, #camel", hex:"U+1F42B"/*bactrian*/},
    elephantcamelrider: {parlett: "#elephant, #camelrider"},
    elephantferz: {parlett: "#elephant, #ferz", image:["elephantferz", "elephant2ferz"]},
    elephantferzrook: {parlett: "#elephant, #ferz, #rook"},
    elephantknight: {parlett: "#elephant, #knight"},
    elephantknightrider: {parlett: "#elephant, #nightrider"},
    elephantknightwazir: {parlett: "#elephant, #knight, #wazir"},
    elephantwizard: {parlett: "#elephant, #wizard", image:"elephantzzmoon"},
    //fibnifrook: {parlett: "#fibnif, #rook"}, // TODO: image
    genscher: {parlett: "#panda, #knight"},
    giraffeferz: {parlett: "#giraffe, #ferz"},
    giraffewazir: {parlett: "#giraffe, #wazir"},
    knightcamelzebra: {parlett: "#knight, #camel, #zebra"},
    //lynx: {parlett: "#rook, #knight, #zebra", pc:"akm"},  // TODO: image
    rookwarmachine: {parlett: "#rook, #warmachine", image:"rookdabbaba"},
    rookelephantrider: {parlett: "#rook, #alfilrider"},
    narrowknightferz: {parlett: "#narrowknight, #ferz"},
    narrowknightwazir: {parlett: "#narrowknight, #wazir"},
    //rhinocamel: {parlett: "#rhino, #camel"},
    //rhinocamelrider: {parlett: "#rhino, #camelrider"},
    //rhinozebra: {parlett: "#rhino, #zebra"},
    //rhinozebrarider: {parlett: "#rhino, #zebrarider"},
    scorpion: {parlett: "#man, #grasshopper"}, 
    scorpionpawn: {parlett: "#scorpion, #pawn"},
    queenalfilwarmachine: {parlett: "#queen, #alfil, #warmachine", image:"queenalfildabbaba3"},
    // TODO: herowarmachinewazir, lemurianwarmachinewazir, flexibleknight, linearchieftainjumpinggeneral, from http://chessvariants.wikidot.com/joe-s-strange-notation
    wazirwarmachinealfil: {parlett: "#wazir, #warmachine, #alfil", image:"wazirdababaalfil"},
    warmachineriderwazir: {parlett: "#warmachinerider, #wazir"},
    warmachineferz: {parlett: "#warmachine, #ferz"},
    warmachineferzrider: {parlett: "#warmachinerider, #ferz"},
    warmachineriderferz: {parlett: "#warmachinerider, #ferz", image:"dababbahriderferz", aka:["dabbabahriderferz"]},
    warmachineriderwazir: {parlett: "#warmachinerider, #wazir", image:"dababbahriderwazir2", aka:["dababbahriderwazir"]},
    warmachinewizard: {parlett: "#warmachine, #wizard", image:"warmachinezzmoon"},
    wizardrider: {parlett: "#camelrider, #ferz", image:"moonrider"},
    witch: {parlett: "#rook, #bishop, #nightrider, #camelrider, #zebrarider"},
    zebracamel: {parlett: "#zebra, #camel"},
    zebracamelrider: {parlett: "#zebra, #camelrider"},
    zebraferz: {parlett: "#zebra, #ferz"},
    zebrawazir: {parlett: "#zebra, #wazir"},
    zebrawizard: {parlett: "#zebra, #wizard", image:"zebrazzmoon"},

    // Snipers (move like one piece, capture like another), from http://www.mayhematics.com/v/gm.htm
    roobis: {parlett: "o#rook, c#bishop", image:"frookbbishop", castle:true, url:"akm"},
    ensign: {parlett: "o#bishop, c#rook", image:"fbishopbrook", url:"akm", aka:["bishroo"]},
    rookni: {parlett: "o#rook, c#knight", image:"frookbknight", castle:true, url:"akm"},
    kniroo: {parlett: "o#knight, c#rook", image:"fknightbrook", url:"akm"},
    bishkni: {parlett: "o#bishop, c#knight", image:"fbishopbnight", url:"akm"},
    knibis: {parlett: "o#knight, c#bishop", image:"fknightbbishop", url:"akm"},
    // .. logical extensions
    kinkni: {parlett: "o#king, c#knight", image:"fkingbknight", royal:true, castles_with:"rook"},
    knikin: {parlett: "o#knight, c#king", image:"fknightbking", royal:true},
    knique: {parlett: "o#knight, c#queen", image:"fknightbqueen"},
    quekni: {parlett: "o#queen, c#knight", image: "fqueenbknight"},

    tiger: {parlett: "o#bishop, c#knight", hex:"U+1F405"},
    bede: {parlett: "#warmachine, #bishop", image:"bishopwarmachine", url:"pc:bd"},
    canvasser: {parlett: "#camel, #rook", image:"camelrook", url:"pc:canvassr"}, // yes, url is canvassr (no e)
    champion: {parlett: "#wazir, #alfil, #warmachine", url:"pc:champion"},
    crownedrook: {parlett: "#rook, #ferz"},
    crownedcamel: {parlett: "#camel, #ferz"},
    camelking: {parlett: "#camel, #king", image:["simplecamelking", "cbjcamelking", "tinyscamelking"]},
    // TODO: telepotency - can attack opposing general on same open file. Like a capture but only for specific piece. New need syntax, maybe c(king)n+?
    general: {parlett: "#wazir", royal: true, url:"pc:general", image:["general2", "general"], aka:["chineseking"], wxf_letter:"K", cn_letter:["帥", "將"]}, 
    // http://www.mayhematics.com/v/gm.htm has a different definition of wizard
    wizard: {parlett: "#camel, #ferz", image:"moon",  url:"pc:wizard", hex: "U+1F319"},
    fad: {parlett: "#ferz, #alfil, #warmachine", image:["elephantferzwarmachine"], url:"pc:fad"},
    bede: {parlett: "#bishop, #warmachine", image:"bishopwarmachine"},
    //zurafa: {parlett: "i#giraffe, #rook"}, // TODO: image, and no rook move on initial

    // More complex fairy / non-intl chess pieces
    // See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
    // and even better, Piecelopedia 
    // http://chessvariants.wikidot.com/pcp:piececlopedia
 
    hornedfalcon: {parlett: "n=x, 2>", image:"kakuo_hornedfalcon"},    // from Parlett, TODO: fix invalid direction
    
    // Despite appearances, this is not ~1/2>, since that would allow also
    // allow the forward moves [2,-1] and [-2,1].
    honorablehorse: {parlett: "[-1,2], [1,2]", image:"shogiknight", url:"pc:shogiknight", aka:["kei", "keima"], hex:"U+1F40E"},

    //chineseknight: {parlett: "1//2"}, // TODO: intervening must be unblocked
    lance: {parlett: "n>", url:"pc:lance", image:["lance", "lance1"], aka:["kyosha", "yari", "fragrantchariot"]},     // TODO: promote to hakku from http://filer.case.edu/org/cwrums/games/chu-pieces.html
    //reversechariot: {parlett: "n>, n<", url:"http://filer.case.edu/org/cwrums/games/chu-pieces.html#hansha", aka:["hansha"]}, // TODO: image

    //murray_lion: {parlett: "~0/2, ~2/2, c1*", letter: "XM"}, // TODO: image
    lion: {parlett: "~n*", letter: "XL", url:"pc:lion"},
    elephant: {parlett: "2X", letter: "E", image:["elephantmodern", "elephant1"], url:"pc:elephant", aka:["minister"], hex:"U+1F418", wxf_letter:"E", cn_letter:["相","象"]}, // Not a leaper, path can be blocked (unlike alfil, ~2X)

    // TODO: support ~0/0 for "null move" (---), but don't let drop to null, instead show a button
    //kraken: {parlett: "~n/m ~0/0"},     // any square, not realistic since always checkmates! TODO: image
    //octopus: {parlett: "o~n/m ~0/0", letter: "XD", hex:"U+1F419"}, // any square (8x8, octo, get it?) but can't capture, much less powerful TODO: image
    universal_leaper: {parlett: "~n/m", image:"ubiubi"},// like kraken, but can't go to square it is on (like a zero) TODO: image
    allseeingeye: {parlett: "o~n/m", image:["allseeingeye2", "allseeingeye"]},       // anywhere

    // Riders
    nightrider: {parlett: "~1/2&", letter:"XN", image:["nightrider", "knightinv"], aka:"knightrider", url:"pc:knightrider"},  // Wikipedia says n(1/2), but Parlett says ~1/2&
    alfilrider: {parlett: "~2/2&", image:"elephantrider", aka:["skipbishop"]},
    //elephantrider: {parlett: "n(2X)", image:"elephantridermodern"}, // TODO: gets blocked
    warmachinerider: {parlett: "~2/0&", image:["warmachinerider","dababbarider"], aka:["skiprook", "dabbabarider"]}, 
    squirrelrider: {parlett: "n(#squirrel)"},
    crabrider: {parlett: "n(#crab)"},
    barcrider: {parlett: "n(#barc)"},
    // TODO: slip-rook (panda), slip-bishop, slip-queen: omits second and every other even cell in path
    camelrider: {parlett: "~1/3&"},
    alibabariderferz: {parlett: "~2/0&, ~2/2&"},
    girafferider: {parlett: "~1/4&"},
    zebrarider: {parlett: "~2/3&"},

    // Projectiles
    airplane: {parlett: "#allseeingeye, {cn+<;snapback}", letter: "U", image:"plane"},  // drops bombs
    gun: {parlett: "o#man, {c#queen;snapback}"},            // able to walk around, powerful distance projectiles
    rocket: {parlett: "o<<1, o>>1, {~cn+>;snapback}"},    // shoots straight, not very mobile
    // Note: not the patented archer at http://www.google.com/patents?id=MLEWAAAAEBAJ&dq=5901957
    archer: {parlett: "o#bishop, {c#knight;snapback}"},     // quite mobile, but can't shoot very far
    archerzz2: {parlett: "o#rook, {c#knight;snapback}"},
    archerzz3: {parlett: "o#bishop, {c#squirrel;snapback}"},

    // Invincibles
    block: {parlett: "", invincible: true},
    // Stone is an invincible warmachinerider
    stone: {parlett: "~2/0&",
                    // Explicit notation, before had rider syntax
                    /*"[0,2], [0,4;if_unblocked=0,2], [0,6;if_unblocked=0,4], " +
                     "[2,0], [4,0;if_unblocked=2,0], [6,0;if_unblocked=4,0], " +
                     "[-2,0], [-4,0;if_unblocked=-2,0], [-6,0;if_unblocked=-4,0], " +
                     "[0,-2], [0,-4;if_unblocked=0,-2], [0,-6;if_unblocked=0,-4]",*/
                     invincible: true},
    fort: {parlett: "o#man", invincible: true},
    fortress: {parlett: "o#bishop", invincible: true},
    nwall: {parlett: "o1>, o1=", invincible: true},

    // Kamikaze pieces - disappear when making a capture 
    bomb: {parlett: "o1*, {c1*;self_destruct}", image:"medusa", invincible:true, hex:"U+1F4A3"},
    superbomb: {parlett: "on*, {c~n*;self_destruct}", image:"gorgona"},

    // Pieces from chess-3
    // http://www.chessbase.com/newsdetail.asp?newsid=4553
    
    // rook + can move (not capture) like bishop
    tower: {parlett: "#rook, o#bishop", castle: true, letter: "T", image: "redrook"},  

    // knight + can move (not capture!) like wazir
    jous: {parlett: "#knight, o#wazir", letter: "J", image: "orangeknight"}, 

    // bishop + can move (not capture) 1 or 2 squares orthogonally
    vicar: {parlett: "#bishop, o2+", letter: "V", image: "yellowbishop"},

    // Ralph Betza's crazy pieces
    chargingrook: {parlett: "n+>=, 1<, 1X<", image:"frookbprince", url:"http://www.chessvariants.com/unequal.dir/cwda.html", castle:true},
    fibnif: {parlett: "#ferz, [1,2], [-1,2], [1,-2], [-1,-2]", url:"pc:fibnif", image:"narrowknightferz"},
    chargingknight: {parlett: "~1/2>, 1<, 1=", image:"fknightbprince", url:"http://www.chessvariants.com/unequal.dir/cwda.html"},
    colonel: {parlett: "n>, n=, ~1/2>, 1*", letter: "XC", url:"http://www.chessvariants.com/unequal.dir/cwda.html", image:"forwardchancellorprince"},
    furlrurlbakking: {parlett: "n=, n>, 1<, 1<X", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/frlrrlbk.html"}, 
    forfnibakking: {parlett: "~1/2>, 1<, 1<X", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/fhnrlbk.html"}, 
    //forfnifurlrurking: {parlett: "~1/2>, n=, n>, 1*", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/fhnfrlrk.html"}, // TODO: image
 
    // Hoppers

    // http://www.mayhematics.com/v/gm.htm
    // Hoppers vary in how far the hurdle can be from the source and destination
    // Jumping left to right, / is the piece start, = is the hurdle, ... is any number of squares, \ is where it lands:
    //
    //  ---->
    //  _____
    // /  =  \
    // 
    // /=\          step-hop
    // /...=\       fore-hop    ^
    // /=...\       contra-hop
    // /...=...\    line-hop    ^& (TODO)
   
    // Line-hoppers
    //rion: {parlett: "n+^&", aka:"rooklinehopper", pc:"akm"}, // TODO: movement
    //bion: {parlett: "nX^&", aka:["bishlion", "bishoplinehopper"], pc:"akm"},
    //lion: {parlett: "n*^&", aka:"queenlinehopper", pc:"akm"},  // TODO: reconcile with ~n* lion
    //nightriderhopper: {parlett: "(~1/2&)^&", pc:"akm"}, // TODO: movement notation?

    // Chinese hoppers: move as rider, capture as line-hopper
    cannon: {image:["circle#炮"], parlett: "on+, cn+^&", aka:["pao"], wxf_letter:"C", cn_letter:"炮"}, // TODO: movement. Like rook, but capture move requires a "screen" to hop over immediately in front; line-hopper
    //vao: {parlett: "onX, cnX^&"}, // like bishop
    //leo: {letter: "XO", parlett: "on*, cn*^&", url:"http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples"}, 
    
    // Fore-hoppers
    grasshopper: {parlett: "n*^", aka:"queenhopper", url:"http://en.wikipedia.org/wiki/Grasshopper_(chess)"}, // TODO: movement
    rookhopper: {parlett: "n+^", pc:"akm"},
    bishopper: {parlett: "nX^", pc:"akm"}, // TODO: image
    //kangaroo: {parlett: "n*^^", pc:"akm"}, // TODO: movement, hops over *two* hurdles

    // TODO: locust movement (captures hurdle), cn*^&?? cn*^^?. 
    //checker: {parlett: "cn(^2X)>, o1X>", url:"http://en.wikipedia.org/wiki/Fairy_chess_piece#Notations"}, // TODO: movement; difficult because it must hop to the end

    // Bifurcating pieces, have a path that forks
    //moose: {parlett: "n*\\45^"}, // TODO: movement, like grasshopper but turns 45 degrees over hurdle 
    //eagle: {parlett: "n*\\90^", pc:"akm"}, // TODO: movement, like grasshopper but lands to left or right of hurdle 
    //sparrow: {parlett: "n*\\135^", pc:"akm"}, // TODO: movement, like grasshopper but turns 135 degrees over hurdle
    //jibber: {parlett: "n*\\180^", pc:"akm"}, // TODO: movement, like grasshopper but to cell in front of hurdle


    // Taikyoku Shogi pieces http://en.wikipedia.org/wiki/Taikyoku_shogi
    // TODO: wedge piece instead of circle
    // TODO: "The [royal pieces] may move into check (not recommended)."
    // TODO: promote on capture
    //TAIK
    //king: {parlett: "n*.2", romanji: "gyokushō", image: "circle#玉将", letter: "K", royal: true, tags:"taikyoku "}, 
    fragrant_elephant: {parlett: "n*.2", romanji: "kōzō", promote: ["elephant_king"], image: "circle#香象", letter: "FG", tags:"taikyoku "},
    white_elephant: {parlett: "n*.2", romanji: "hakuzō", promote: ["elephant_king"], image: "circle#白象", letter: "WE", tags:"taikyoku "},
    crown_prince: {parlett: "1*", romanji: "taishi", promote: ["king"], image: "circle#太子", letter: "CP", royal: true, tags:"taikyoku "},
    left_general: {parlett: "1*", romanji: "sashō", promote: ["left_army"], image: "circle#左将", letter: "LG", tags:"taikyoku "},
    right_general: {parlett: "1*", romanji: "ushō", promote: ["right_army"], image: "circle#右将", letter: "RG", tags:"taikyoku "},
    //gold_general: {parlett: "1+, 1X>", romanji: "kinshō", promote: ["rook"], image: "circle#金将", letter: "G", tags:"taikyoku "}, // TODO: reconcile
    violent_wolf: {parlett: "1+, 1X>", romanji: "mōrō", promote: ["bears_eyes"], image: "circle#猛狼", letter: "NT", tags:"taikyoku "},
    rear_standard: {parlett: "1X, 2X, n+", romanji: "kōki", promote: ["center_standard"], image: "circle#後旗", letter: "RS", tags:"taikyoku "},
    free_king: {parlett: "n*", romanji: "honnō", promote: ["great_general"], image: "circle#奔王", letter: "FK", tags:"taikyoku "},
    free_dreameater: {parlett: "nX, n<, n>, n=.5", romanji: "honbaku", promote: ["free_king"], image: "circle#奔獏", letter: "FT", tags:"taikyoku "},
    //wooden_dove: {parlett: "n+.2, ~nX", romanji: "kyūhan", image: "circle#鳩槃", letter: "WO", tags:"taikyoku "}, // TODO: movement
    earth_dragon: {parlett: "1>, 1X<, n+.2, nX<", romanji: "chiryū", promote: ["rain_dragon"], image: "circle#地龍", letter: "ED", tags:"taikyoku "},
    free_demon: {parlett: "n<X.5, n+, n>>", romanji: "honki", promote: ["free_king"], image: "circle#奔鬼", letter: "FR", tags:"taikyoku "},
    //running_horse: {parlett: "1<, n+, n>X", romanji: "sōma, sōba", promote: ["free_demon"], image: "circle#走馬", letter: "HR", tags:"taikyoku "}, // TODO: jump nX<
    beast_cadet: {parlett: "n>.2, n=.2, nX.2", romanji: "jūsō", promote: ["beast_officer"], image: "circle#獣曹", letter: "BC", tags:"taikyoku "},
    //longnosed_goblin: {parlett: "", romanji: "tengu", image: "circle#天狗", letter: "LO", tags:"taikyoku "}, // TODO: hook move
    //mountain_eagle_left: {parlett: "n↙.2", romanji: "sanshū", promote: ["soaring_eagle"], image: "circle#山鷲", letter: "ME", tags:"taikyoku "},
    //mountain_eagle_right: {parlett: "n↘.2", romanji: "sanshū", promote: ["soaring_eagle"], image: "circle#山鷲", letter: "MR", tags:"taikyoku "},
    fire_demon: {parlett: "n>.2, n<.2, n=, nX", romanji: "kaki", promote: ["free_fire"], image: "circle#火鬼", letter: "DM", tags:"taikyoku "}, // Note: no burning
    //free_fire: {parlett: "", romanji: "honka", image: "circle#奔火", letter: "+DM", tags:"taikyoku "},
    whale: {parlett: "n<, n>, nX<", romanji: "keigei", promote: ["great_whale"], image: "circle#鯨鯢", letter: "W", tags:"taikyoku "},
    //great_whale: {parlett: "", romanji: "daigei", image: "circle#大鯨", letter: "+W", tags:"taikyoku "},
    running_rabbit: {parlett: "1+, 1<X, n+, n>X", romanji: "sōto", promote: ["treacherous_fox"], image: "circle#走兎", letter: "RR", tags:"taikyoku "},
    white_tiger: {parlett: "n=, n↖, n>.2, n<.2", romanji: "byakko", promote: ["divine_tiger"], image: "circle#白虎", letter: "WT", tags:"taikyoku "},
    //divine_tiger: {parlett: "", romanji: "shinko", image: "circle#神虎", letter: "+WT", tags:"taikyoku "},
    turtle_snake: {parlett: "n↗, n↙, 1*", romanji: "genbu", promote: ["divine_turtle"], image: "circle#玄武", letter: "TS", tags:"taikyoku "},
    ceramic_dove: {parlett: "n+.2, nX", romanji: "kyūban", image: "circle#鳩盤", letter: "CD", tags:"taikyoku "},
    //divine_turtle: {parlett: "", romanji: "shinki", image: "circle#神亀", letter: "+TS", tags:"taikyoku "},
    //lance: {parlett: "", romanji: "kyōsha", promote: ["white_horse"], image: "circle#香車", letter: "L", tags:"taikyoku "}, // TODO: reconcile
    oxcart: {parlett: "n>", romanji: "gissha", promote: ["plodding_ox"], image: "circle#牛車", letter: "OC", tags:"taikyoku "},
    savage_tiger: {parlett: "n>", romanji: "mōko", promote: ["great_tiger"], image: "circle#猛虎", letter: "TG", tags:"taikyoku "},
    reverse_chariot: {parlett: "n<, n>", romanji: "hensha", promote: ["whale"], image: "circle#反車", letter: "RV", tags:"taikyoku "},
    mountain_dove: {parlett: "1<, 1=, n>X.5", romanji: "sankyū", promote: ["great_dove"], image: "circle#山鳩", letter: "MD", tags:"taikyoku "},
    //elephant_king: {parlett: "", romanji: "zōō", image: "circle#象王", letter: "+FG", tags:"taikyoku "},
    flying_swallow: {parlett: "1<, n>X", romanji: "hien", promote: ["rook"], image: "circle#飛燕", letter: "FS", tags:"taikyoku "},
    captive_officer: {parlett: "n>.2, n=.2, nX.3", romanji: "kinri", promote: ["captive_bird"], image: "circle#禽吏", letter: "CO", tags:"taikyoku "},
    //captive_bird: {parlett: "", romanji: "kinchō", image: "circle#禽鳥", letter: "+CO", tags:"taikyoku "},
    rain_dragon: {parlett: "1+, 1↗, n<, n=, nX<", romanji: "uryū", promote: ["great_dragon"], image: "circle#雨龍", letter: "RA", tags:"taikyoku "},
    forest_demon: {parlett: "n>.3, n=.3, n<, n↗", romanji: "shinki", promote: ["thunder_runner"], image: "circle#森鬼", letter: "FO", tags:"taikyoku "},
    //thunder_runner: {parlett: "", romanji: "raisō", image: "circle#雷走", letter: "+FO", tags:"taikyoku "},
    mountain_stag: {parlett: "1>, n=.2, nX>.3, nX<.4", romanji: "sanroku", promote: ["great_stag"], image: "circle#山鹿", letter: "MS", tags:"taikyoku "},
    running_pup: {parlett: "1=, n<, n>", romanji: "sōku", promote: ["free_leopard"], image: "circle#走狗", letter: "RP", tags:"taikyoku "},
    running_serpent: {parlett: "#running_pup", romanji: "sōja", promote: ["free_serpent"], image: "circle#走蛇", letter: "RU", tags:"taikyoku "},
    //free_leopard: {parlett: "", romanji: "honpyō", image: "circle#奔豹", letter: "+RP", tags:"taikyoku "},
    //free_serpent: {parlett: "", romanji: "honja", image: "circle#奔蛇", letter: "+RU", tags:"taikyoku "},
    side_serpent: {parlett: "1<, n>.3, n=", romanji: "ōja", promote: ["great_shark"], image: "circle#横蛇", letter: "SS", tags:"taikyoku "},
    //great_shark: {parlett: "", romanji: "dairin", image: "circle#大鱗", letter: "+SS", tags:"taikyoku "},
    great_dove: {parlett: "n+.3, nX", romanji: "daikyū", promote: ["wooden_dove"], image: "circle#大鳩", letter: "GR", tags:"taikyoku "},
    running_tiger: {parlett: "n=.2, n<, n>", romanji: "sōko", promote: ["free_tiger"], image: "circle#走虎", letter: "RT", tags:"taikyoku "},
    running_bear: {parlett: "#running_tiger", romanji: "sōyū", promote: ["free_bear"], image: "circle#走熊", letter: "BA", tags:"taikyoku "},
    //free_tiger: {parlett: "", romanji: "honko", image: "circle#奔虎", letter: "+RT", tags:"taikyoku "},
    //free_bear: {parlett: "", romanji: "hon’yū", image: "circle#奔熊", letter: "+BA", tags:"taikyoku "},
    yaksha: {parlett: "1<, 1>X, n=.3", romanji: "yasha", promote: ["heavenly_tetrarch"], image: "circle#夜叉", letter: "YA", tags:"taikyoku "},
    //heavenly_tetrarch: {parlett: "", romanji: "shiten", image: "circle#四天", letter: "+YA", tags:"taikyoku "},
    buddhist_devil: {parlett: "n>X.3, 1=, 1<", romanji: "rasetsu", promote: ["heavenly_tetrarch"], image: "circle#羅刹", letter: "BD", tags:"taikyoku "},
    guardian_of_the_gods: {parlett: "n+.3", romanji: "kongō", promote: ["heavenly_tetrarch"], image: "circle#金剛", letter: "GU", tags:"taikyoku "},
    wrestler: {parlett: "nX.4", romanji: "rikishi", promote: ["heavenly_tetrarch"], image: "circle#力士", letter: "WR", tags:"taikyoku "},
    //silver_general: {parlett: "", romanji: "ginshō", promote: ["vertical_mover"], image: "circle#銀将", letter: "S", tags:"taikyoku "}, // TODO: reconcile
    //violent_stag: {parlett: "#silver_general", romanji: "mōroku", promote: ["rushing_boar"], image: "circle#猛鹿", letter: "VS", tags:"taikyoku "},
    //drunken_elephant: {parlett: "", romanji: "suizō", promote: ["crown_prince"], image: "circle#酔象", letter: "DE", tags:"taikyoku "}, // TODO: reconcile
    //neighboring_king: {parlett: "#drunken_elephant", romanji: "kinnō", promote: ["front_standard"], image: "circle#近王", letter: "NK", tags:"taikyoku "},
    gold_chariot: {parlett: "1X, n=.2, n<, n>", romanji: "kinsha", promote: ["playful_cockatoo"], image: "circle#金車", letter: "GC", tags:"taikyoku "},
    //playful_cockatoo: {parlett: "", romanji: "yūmo", image: "circle#遊母", letter: "+GC", tags:"taikyoku "},
    //right_army: {parlett: "", romanji: "ugun", image: "circle#右軍", letter: "+RG", tags:"taikyoku "},
    //left_army: {parlett: "", romanji: "sagun", image: "circle#左軍", letter: "+LG", tags:"taikyoku "},
    side_dragon: {parlett: "n>, n=", romanji: "ōryū", promote: ["running_dragon"], image: "circle#横龍", letter: "SI", tags:"taikyoku "},
    //running_dragon: {parlett: "", romanji: "sōryū", image: "circle#走龍", letter: "+SI", tags:"taikyoku "},
    running_stag: {parlett: "n<.2, n=, nX>", romanji: "sōroku", promote: ["free_stag"], image: "circle#走鹿", letter: "RN", tags:"taikyoku "},
    //free_stag: {parlett: "", romanji: "honroku", image: "circle#奔鹿", letter: "+RN", tags:"taikyoku "},
    running_wolf: {parlett: "1>, n=, nX>", romanji: "sōrō", promote: ["free_wolf"], image: "circle#走狼", letter: "RW", tags:"taikyoku "},
    //free_wolf: {parlett: "", romanji: "honrō", image: "circle#奔狼", letter: "+RW", tags:"taikyoku "},
    //bishop_general: {parlett: "", romanji: "kakushō", promote: ["rain_demon"], image: "circle#角将", letter: "BG", tags:"taikyoku "}, // TODO: fly
    //rook_general: {parlett: "", romanji: "hishō", promote: ["flying_crocodile"], image: "circle#飛将", letter: "RO", tags:"taikyoku "}, // TODO: fly
    //rain_demon: {parlett: "", romanji: "rinki", image: "circle#霖鬼", letter: "+BG", tags:"taikyoku "},
    //flying_crocodile: {parlett: "", romanji: "higaku", image: "circle#飛鰐", letter: "+RO", tags:"taikyoku "},
    right_tiger: {parlett: "1↗, 1↘, n<<, n↙, n↖", romanji: "uko", promote: ["white_tiger"], image: "circle#右虎", letter: "TT", tags:"taikyoku "},
    left_tiger: {parlett: "1↖, 1↙, n>>, n↗, n↘", romanji: "sako", promote: ["turtle_snake"], image: "circle#左虎", letter: "LT", tags:"taikyoku "},
    right_dragon: {parlett: "n>>.2, n<<, n↙, n↖", romanji: "uryū", promote: ["blue_dragon"], image: "circle#右龍", letter: "RI", tags:"taikyoku "},
    left_dragon: {parlett: "n<<.2, n>>, n↗, n↘", romanji: "saryū", promote: ["vermillion_sparrow"], image: "circle#左龍", letter: "LE", tags:"taikyoku "},
    beast_officer: {parlett: "n=.2, n>.3, nX.3", romanji: "jūri", promote: ["beast_bird"], image: "circle#獣吏", letter: "BO", tags:"taikyoku "},
    //beast_bird: {parlett: "", romanji: "jūchō", image: "circle#獣鳥", letter: "+BO", tags:"taikyoku "},
    wind_dragon: {parlett: "1↙, n=, nX>, n↘", romanji: "fūryū", promote: ["free_dragon"], image: "circle#風龍", letter: "WD", tags:"taikyoku "},
    //free_dragon: {parlett: "", romanji: "honryū", image: "circle#奔龍", letter: "+WD", tags:"taikyoku "},
    free_pup: {parlett: "1X<, n=.2, n>, n<, nX>", romanji: "honku", promote: ["free_dog"], image: "circle#奔狗", letter: "FP", tags:"taikyoku "},
    //free_dog: {parlett: "", romanji: "honken", image: "circle#奔犬", letter: "+FP", tags:"taikyoku "},
    rushing_bird: {parlett: "1=, 1X, n>.2", romanji: "gyōchō", promote: ["free_demon"], image: "circle#行鳥", letter: "RB", tags:"taikyoku "},
    old_kite: {parlett: "nX.2, 1=", aka:["hawk"], romanji: "kotetsu", promote: ["longnosed_goblin"], image: "circle#古鵄", letter: "OK", tags:"taikyoku "},
    //peacock: {parlett: "", romanji: "kujaku", promote: ["longnosed_goblin"], image: "circle#孔雀", letter: "PC", tags:"taikyoku "}, // TODO: hook move
    water_dragon: {parlett: "nX>.2, n↙.4, n↘.4", romanji: "suiryū", promote: ["phoenix_master"], image: "circle#水龍", letter: "WA", tags:"taikyoku "},
    fire_dragon: {parlett: "nX<.2, nX>.4, n+", romanji: "karyū", promote: ["kirin_master"], image: "circle#火龍", letter: "FI", tags:"taikyoku "},
    //copper_general: {parlett: "1>, 1<, ", romanji: "dōshō", promote: ["side_mover"], image: "circle#銅将", letter: "C", tags:"taikyoku "}, // TODO: reconcile
    phoenix_master: {parlett: "n=.3, nX, n>, n<, ~3X>", romanji: "hōshi", image: "circle#鳳師", letter: "PM", tags:"taikyoku "}, 
    kirin_master: {parlett: "n=.3, nX, n>, n<, ~3X>, ~3X<", romanji: "rinshi", image: "circle#麟師", letter: "KM", tags:"taikyoku "},
    silver_chariot: {parlett: "1X<, nX>.2, n>, n<", romanji: "ginsha", promote: ["goose_wing"], image: "circle#銀車", letter: "SV", tags:"taikyoku "},
    //goose_wing: {parlett: "", romanji: "kōyoko", image: "circle#鴻翼", letter: "+SV", tags:"taikyoku "},
    vertical_bear: {parlett: "1<, n=.2, n>", romanji: "shuyū", promote: ["free_bear"], image: "circle#竪熊", letter: "VE", tags:"taikyoku "},
    //knight: {parlett: "", romanji: "keima", promote: ["side_soldier"], image: "circle#桂馬", letter: "N", tags:"taikyoku "}, // TODO: reconcile
    pig_general: {parlett: "n<.2, nX>.4", romanji: "tonshō", promote: ["free_pig"], image: "circle#豚将", letter: "PI", tags:"taikyoku "},
    //free_pig: {parlett: "", romanji: "honton", image: "circle#奔豚", letter: "+PI", tags:"taikyoku "},
    chicken_general: {parlett: "1X<, n>.4", romanji: "keishō", promote: ["free_chicken"], image: "circle#鶏将", letter: "CG", tags:"taikyoku "},
    pup_general: {parlett: "#chicken_general", romanji: "kushō", promote: ["free_pup"], image: "circle#狗将", letter: "PG", tags:"taikyoku "},
    //free_chicken: {parlett: "", romanji: "honkei", image: "circle#奔鶏", letter: "+CG", tags:"taikyoku "},
    horse_general: {parlett: "1<, 1X>, n>.3", romanji: "bashō", promote: ["free_horse"], image: "circle#馬将", letter: "H", tags:"taikyoku "},
    ox_general: {parlett: "#ox_general", romanji: "gyūshō", promote: ["free_ox"], image: "circle#牛将", letter: "O", tags:"taikyoku "},
    //free_horse: {parlett: "", romanji: "honba", image: "circle#奔馬", letter: "+H", tags:"taikyoku "},
    //free_ox: {parlett: "", romanji: "hongyū", image: "circle#奔牛", letter: "+O", tags:"taikyoku "},
    center_standard: {parlett: "nX.3, n+", romanji: "chūki", promote: ["front_standard"], image: "circle#中旗", letter: "CN", tags:"taikyoku "},
    front_standard: {parlett: "#center_standard", romanji: "zenki", promote: ["great_standard"], image: "circle#前旗", letter: "SD", tags:"taikyoku "},
    side_boar: {parlett: "1>, 1<, 1X, n=", romanji: "ōcho", promote: ["free_boar"], image: "circle#横猪", letter: "SA", tags:"taikyoku "},
    //free_boar: {parlett: "", romanji: "honcho", image: "circle#奔猪", letter: "+SA", tags:"taikyoku "},
    silver_rabbit: {parlett: "nX>.2, nX<", romanji: "ginto", promote: ["whale"], image: "circle#銀兎", letter: "SR", tags:"taikyoku "},
    golden_deer: {parlett: "nX>, nX<.2", romanji: "konroku", promote: ["white_horse"], image: "circle#金鹿", letter: "GL", tags:"taikyoku "},
    //lion: {parlett: "", romanji: "shishi", promote: ["furious_fiend"], image: "circle#獅子", letter: "LN", tags:"taikyoku "}, // TODO: area mover 
    //furious_fiend: {parlett: "", romanji: "funjin", image: "circle#奮迅", letter: "+LN", tags:"taikyoku "},
    captive_cadet: {parlett: "n>.3, n=.3, nX.3", romanji: "kinsō", promote: ["captive_officer"], image: "circle#禽曹", letter: "CT", tags:"taikyoku "},
    great_stag: {parlett: "nX<.2, ~2X>, n+", romanji: "dairoku", promote: ["free_stag"], image: "circle#大鹿", letter: "GS", tags:"taikyoku "},
    //violent_dragon: {parlett: "n+.4", romanji: "mōryū", promote: ["great_dragon"], image: "circle#猛龍", letter: "VD", tags:"taikyoku "}, // TODO: flying
    woodland_demon: {parlett: "n=.2, n>, n<, nX>", romanji: "rinki", promote: ["right_phoenix"], image: "circle#林鬼", letter: "WL", tags:"taikyoku "},
    //right_phoenix: {parlett: "", romanji: "ushū", image: "circle#右鵰", letter: "+WL", tags:"taikyoku "},
    //vice_general: {parlett: "~2X=, ", romanji: "fukushō", promote: ["great_general"], image: "circle#副将", letter: "VG", tags:"taikyoku "}, TODO: flying
    //great_general: {parlett: "", romanji: "taishō", image: "circle#大将", letter: "GG", tags:"taikyoku "}, // TODO: flying
    stone_chariot: {parlett: "1X>, n=.2, n>, n<", romanji: "sekisha", promote: ["walking_heron"], image: "circle#石車", letter: "CI", tags:"taikyoku "},
    //walking_heron: {parlett: "", romanji: "fushin", image: "circle#歩振", letter: "+CI", tags:"taikyoku "},
    cloud_eagle: {parlett: "1=, nX>.3, n>, n<", romanji: "unjū", promote: ["strong_eagle"], image: "circle#雲鷲", letter: "CE", tags:"taikyoku "},
    //strong_eagle: {parlett: "", romanji: "keijū", image: "circle#勁鷲", letter: "+CE", tags:"taikyoku "},
    //bishop: {parlett: "nX", romanji: "kakugyō", promote: ["dragon_horse"], image: "circle#角行", letter: "B", tags:"taikyoku "}, // TODO: reconcile
    //rook: {parlett: "n+", romanji: "hisha", promote: ["dragon_king"], image: "circle#飛車", letter: "R", tags:"taikyoku "}, // TODO: reconcile
    //soldier: {parlett: "#rook", romanji: "heishi", promote: ["cavalier"], image: "circle#兵士", letter: "SO", tags:"taikyoku "}, // TODO: reconcile
    running_chariot: {parlett: "#rook", romanji: "sōsha", promote: ["burning_chariot"], image: "circle#走車", letter: "RH", tags:"taikyoku "},
    square_mover: {parlett: "#rook", romanji: "hōgyō", promote: ["strong_chariot"], image: "circle#方行", letter: "SQ", tags:"taikyoku "},
    side_wolf: {parlett: "1↖, 1↘, n=", romanji: "ōrō", promote: ["free_wolf"], image: "circle#横狼", letter: "WF", tags:"taikyoku "},
    flying_cat: {parlett: "1<, X<, ~3>, ~3=, ~3/3", romanji: "hibyō", promote: ["rook"], image: "circle#飛猫", letter: "FC", tags:"taikyoku "},
    mountain_falcon: {parlett: "nX<.2, ~2>, n+, nX>", romanji: "san’ō", promote: ["horned_falcon"], image: "circle#山鷹", letter: "MF", tags:"taikyoku "},
    vertical_tiger: {parlett: "n<.2, n>", romanji: "shuko", promote: ["free_tiger"], image: "circle#竪虎", letter: "VT", tags:"taikyoku "},
    //cavalier: {parlett: "", romanji: "kishi", image: "circle#騎士", letter: "+SO", tags:"taikyoku "},
    little_standard: {parlett: "1X<, nX>.2, n+", romanji: "shōki", promote: ["rear_standard"], image: "circle#小旗", letter: "LS", tags:"taikyoku "},
    cloud_dragon: {parlett: "1>, 1=, n<, nX", romanji: "unryū", promote: ["great_dragon"], image: "circle#雲龍", letter: "CL", tags:"taikyoku "},
    copper_chariot: {parlett: "nX>.3, n>, n<", romanji: "dōsha", promote: ["copper_elephant"], image: "circle#銅車", letter: "CR", tags:"taikyoku "},
    //copper_elephant: {parlett: "", romanji: "dōzō", image: "circle#銅象", letter: "+CR", tags:"taikyoku "},
    //burning_chariot: {parlett: "", romanji: "hōsha", image: "circle#炮車", letter: "+RH", tags:"taikyoku "},
    ramshead_soldier: {parlett: "nX>, 1<", romanji: "yōhei", promote: ["tiger_soldier"], image: "circle#羊兵", letter: "HE", tags:"taikyoku "},
    //tiger_soldier: {parlett: "", romanji: "kohei", image: "circle#虎兵", letter: "+HE", tags:"taikyoku "},
    violent_ox: {parlett: "1>, 1<, nX>", romanji: "mōgyū", promote: ["flying_ox"], image: "circle#猛牛", letter: "VO", tags:"taikyoku "},
    great_dragon: {parlett: "n>.3, n<.3, nX", romanji: "dairyū", promote: ["ancient_dragon"], image: "circle#大龍", letter: "GD", tags:"taikyoku "},
    //ancient_dragon: {parlett: "", romanji: "genryū, ganryū", image: "circle#元龍", letter: "+GD", tags:"taikyoku "},
    //golden_bird: {parlett: "n=.3, nX<.3, n>, n<", romanji: "kinshi", promote: ["free_bird"], image: "circle#金翅", letter: "GO", tags:"taikyoku "}, // TODO: jump up to 3 X>
    //free_bird: {parlett: "", romanji: "honshi", image: "circle#奔翅", letter: "+GO", tags:"taikyoku "},
    dark_spirit: {parlett: "1+, 1↘, 1↗, 1↙", romanji: "mumyō", promote: ["buddhist_spirit"], image: "circle#無明", letter: "DS", tags:"taikyoku generals "},
    //buddhist_spirit: {parlett: "", romanji: "hōsei", image: "circle#法性", letter: "+DS", tags:"taikyoku "},
    deva: {parlett: "1+, 1↘, 1↖, 1↙", romanji: "daiba", promote: ["teaching_king"], image: "circle#提婆", letter: "DV", tags:"taikyoku generals "},
    //teaching_king: {parlett: "", romanji: "kyōō", image: "circle#教王", letter: "+DV", tags:"taikyoku "},
    wood_chariot: {parlett: "1↖, 1↘, n>, n<", romanji: "mokusha", promote: ["wind_snapping_turtle"], image: "circle#木車", letter: "WC", tags:"taikyoku "},
    //wind_snapping_turtle: {parlett: "", romanji: "fūbetsu", image: "circle#風鼈", letter: "+WC", tags:"taikyoku "},
    white_horse: {parlett: "n>, n<, nX>", romanji: "hakku", promote: ["great_horse"], image: "circle#白駒", letter: "WH", tags:"taikyoku "},
    //great_horse: {parlett: "", romanji: "daiku", image: "circle#大駒", letter: "+WH", tags:"taikyoku "},
    howling_dog_left: {parlett: "1<, n>", romanji: "kiken", promote: ["left_dog"], image: "circle#口奇犬", letter: "HL", tags:"taikyoku "},
    howling_dog_right: {parlett: "#howling_dog_left", romanji: "kiken", promote: ["right_dog"], image: "circle#口奇犬", letter: "HD", tags:"taikyoku "},
    //right_dog: {parlett: "", romanji: "uken", image: "circle#右犬", letter: "+HD", tags:"taikyoku "},
    //left_dog: {parlett: "", romanji: "saken", image: "circle#左犬", letter: "+HL", tags:"taikyoku "},
    side_mover: {parlett: "n=, 1>, 1<", romanji: "ōgyō", promote: ["free_boar"], image: "circle#横行", letter: "SM", tags:"taikyoku "},
    prancing_stag: {parlett: "n=.2, 1>, 1<, 1X>", romanji: "yōroku", promote: ["square_mover"], image: "circle#踊鹿", letter: "PR", tags:"taikyoku "},
    water_buffalo: {parlett: "nX, n=, n>.2, n<.2", romanji: "suigyū", promote: ["great_dreameater"], image: "circle#水牛", letter: "WB", tags:"taikyoku "},
    //great_dreameater: {parlett: "", romanji: "daibaku", image: "circle#大獏", letter: "+WB", tags:"taikyoku "},
    //ferocious_leopard: {parlett: "1X, 1>, 1<", romanji: "mōhyō", promote: ["bishop"], image: "circle#猛豹", letter: "FL", tags:"taikyoku generals"}, // TODO: reconcile
    fierce_eagle: {parlett: "nX.2, 1>, 1=", romanji: "mōjū", promote: ["soaring_eagle"], image: "circle#猛鷲", letter: "EG", tags:"taikyoku "},
    flying_dragon: {parlett: "~2/2&", romanji: "hiryū", promote: ["dragon_king"], image: "circle#飛龍", letter: "FD", tags:"taikyoku "}, // TODO: reconcile w/ skip bishop
    poisonous_snake: {parlett: "1<, 1X>, n>.2, n=.2", romanji: "dokuja", promote: ["hook_mover"], image: "circle#毒蛇", letter: "PS", tags:"taikyoku "},
    flying_goose: {parlett: "1>, 1<, 1X>", romanji: "ganhi", promote: ["swallow’s_wings"], image: "circle#鳫飛", letter: "FY", tags:"taikyoku generals"}, // TODO: reconcile w/ one of the generals
    strutting_crow: {parlett: "1>, 1X<", romanji: "ukō", promote: ["flying_falcon"], image: "circle#烏行", letter: "ST", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //flying_falcon: {parlett: "", romanji: "hiyō", image: "circle#飛鷹", letter: "+ST", tags:"taikyoku "},
    blind_dog: {parlett: "1<, 1=, 1X>", romanji: "mōken", promote: ["violent_stag"], image: "circle#盲犬", letter: "BI", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    chinese_cock: {parlett: "#blind_dog", romanji: "waikei", promote: ["wizard_stork"], image: "circle#淮鶏", letter: "CC", tags:"taikyoku "},
    water_general: {parlett: "1>, 1<, nX.3", romanji: "suishō", promote: ["vice_general"], image: "circle#水将", letter: "WG", tags:"taikyoku "},
    mountain_general: {parlett: "#water_general", romanji: "sanshō", promote: ["peaceful_mountain"], image: "circle#山将", letter: "M", tags:"taikyoku "},
    fire_general: {parlett: "1X>, n>.3, n<.3", romanji: "kashō", promote: ["great_general"], image: "circle#火将", letter: "F", tags:"taikyoku "},
    phoenix: {parlett: "1=, ~2X", romanji: "hōō", promote: ["golden_bird"], image: "circle#鳳凰", letter: "PH", tags:"taikyoku "},
    kirin: {parlett: "1>, 1X, ~2X", romanji: "kirin", promote: ["golden_bird"], image: "circle#麒麟", letter: "KR", tags:"taikyoku "},
    //hook_mover: {parlett: "", romanji: "kōgyō", image: "circle#鉤行", letter: "HM", tags:"taikyoku "}, // TODO: hook move
    little_turtle: {parlett: "n=.2, ~2>, ~2<, n>, n<, nX", romanji: "shōki", promote: ["treasure_turtle"], image: "circle#小亀", letter: "LL", tags:"taikyoku "},
    //treasure_turtle: {parlett: "", romanji: "hōki", image: "circle#宝亀", letter: "+LL", tags:"taikyoku "},
    great_turtle: {parlett: "n=.3, ~3>, ~3<, n>, n<, nX", romanji: "daiki", promote: ["spirit_turtle"], image: "circle#大亀", letter: "GT", tags:"taikyoku "},
    //spirit_turtle: {parlett: "", romanji: "reiki", image: "circle#霊亀", letter: "+GT", tags:"taikyoku "},
    //capricorn: {parlett: "", romanji: "makatsu", promote: ["hook_mover"], image: "circle#摩羯", letter: "CA", tags:"taikyoku "}, // TODO: hook move
    tile_chariot: {parlett: "1↗, 1↙, n<, n>", romanji: "gasha", promote: ["running_tile"], image: "circle#瓦車", letter: "TC", tags:"taikyoku "},
    //running_tile: {parlett: "", romanji: "sōga", image: "circle#走瓦", letter: "+TC", tags:"taikyoku "},
    vertical_wolf: {parlett: "1=, n<.3, n>", romanji: "shurō", promote: ["running_wolf"], image: "circle#竪狼", letter: "VW", tags:"taikyoku "},
    side_ox: {parlett: "1↗, 1↙, n=", romanji: "ōgyū", promote: ["flying_ox"], image: "circle#横牛", letter: "SX", tags:"taikyoku "},
    donkey: {parlett: "n=.2", romanji: "roba", promote: ["ceramic_dove"], image: "circle#驢馬", letter: "DO", tags:"taikyoku "},
    enchanted_badger: {parlett: "#donkey", romanji: "henri", promote: ["ceramic_dove"], image: "circle#変狸", letter: "EB", tags:"taikyoku "},
    flying_horse: {parlett: "nX.2", romanji: "barin", promote: ["free_king"], image: "circle#馬麟", letter: "FH", tags:"taikyoku "},
    violent_bear: {parlett: "nX>.2, 1=, 1>", romanji: "mōyū", promote: ["great_bear"], image: "circle#猛熊", letter: "VB", tags:"taikyoku "}, // 1X< instead of 1>?
    //great_bear: {parlett: "", romanji: "daiyū", image: "circle#大熊", letter: "+VB", tags:"taikyoku "},
    //angry_boar: {parlett: "", romanji: "shincho", promote: ["free_boar"], image: "circle#嗔猪", letter: "AB", tags:"taikyoku "},
    evil_wolf: {parlett: "1=, 1>, 1X>", romanji: "akurō", promote: ["venomous_wolf"], image: "circle#悪狼", letter: "EW", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //venomous_wolf: {parlett: "", romanji: "dokurō", image: "circle#毒狼", letter: "+EW", tags:"taikyoku "},
    liberated_horse: {parlett: "1X>, n<.2, n>", romanji: "fūma", promote: ["heavenly_horse"], image: "circle#風馬", letter: "LH", tags:"taikyoku "},
    //heavenly_horse: {parlett: "", romanji: "temma", image: "circle#天馬", letter: "+LH", tags:"taikyoku "},
    flying_cock: {parlett: "1=, 1X>", romanji: "keihi", promote: ["raiding_falcon"], image: "circle#鶏飛", letter: "CK", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //raiding_falcon: {parlett: "", romanji: "en’yō", image: "circle#延鷹", letter: "+CK", tags:"taikyoku "},
    old_monkey: {parlett: "1X, 1<", romanji: "koen", promote: ["mountain_witch"], image: "circle#古猿", letter: "OM", tags:"taikyoku "}, // TODO: reconcile
    //mountain_witch: {parlett: "", romanji: "sanbo", image: "circle#山母", letter: "+OM", tags:"taikyoku "},
    //wizard_stork: {parlett: "", romanji: "senkaku", image: "circle#仙鷦", letter: "+CC", tags:"taikyoku "},
    northern_barbarian: {parlett: "n=.2, 1>, 1<, 1X>", romanji: "hokuteki", promote: ["wooden_dove"], image: "circle#北狄", letter: "NB", tags:"taikyoku "},
    southern_barbarian: {parlett: "#northern_barbarian", romanji: "nanban", promote: ["golden_bird"], image: "circle#南蛮", letter: "SU", tags:"taikyoku "},
    western_barbarian: {parlett: "n>.2, n<.2, 1=, 1X>", romanji: "seijū", promote: ["lion_dog"], image: "circle#西戎", letter: "WS", tags:"taikyoku "},
    eastern_barbarian: {parlett: "#western_barbarian", romanji: "tōi", promote: ["lion"], image: "circle#東夷", letter: "ES", tags:"taikyoku "},
    //rushing_boar: {parlett: "", romanji: "gyōcho", image: "circle#行猪", letter: "+VS", tags:"taikyoku "},
    //bears_eyes: {parlett: "", romanji: "yūgan", image: "circle#熊眼", letter: "+NT", tags:"taikyoku "},
    treacherous_fox: {parlett: "n>, n<, nX", romanji: "inko, onko", promote: ["mountain_crane"], image: "circle#隠狐", letter: "TF", tags:"taikyoku "},
    //mountain_crane: {parlett: "", romanji: "sankotsu", image: "circle#山鶻", letter: "+TF", tags:"taikyoku "},
    //center_master: {parlett: "n=.3, nX<.3", romanji: "chūshi", image: "circle#中師", letter: "MT", tags:"taikyoku "}, // TODO: jump then move
    //roc_master: {parlett: "", romanji: "hōshi", image: "circle#鵬師", letter: "RM", tags:"taikyoku "},
    earth_chariot: {parlett: "1=, n>, n<", romanji: "dosha", promote: ["young_bird"], image: "circle#土車", letter: "EC", tags:"taikyoku "},
    //young_bird: {parlett: "", romanji: "shakuchō", image: "circle#*尺鳥", letter: "+EC", tags:"taikyoku "},
    vermillion_sparrow: {parlett: "1+, 1↗, 1↙, n↖, n↘", romanji: "suzaku", promote: ["divine_sparrow"], image: "circle#朱雀", letter: "VI", tags:"taikyoku "},
    //divine_sparrow: {parlett: "", romanji: "shinjaku", image: "circle#神雀", letter: "+VI", tags:"taikyoku "},
    blue_dragon: {parlett: "n>, n<, nX↗, n=.2", romanji: "seiryū", promote: ["divine_dragon"], image: "circle#青龍", letter: "BL", tags:"taikyoku "},
    //divine_dragon: {parlett: "", romanji: "shinryū", image: "circle#神龍", letter: "+BL", tags:"taikyoku "},
    horseman: {parlett: "n=.2, n>, n<, nX>", romanji: "kihei", promote: ["cavalier"], image: "circle#騎兵", letter: "HO", tags:"taikyoku "},
    swooping_owl: {parlett: "1>, 1X<", romanji: "shigyō", promote: ["cloud_eagle"], image: "circle#鴟行", letter: "OW", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    old_rat: {parlett: "#swooping_owl", romanji: "rōso", promote: ["bird_of_paradise"], image: "circle#老鼠", letter: "OR", tags:"taikyoku "},
    climbing_monkey: {parlett: "1>, 1<, 1X>", romanji: "tōen", promote: ["violent_stag"], image: "circle#登猿", letter: "CM", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    cat_sword: {parlett: "#ferz", romanji: "myōjin", promote: ["dragon_horse"], image: "circle#猫刄", letter: "CS", tags:"taikyoku "},
    swallows_wings: {parlett: "1>, 1<, n=", romanji: "en’u", promote: ["gliding_swallow"], image: "circle#燕羽", letter: "SW", tags:"taikyoku "},
    //gliding_swallow: {parlett: "", romanji: "engyō", image: "circle#燕行", letter: "+SW", tags:"taikyoku "},
    blind_monkey: {parlett: "1X, 1=", romanji: "mōen", promote: ["flying_stag"], image: "circle#盲猿", letter: "BM", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //flying_stag: {parlett: "", romanji: "hiroku", image: "circle#飛鹿", letter: "+BM", tags:"taikyoku "},
    //blind_tiger: {parlett: "", romanji: "mōko", promote: ["flying_stag"], image: "circle#盲虎", letter: "BT", tags:"taikyoku "}, // TODO: reconcile
    //plodding_ox: {parlett: "", romanji: "sengyū", image: "circle#歬牛", letter: "+OC", tags:"taikyoku "},
    side_flier: {parlett: "1X, n=", romanji: "ōhi", promote: ["side_dragon"], image: "circle#横飛", letter: "SF", tags:"taikyoku "},
    blind_bear: {parlett: "1X, 1=", romanji: "mōyū", promote: ["flying_stag"], image: "circle#盲熊", letter: "BB", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //bird_of_paradise: {parlett: "", romanji: "jichō", image: "circle#", letter: "+OR", tags:"taikyoku "},
    //strong_chariot: {parlett: "", romanji: "kyōsha", image: "circle#強車", letter: "+SQ", tags:"taikyoku "},
    coiled_serpent: {parlett: "1>, 1<, 1X<", romanji: "banja", promote: ["coiled_dragon"], image: "circle#蟠蛇", letter: "SN", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //coiled_dragon: {parlett: "", romanji: "banryū", image: "circle#蟠龍", letter: "+SN", tags:"taikyoku "},
    reclining_dragon: {parlett: "#wazir", romanji: "garyū", promote: ["great_dragon"], image: "circle#臥龍", letter: "RD", tags:"taikyoku "},
    //free_eagle: {parlett: "", romanji: "honjū", image: "circle#奔鷲", letter: "FE", tags:"taikyoku "}, // TODO: jump/ranging
    //lion_hawk: {parlett: "", romanji: "shiō", image: "circle#獅鷹", letter: "LI", tags:"taikyoku "}, // TODO: area move/double capture/ranging
    chariot_soldier: {parlett: "n=.2, n>, n<, nX", romanji: "shahei", promote: ["heavenly_tetrarch_king"], image: "circle#車兵", letter: "CH", tags:"taikyoku "},
    //heavenly_tetrarch_king: {parlett: "", romanji: "shitennō", image: "circle#四天王", letter: "+CH", tags:"taikyoku "},
    side_soldier: {parlett: "1<, n>.2, n=", romanji: "ōhei", promote: ["water_buffalo"], image: "circle#横兵", letter: "SL", tags:"taikyoku "},
    vertical_soldier: {parlett: "1<, n=.2, n>", romanji: "shuhei", promote: ["chariot_soldier"], image: "circle#竪兵", letter: "VR", tags:"taikyoku "},
    wind_general: {parlett: "1<, 1X>, n>.3, n>, nX>", romanji: "fūshō", promote: ["violent_wind"], image: "circle#風将", letter: "WN", tags:"taikyoku "},
    river_general: {parlett: "#wind_general", romanji: "senshō", promote: ["chinese_river"], image: "circle#川将", letter: "RE", tags:"taikyoku "},
    //violent_wind: {parlett: "", romanji: "bōfū", image: "circle#暴風", letter: "+WN", tags:"taikyoku "},
    //chinese_river: {parlett: "", romanji: "waisen", image: "circle#淮川", letter: "+RE", tags:"taikyoku "},
    //peaceful_mountain: {parlett: "", romanji: "taizan", image: "circle#泰山", letter: "+M", tags:"taikyoku "},
    //horse_soldier: {parlett: "", romanji: "bahei", promote: ["running_horse"], image: "circle#馬兵", letter: "HS", tags:"taikyoku "},
    wood_general: {parlett: "nX>.2", romanji: "mokushō", promote: ["white_elephant"], image: "circle#木将", letter: "GN", tags:"taikyoku "},
    //ox_soldier: {parlett: "", romanji: "gyūhei", promote: ["running_ox"], image: "circle#牛兵", letter: "OS", tags:"taikyoku "},
    //running_ox: {parlett: "", romanji: "sōgyū", image: "circle#走牛", letter: "+OS", tags:"taikyoku "},
    earth_general: {parlett: "1>, 1<", romanji: "doshō", promote: ["white_elephant"], image: "circle#土将", letter: "EA", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    go_between: {parlett: "#earth_general", romanji: "chūnin", promote: ["drunken_elephant"], image: "circle#仲人", letter: "GB", tags:"taikyoku "}, // TODO: reconcile
    boar_soldier: {parlett: "1<, n=.2, n>, nX>", romanji: "chohei", promote: ["running_boar"], image: "circle#猪兵", letter: "BS", tags:"taikyoku "},
    leopard_soldier: {parlett: "#boar_soldier", romanji: "hyōhei", promote: ["running_leopard"], image: "circle#豹兵", letter: "LP", tags:"taikyoku "},
    bear_soldier: {parlett: "#boar_soldier", romanji: "yūhei", promote: ["strong_bear"], image: "circle#熊兵", letter: "BE", tags:"taikyoku "},
    //running_boar: {parlett: "", romanji: "sōcho", image: "circle#走猪", letter: "+BS", tags:"taikyoku "},
    stone_general: {parlett: "1X>", romanji: "sekishō", promote: ["white_elephant"], image: "circle#石将", letter: "SG", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    //running_leopard: {parlett: "", romanji: "sōhyō", image: "circle#走豹", letter: "+LP", tags:"taikyoku "},
    tile_general: {parlett: "1X>, 1<", romanji: "gashō", promote: ["white_elephant"], image: "circle#瓦将", letter: "T", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    sword_general: {parlett: "#tile_general", romanji: "tōshō", image: "circle#刀将", letter: "+SE", tags:"taikyoku "},
    //strong_bear: {parlett: "", romanji: "kyōyū", image: "circle#強熊", letter: "+BE", tags:"taikyoku "},
    iron_general: {parlett: "1>, 1X>", romanji: "tesshō", promote: ["white_elephant"], image: "circle#鉄将", letter: "I", tags:"taikyoku generals"}, // TODO: reconcile w/ generals
    dog: {parlett: "#iron_general", romanji: "inu", promote: ["multi_general"], image: "circle#犬", letter: "D", tags:"taikyoku "}, // TODO: rename other dog
    great_standard: {parlett: "nX<.3, nX>, n+", romanji: "daiki", image: "circle#大旗", letter: "GE", tags:"taikyoku "},
    //great_master: {parlett: "n=.5, nX<.5", romanji: "daishi", image: "circle#大師", letter: "GM", tags:"taikyoku "}, // TODO: jump
    right_chariot: {parlett: "n>, n↗, n↙, 1>>", romanji: "usha", promote: ["right_iron_chariot"], image: "circle#右車", letter: "RC", tags:"taikyoku "},
    left_chariot: {parlett: "n>, n↖, n↘, 1<<", romanji: "sasha", promote: ["left_iron_chariot"], image: "circle#左車", letter: "LC", tags:"taikyoku "},
    //right_iron_chariot: {parlett: "", romanji: "utessha", image: "circle#右鉄車", letter: "+RC", tags:"taikyoku "},
    //left_iron_chariot: {parlett: "", romanji: "satessha", image: "circle#左鉄車", letter: "+LC", tags:"taikyoku "},
    side_monkey: {parlett: "1X>, 1<, n=", romanji: "ōen", promote: ["side_soldier"], image: "circle#横猿", letter: "MK", tags:"taikyoku "},
    vertical_mover: {parlett: "n>, n<, 1=", romanji: "shugyō", promote: ["flying_ox"], image: "circle#竪行", letter: "VM", tags:"taikyoku "},
    flying_ox: {parlett: "nX, n>, n<", romanji: "higyū", promote: ["fire_ox"], image: "circle#飛牛", letter: "OX", tags:"taikyoku "},
    //fire_ox: {parlett: "", romanji: "kagyū", image: "circle#火牛", letter: "+OX", tags:"taikyoku "},
    longbow_soldier: {parlett: "1<, n=.2, nX.3, n>", romanji: "dohei", promote: ["longbow_general"], image: "circle#弩兵", letter: "LB", tags:"taikyoku "},
    //longbow_general: {parlett: "", romanji: "doshō", image: "circle#弩将", letter: "+LB", tags:"taikyoku "},
    vertical_pup: {parlett: "1X<, 1<, n>", romanji: "shuku", promote: ["leopard_king"], image: "circle#竪狗", letter: "VP", tags:"taikyoku "},
    //leopard_king: {parlett: "", romanji: "hyōō", image: "circle#豹王", letter: "+VP", tags:"taikyoku "},
    vertical_horse: {parlett: "1X>, 1<, n>", romanji: "shuba", promote: ["dragon_horse"], image: "circle#竪馬", letter: "VH", tags:"taikyoku "},
    burning_soldier: {parlett: "1<, n=.3, nX>.5, n>.7", romanji: "hōhei", promote: ["burning_general"], image: "circle#炮兵", letter: "BN", tags:"taikyoku "},
    //burning_general: {parlett: "", romanji: "hōshō", image: "circle#炮将", letter: "+BN", tags:"taikyoku "},
    dragon_horse: {parlett: "nX, 1+", romanji: "ryūme", promote: ["horned_falcon"], image: "circle#龍馬", letter: "DH", tags:"taikyoku "}, // TODO: reconcile
    dragon_king: {parlett: "n+, 1X", romanji: "ryūō", promote: ["soaring_eagle"], image: "circle#龍王", letter: "DK", tags:"taikyoku "},
    //sword_soldier: {parlett: "", romanji: "tōhei", promote: ["sword_general"], image: "circle#刀兵", letter: "SE", tags:"taikyoku "},
    //horned_falcon: {parlett: "#free_king", romanji: "kakuō", promote: ["great_falcon"], image: "circle#角鷹", letter: "HF", tags:"taikyoku "}, //  TODO: jump
    //great_falcon: {parlett: "", romanji: "daiō", image: "circle#大鷹", letter: "+HF", tags:"taikyoku "},
    //soaring_eagle: {parlett: "", romanji: "hijū", promote: ["great_eagle"], image: "circle#飛鷲", letter: "EL", tags:"taikyoku "}, // TODO: jump
    //great_eagle: {parlett: "", romanji: "daijū", image: "circle#大鷲", letter: "+EL", tags:"taikyoku "},
    spear_soldier: {parlett: "1<, 1=, n>", romanji: "sōhei", promote: ["spear_general"], image: "circle#鎗兵", letter: "SP", tags:"taikyoku "},
    //spear_general: {parlett: "", romanji: "sōshō", image: "circle#鎗将", letter: "+SP", tags:"taikyoku "},
    vertical_leopard: {parlett: "1<, 1=, 1X>, n>", romanji: "shuhyō", promote: ["great_leopard"], image: "circle#竪豹", letter: "VL", tags:"taikyoku "},
    //great_leopard: {parlett: "", romanji: "daihyō", image: "circle#大豹", letter: "+VL", tags:"taikyoku "},
    //great_tiger: {parlett: "", romanji: "daiko", image: "circle#大虎", letter: "+TG", tags:"taikyoku "},
    crossbow_soldier: {parlett: "1<, n=.3, nX>.3, n>.5", romanji: "kyūhei", promote: ["crossbow_general"], image: "circle#弓兵", letter: "SB", tags:"taikyoku "},
    //crossbow_general: {parlett: "", romanji: "kyūshō", image: "circle#弓将", letter: "+SB", tags:"taikyoku "},
    roaring_dog: {parlett: "nX<.3, ~3+, ~3X>, nX>, n+", romanji: "kōken", promote: ["lion_dog"], image: "circle#吼犬", letter: "DG", tags:"taikyoku "},
    lion_dog: {parlett: "~3*, n*", romanji: "komainu", promote: ["great_elephant"], image: "circle#狛犬", letter: "LD", tags:"taikyoku "},
    //great_elephant: {parlett: "", romanji: "taizō", image: "circle#大象", letter: "+LD", tags:"taikyoku "},
    //multi_general: {parlett: "", romanji: "suishō", image: "circle#雜将", letter: "+D", tags:"taikyoku "},
    //pawn: {parlett: "1>", romanji: "fuhyō", promote: ["gold_general"], image: "circle#歩兵", letter: "P", tags:"taikyoku "}, // TODO: reconcile
    // whew!

    // Complex riders
    griffon: {parlett: "[1,0](n+>), [1,0](n+<), [0,1](n+>>), [0,1](n+<<), [-1,0](n+<), [-1,0](n+>), [0,-1](n+<<), [0,-1](n+>>)", 
        image:"gryphon", url:"pc:griffon"}, 

    panda: {parlett: "[0,-1](~2/0>&), [0,1](~2/0<&), [1,0](~2/0<<&), [-1,0](~2/0>>&)", image:["panda", "sliprook"], url:"http://www.chessvariants.org/unequal.dir/seeping-switchers.html", hex:"U+1F43C"},

    slipbishop: {parlett: "[1,-1](~2/2↖&), [-1,-1](~2/2↗&), [-1,1](~2/2↘&), [1,1](~2/2↙&)"},
    slipqueen: {parlett: "#panda, #slipbishop"},

    crookedbishop: {parlett: "nX\\90,-90\\, nX\\-90,90\\", url:"pc:crookedbishop", image:["crookedbishop", "eaglescout"], aka:["hotdog"]}, 
    crookedrook: {parlett: "n+\\90,-90, n+\\-90,90\\"},
    crookedqueen: {parlett: "#crookedbishop, #rook", url:"pc:crooked-queen"},

    // Invented rotations
    galaxy: {parlett: "n+\\45\\", image:"horsezzstar"},
    nazi: {parlett: "nX\\45,0\\.3", image:"thief"},
    hitler: {parlett: "n*\\90,0,0\\", image:"theif2"}, // image name actually is misspelled

    // Explicit movements
    crab: {parlett: "[1,2], [-1,2], [-2,-1], [2,-1]", image: ["betzancrab", "crab2", "crab"], url:"pc:crab"},
    barc: {parlett: "[1,-2], [-1,-2], [-2,1], [2,1]", image: ["barc2", "barc"], url:"pc:barc"},
    mushroom: {parlett: "[-1,2], [1,2], [3,1], [-3,1], [1,-1], [1,-2], [-1,-1], [-1,-2]", url:"pc:mushroom", hex: "U+1F344"},
    sausage: {parlett: "1X, 1=, ~0/3<>, [1,2], [-1,2], [1,-2], [-1,-2]", url:"http://www.chessvariants.org/unequal.dir/pizza-kings.html", castle:true},
    pepperoni: {parlett: "2=, 1X, 1<, 1>, ~2/2>"},
    meatball: {parlett: "#ferz, #wazir, #alfil, #warmachine, [1,2], [-1,2]", url:"http://www.chessvariants.org/unequal.dir/pizza-kings.html"},

    
    // Pieces that probably won't be supported without significant coding
    // TODO: "darters", blockable 'leapers' - 1//2, elban knight, like horse and moa
    //checker: {parlett: "cn(^2X>), o1X>", promote: "checker_kinged", letter:"XY"},  // no grouping
    //checker_kinged: {parlett: "cn(^2X), o1x", letter:"XZ"},
    //spy: {parlett: "2>, 2=, (1/1)>", letter:"XS"}  // no grouping
    // pieces with no notation. WinChloe supports 1400 pieces.
    //
    // TODO: pieces from http://members.shaw.ca/quadibloc/chess/ch04.htm
   
    // TODO: Can go be supported? http://news.ycombinator.com/item?id=678145

    dummy: {parlett: "~0/0", letter: "O", image:"banner"},

    custom: {parlett: "", image: "hexagon"}
};

var DEFAULT_BOARD_GROUP = "Recognized";
var DEFAULT_BOARD_NAME = "FIDE Chess";

// Saved board setups in FEN
var SAVED_BOARDS = {
    // Recognized chesses, ordered roughly chronologically and/or increasing complexity
    // http://chessvariants.org/index/mainquery.php?type=Any&orderby=LinkText&displayauthor=1&displayinventor=1&showimages=1&showtextnotes=1&listrecognizedonly=1&primarylinksonly=1&usethisheading=Recognized+Chess+Variants
    "Recognized": {
// TODO: Indian Chess (Chaturanga)
// TODO: Support Chaturanga pawns. No double move/en passant, and promotes to where started, but only if piece was captured.
// Stalemate / bare king = win for stalemating player,
//"Indian Chess (Chaturanga)": "rnekxfenr/pppppppp/8/8/8/8/PPPPPPPP/RNEKXFENR w - statemate=win",

// Shatranj (2nd known variant), except that this rule is not implemented:
// - Taking the last piece of your opponent wins, unless your opponent
//    can take your last non-king piece too, in which case the game is drawn
// Note that K v. K will result in a "draw by insufficient material" anyway, and
// bareing the king will often result in a win eventually.
// aka Iranian Chess, http://www.garagegames.com/community/blogs/view/17595
"Iranian Chess (Shatranj)":     "rnyx(lord)xfynr/x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)/8/8/8/8/X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)/RNYX(lord)XFYNR w - - rs=shatranj",

// TODO: Tamerlane Chess, Timur's game, http://en.wikipedia.org/wiki/Tamerlane_Chess and http://www.pathguy.com/chess/Tamerlan.htm http://filer.case.edu/org/cwrums/games/tamerlane.html
// TODO: Korean Chess (Changgi)
// TODO: Omega Chess
// TODO: Japanese Chess (Shogi), see http://www.crockford.com/chess/shogi.html
// TODO: Minishogi, 5x5 board, http://en.wikipedia.org/wiki/Minishogi

// Chinese Chess (Xiangqi),
"Chinese Chess (Xiangqi)": "rhex(ferz)x(general)x(ferz)ehr//1x(cannon)5x(cannon)/x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)///X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)/1X(cannon)5X(cannon)//RHEX(ferz)X(general)X(ferz)EHR w - - rs=xiangqi",

"Chinese Chess (Xiangqi, Westernized)": "rhex(ferz)x(general)x(ferz)ehr//1x(cannon)5x(cannon)/x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)///X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)//1X(cannon)5X(cannon)/RHEX(ferz)X(general)X(ferz)EHR w - - rs=xiangqiw",

// TODO: http://www.chessvariants.org/xiangqivariants.dir/yangqi.htm

// Counting rules on http://en.wikipedia.org/wiki/Makruk are not implemented
"Thai Chess (Makruk)": "rnx(silvergeneral)x(ferz)x(lord)x(silvergeneral)nr/8/x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)/8/8/X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)/8/RNX(silvergeneral)X(lord)X(ferz)X(silvergeneral)NR w - -",
"FIDE Chess": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -",
"Chess960": setup_chess960,
// TODO: pawns promote to rook,knight,queen, no double-move
"Los Alamos Chess": "rnqknr/x(losalamospawn)x(losalamospawn)x(losalamospawn)x(losalamospawn)x(losalamospawn)x(losalamospawn)/6/6/X(losalamospawn)X(losalamospawn)X(losalamospawn)X(losalamospawn)X(losalamospawn)X(losalamospawn)/RNQKNR w - - ranks=6 files=6",
"Capablanca Chess": "rnabqkbcnr/pppppppppp/8/8/8/8/PPPPPPPPPP/RNABQKBCNR w AJaj - files=10 stalemate=win rs=triple_castle",
"Berolina Chess": "rnbqkbnr/xbxbxbxbxbxbxbxb/8/8/8/8/XBXBXBXBXBXBXBXB/RNBQKBNR w KQkq -",
"Courier Chess": "rnybmkxfibynr/x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)/////X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)/RNYBMKXFIBYNR w - - files=12 ranks=8",
// Note that in this implementation, only 4-move castling is supported, but chessvariants.com describes how one, two, three, or four is supported.
"Wildebeest Chess": "rnwwx(gnu)kqbbnr/ppppppppppp///////PPPPPPPPPPP/RNWWX(gnu)KQBBNR w AKak - files=11 ranks=10 stalemate=win rs=quad_castle shredder_castle",
"Taikyoku Shogi": "5(D)5(GB)3(D)6(D)3(GB)4(D)/" + // TODO: mirror other side too!
    "(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)(P)/" + 
    "(LC)(MK)(VM)(OX)(LB)(VP)(VH)(BN)(DH)(DK)(SE)(HF)(EL)(SP)(VL)(TG)(SB)(LD)(DG)(SB)(TG)(VL)(SP)(EL)(HF)(SE)(DK)(DH)(BN)(VH)(VP)(LB)(OX)(VM)(MK)(RC)/" + 
    "(CH)(SL)(VR)(WN)(RE)(M)(SD)(HS)(GN)(OS)(EA)(BS)(SG)(LP)(T)(BE)(I)(GM)(GE)(I)(BE)(T)(LP)(SG)(BS)(EA)(OS)(GN)(HS)(SD)(M)(RE)(WN)(VR)(SL)(CH)/" + 
    "(EC)(BL)(EB)(HO)(OW)(CM)(CS)(SW)(BM)(BT)(OC)(SF)(BB)(OR)(SQ)(SN)(RD)(LI)(FE)(RD)(SN)(SQ)(OR)(BB)(SF)(OC)(BT)(BM)(SW)(CS)(CM)(OW)(HO)(EB)(VI)(EC)/" + 
    "(TC)(VW)(SX)(DO)(FH)(VB)(AB)(EW)(LH)(CK)(OM)(CC)(WS)(ES)(VS)(NT)(TF)(RM)(MT)(TF)(NT)(VS)(SU)(NB)(CC)(OM)(CK)(LH)(EW)(AB)(VB)(FH)(DO)(SX)(VW)(TC)/" + 
    "(WC)(WH)(HD)(SM)(PR)(WB)(FL)(EG)(FD)(PS)(FY)(ST)(BI)(WG)(F)(KR)(CA)(GT)(LL)(HM)(PH)(F)(WG)(BI)(ST)(FY)(PS)(FD)(EG)(FL)(WB)(PR)(SM)(HD)(WH)(WC)/" + 
    "(CI)(CE)(B)(R)(WF)(FC)(MF)(VT)(SO)(LS)(CL)(CR)(RH)(HE)(VO)(GD)(GO)(DV)(DS)(GO)(GD)(VO)(HE)(RH)(CR)(CL)(LS)(SO)(VT)(MF)(FC)(WF)(R)(B)(CE)(CI)/" + 
    "(SV)(VE)(N)(PI)(CG)(PG)(H)(O)(CN)(SA)(SR)(GL)(LN)(CT)(GS)(VD)(WL)(GG)(VG)(WL)(VD)(GS)(CT)(LN)(GL)(SR)(SA)(CN)(O)(H)(PG)(CG)(PI)(N)(VE)(SV)/" + 
    "(GC)(SI)(RN)(RW)(BG)(RO)(LT)(LE)(BO)(WD)(FP)(RB)(OK)(PC)(WA)(FI)(C)(KM)(PM)(C)(FI)(WA)(PC)(OK)(RB)(FP)(WD)(BO)(RI)(TT)(RO)(BG)(RW)(RN)(SI)(GC)/" + 
    "(RV)(WE)(MD)(FS)(CO)(RA)(FO)(MS)(RP)(RU)(SS)(GR)(RT)(BA)(BD)(WR)(S)(NK)(DE)(S)(GU)(YA)(BA)(RT)(GR)(SS)(RU)(RP)(MS)(FO)(RA)(CO)(FS)(MD)(FG)(RV)/" + 
    "(L)(TS)(RR)(W)(DM)(ME)(LO)(BC)(HR)(FR)(ED)(CD)(FT)(FK)(RS)(LG)(G)(K)(CP)(G)(RG)(RS)(FK)(FT)(WO)(ED)(FR)(HR)(BC)(LO)(ME)(DM)(W)(RR)(WT)(L)/" + 
    " w - - ranks=36 files=36",  // TODO
//TODO: http://en.wikipedia.org/wiki/Tenjiku_shogi
// TODO: Modern variants
// TODO: Ultima

    },

    "Randomized": {
"Chess960": setup_chess960,
"Chess256": setup_chess256,
"D-Chess (swap manually)": setup_dchess
    },

    "New Pieces": {
"Amazon Chess":         "rnbxvkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBXVKBNR w KQkq -",
// http://en.wikipedia.org/wiki/Breakthrough_(board_game)
// TODO: Win if promote.. have a universal leaper, but there is nothing to checkmate.
"Breakthrough": "x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)/x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)/8/8/8/8/X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)/X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru) w - - uncheckered",
"Commoner Chess":     "rnbqmbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQMBNR w KQkq -",
"Knightmate Chess":    "rmbqxrbmr/pppppppp/8/8/8/8/PPPPPPPP/RMBQXRBMR w KQkq -",
// A winning line of play for the roaylty pieces, from _The Oxford History of Board Games_ by David Parlett, pg. 192, regardless of the moves for the maharajah:
// a4 a5 a6 a7 e3 Nh3 Nf4 Bd3 O-O Qh5 Nc3 Ncd5 Ra6 b4 h3 (if M on g7) Bb2 Rfa1 Re6 Rae6 (I think this is supposed to be Raa6) Re7 Rae6 and mate the on the next move
"Maharajah and the Sepoys (black)":     "4xj3/8/8/8/8/8/PPPPPPPP/RNBQKBNR w KQ -",
// TODO: No black pawn promotion
"Maharajah and the Sepoys (white)":     "rnbqkbnr/pppppppp/8/8/8/8/8/4XJ3 w kq -",
"Milener's Chess-3 (non-random)": "rnbqkvjt/pppppppp/8/8/8/8/PPPPPPPP/RNBQKVJT w KQkq -",
"Nightrider Chess I": "r1bx(nightrider)kb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BX(nightrider)KB1R w KQkq -",
"Nightrider Chess II": "rx(nightrider)bqkbx(nightrider)r/pppppppp/8/8/8/8/PPPPPPPP/RX(nightrider)BQKBX(nightrider)R w KQkq -",
"Fox and Geese": "8/8/8/4x(ferz)/5X(goose)/2X(goose)1X(goose)/3X(goose) w - -", // geese win by stalemating fox, solution at http://www.mayhematics.com/v/gm.htm
// http://hem.passagen.se/melki9/royalpawn.htm
"Royal Pawn Chess": "rnbqmbnr/ppppx(royalpawn)ppp/8/8/8/8/PPPPX(royalpawn)PPP/RNBQMBNR w - -",
"Sniper Chess": "x(rookni)x(kniroo)x(bishkni)qkx(ensign)x(knibis)x(roobis)/pppppppp/8/8/8/8/PPPPPPPP/X(rookni)X(kniroo)X(bishkni)QKX(ensign)X(knibis)X(roobis) w KQkq -",

    //"Chess with Different Armies": {
// Chess with Different Armies http://www.chessvariants.com/unequal.dir/cwda.html
// TODO: Choose each? Colorbound Clobberers vs. Remarkable Rookies, randomized, etc.
// TODO: new pawns to promote to pieces on each board
"Colorbound Clobberers": "x(bede)x(waffle)x(fad)x(archbishop)kx(fad)x(waffle)x(bede)/x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)/8/8/8/8/X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)/X(bede)X(waffle)X(fad)X(archbishop)KX(fad)X(waffle)X(bede) w KQkq -",
"Remarkable Rookies": "x(r4)x(woodyrook)x(halfduck)ckx(halfduck)x(woodyrook)x(r4)/x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)/8/8/8/8/X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)/X(r4)X(woodyrook)X(halfduck)CKX(halfduck)X(woodyrook)X(r4) w KQkq -",
"Nutty Knights": "x(chargingrook)x(fibnif)x(chargingknight)x(colonel)kx(chargingknight)x(fibnif)x(chargingrook)/x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)/8/8/8/8/X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)/X(chargingrook)X(fibnif)X(chargingknight)X(colonel)KX(chargingknight)X(fibnif)X(chargingrook) w KQkq -",

"Amazon Army": "x(r4)nbxvkbnx(r4)/pppppppp/8/8/8/8/PPPPPPPP/X(r4)NBXVKBNX(r4) w KQkq -",
/// TODO: Cylindrical Cinders, fighting fizzes, etc.
/// http://en.wikipedia.org/wiki/Chess_with_different_armies#cite_note-2
// http://www.chessvariants.org/unequal.dir/pizza-kings.html
"Pizza Kings": "x(sausage)x(mushroom)x(pepperoni)x(meatball)kx(pepperoni)x(mushroom)x(sausage)/x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)/8/8/8/8/X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)/X(sausage)X(mushroom)X(pepperoni)X(meatball)KX(pepperoni)X(mushroom)X(sausage) w KQkq -"

    },

    "Miniature Variants": {
// See Parlett, pg. 317-318. Not all of the rules might be correct.
"7x7 Microchess-49 (Paletta, 1980)": "rbnknbr/ppppppp/7/7/7/PPPPPPP/RBNKNBR w KQkq - files=7 ranks=7",
"6x8 Microchess-48 (Paletta, 1980)": "rnqknr/1b2b/pppppp///PPPPPP/1B2B/RNQKNR w KQkq - files=6 ranks=8",
"6x6 Diana (Hopwood, 1870)": "rbnkbr/pppppp///PPPPPP/RNBKBR w KQkq - files=6 ranks=6",
"6x6 Compact Chess (Dean-Smith, 1988)": "rnkqnr/bppppb/pp2pp/PP2PP/BPPPPB/RNKQNR w KQkq - files=6 ranks=6",
"6x6 Lilliputian Chess (Dekle, 1986)": "raqkar/pppppp///PPPPPP/RAQKAR w KQkq - files=6 ranks=6",
"5x6 Petty Chess (Walker, 1930)": "qkbnr/ppppp///PPPPP/QKBNR w KQkq - files=5 ranks=6",
"8x4 Chi-Chi's Chess (Hackenberg, 1968)": "rnbqkbnr/p1ppp2p/P1PPP2P/RNBQKBNR w KQkq - files=8 ranks=4",
"5x5 Baby Chess (Gardner, 1989)": "kqbnr/ppppp//PPPPP/RNBQK w KQkq - files=5 ranks=5",
"5x5 Minichess (AISE, 1978)": "kqbnr/ppppp//PPPPP/KQBNR w KQkq - files=5 ranks=5",
"5x5 Minichess (Jacobs, 1983)": "bnrqk/ppppp//PPPPP/KQNBR w KQkq - files=5 ranks=5"
// See Parlett, pg. 319 for the rules. 
// pawns: may advance 2 squares initially
// knights: two or three squares, jumping if necessary
// bishops: move only on square of own color, ignoring those on the other
// kings: one or two squares
// castling: changing places
//"One-Dimensional Chess (Glimne)": "kqrbbnp4PNBBRQK w - - files=18 ranks=1",
    },

    "Orthodox Variants": {
// Standard chess and variants using no new pieces.  
// Sources:
// http://www.pathguy.com/chess/ChessVar.htm
// http://www.chessclub.com/helpcenter/tips/wild.html
"Advance Chess":        "rnbqkbnr/8/pppppppp/8/8/PPPPPPPP/8/RNBQKBNR w KQkq -",
"Atheist Chess": "rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RN1QK1NR w KQkq -",
"Church Chess":         "bbbbkbbb/pppppppp/8/8/8/8/PPPPPPPP/BBBBKBBB w - -",
"Corner Chess":         "4rbqk/4rb1q/4r1bb/5rrr/RRR5/BB1R4/Q1BR4/KQBR4 w - -",
"Corner Chess II":      "kbp2pbq/nrp2prn/pp4pp/8/8/PP4PP/NRP2PRN/QBP2PBK w - -",
"Corridor Chess":       "1nrqkrn1/2b2b2/1pppppp1/8/8/1PPPPPP1/2B2B2/1NRQKRN1 w - -",
"Black Begins": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR ? KQkq -",
"Desegregated Chess": "RNbqKBnr/ppPpPPPp/8/8/8/8/PPpppPpP/rnBQkBnr w KQkq -",
"Dunsany's Chess": "rnbqkbnr/pppppppp/8/8/PPPPPPPP/PPPPPPPP/PPPPPPPP/PPPPPPPP w kq -",
"Eight Kings Chess":    "kkkkkkkk/pppppppp/8/8/8/8/PPPPPPPP/KKKKKKKK w - -",
"Fianchetto Chess":     "bnrqkrnb/pppppppp/8/8/8/8/PPPPPPPP/BNRQKRNB w KQkq -",
"Fortress Chess":       "rnbqkbnr/pppppppp/ppp4/8/8/5PPP/PPPPPPPP/RNBQKBNR w KQkq -",
// TODO: White wins if captures all black's pieces
"Horde Chess":          "ppp2ppp/pppppppp/pppppppp/pppppppp/3pp3/8/PPPPPPPP/RNBQKBNR w KQ -",
"Knight Odds Chess":   "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/R1BQKBNR w KQkq -",
"Marxist Chess (DLS-CSB)":       "8/pppppppp/8/8/8/8/PPPPPPPP/8 w - -",
"Marxist Chess (2x)":       "pppppppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPPPPP w - -",
"Missionary Chess": "pppppppp/ppppqppp/8/8/4K3 w - -",
"Mind Chess": "8/8/8/8/8/8/8/8 w - -",
// chess-3 http://www.chessbase.com/newsdetail.asp?newsid=4553
// TODO: 48 unique setups
"Mongredian Chess":    "rbbqknnr/pppppppp/8/8/8/8/PPPPPPPP/RBBQKNNR w - -",
"Obama Chess": "rnbqKbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQkBNR b - -",
"Pawn's Game Chess": "rnbqkbnr/pppppppp/8/8/2PPPP2/1PP2PP1/PPPPPPPP/RNB1KBNR w KQkq -",
"Pawn Massacre Chess": "RNBQKBNR/pppppppp/8/8/8/8/PPPPPPPP/rnbqkbnr w KQkq -",
"Pawn Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPP1PP/RNBQKBNR w KQkq -",
"Pawnless Chess":      "rnbqkbnr/8/8/8/8/8/8/RNBQKBNR w KQkq -",
"Peasant's Revolt Chess I":"1nn1knn1/4p3/8/8/8/8/PPPPPPPP/4K3 w - -",
"Peasant's Revolt Chess II":"1nn1k1n1/4p3/8/8/8/8/PPPPPPPP/4K3 w - -",
"Peasant's Revolt Chess III":"1n2k1n1/2p1p3/8/8/8/8/PPPPPPPP/4K3 w - -",
"Power Chess / Wild 18":"qqqqkqqq/pppppppp/8/8/8/8/PPPPPPPP/QQQQKQQQ w - -",
"Power Chess II":       "rrbqkbrr/bbnnnnbb/pppppppp/8/8/PPPPPPPP/BBNNNNBB/RRBQKBRR w - -",
"Queen Odds Chess":    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB1KBNR w KQkq -",
"Reverso Chess":        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBKQBNR w KQkq -",
"Revolt Chess": "pppppppp/rnbqkbnr/8/8/8/8/RNBQKBNR/PPPPPPPP w KQkq -",
"Republican Chess": "rnb2bnr/pppppppp/8/8/8/8/PPPPPPPP/RNB2BNR w - -",
"Rook Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/1NBQKBNR w KQkq -",
"Royal Stables Chess":  "nnnnknnn/pppppppp/8/8/8/8/PPPPPPPP/NNNNKNNN w - -",
"Survival Chess": "nnnpnpnn/pppnnnpn/nppppppp/np4pn/np2P1pn/pp4pn/nppppppp/nnpnnnpn w - -",
"Stalemate Wins": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - stalemate=win",
"Twin Chess":           "rbqkkqbr/pppppppp/n6n/8/8/N6N/PPPPPPPP/RBQKKQBR w - -",
"Twin Chess B":         "nkbqqbkn/r2pp2r/pppppppp/8/8/PPPPPPPP/R2PP2R/NKBQQBKN w - -",
"Upside-Down Chess / Wild 5":    "RNBQKBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbqkbnr w KQkq -",
"Vegetarian Chess": "r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BQKB1R w KQkq -",
"Weak! / Seven Knights Chess":  "nnnnknnn/pppppppp/2p2p2/1pppppp1/8/8/PPPPPPPP/RNBQKBNR w - -",
"Wild Chess 7 ":        "4k3/5ppp/8/8/8/8/PPP5/3K4 w - -",
"Wild Chess 8":         "rnbqkbnr/8/8/pppppppp/PPPPPPPP/8/8/RNBQKBNR w KQkq -",
"Wild Chess 19":        "8/6k1/4p3/4N3/8/6K1/7N/8 w - -"
    },

    "Chess Openings": {
    },

    "Test Pieces": {
"Test Pawns": "8/x(rookpawn)x(dragon)x(bishoppawn)x(superpawn)x(weakpawn)x(berolinapawn)x(pawnattackrook)//2x(steward)4X(optingpawn)/4X(sergeant)1X(liapawn)/8/X(rookpawn)X(dragon)X(bishoppawn)X(superpawn)X(weakpawn)X(berolinapawn)X(pawnattackrook)P w - -",
"Test Leapers": "K/2E1Y1H1/3M/1XT1W1XG1Z/8/3Z1N/4oo/5k w - -", // TODO: antelope, flamingo
"Test Riders": "B2R4/5X(barcrider)2/4Q3/4XN3/2X(alibabariderferz)3X(stone)1/3X(crabrider)1X(warmachinerider)X(squirrelrider)1/2X(alfilrider)X(camelrider)2X(zebrarider)1/4X(girafferider)3 w - - 0 1",
"Test Complex Riders": "1X(crookedbishop)/8/3X(dummy)/4X(griffon)/7X(panda)//5X(slipbishop) w - -",
"Test Complex Riders I": "8/8/8/8/4X(crookedrook) w - -",
"Test Fore-Hoppers": "/2X(rookhopper)2x(dummy)/5X(bishopper)/4X(grasshopper)kx(dummy)//2x(dummy)1X(dummy) w - -",
"Test Line-Hoppers": "/2X(rion)2x(dummy)///2X(rion)/2x(dummy) w - -",
//TODO: "Test Line-Hoppers": "x(cannon)"
"Test Chinese Pieces": "8/8/8/3X(moa)X(moo)/3hH3/8/8/8 w - -",
"Test Amphibians": "4k/8/8/slslslsl/8/8/FFFFFFFF/4K w - -",
"Test Royalty": "x(royalrook)x(royalknight)x(royalbishop)xjkx(royalbishop)x(royalknight)x(royalrook)/pppppppp/8/8/8/8/PPPPPPPP/X(royalrook)X(royalknight)X(royalbishop)XJKX(royalbishop)X(royalknight)X(royalrook) w KQkq -",
"Test Projectiles": "x(airplane)X(airplane)4x(airplane)/X(allseeingeye)/1x(bird)/2x(bird)x(bird)x(bird)1x(bird)/3x(bird)x(bird)/3X(archerzz3)x(bird)/4X(archerzz2)X(archer)/x(frog)1X(gun)3X(rocket) w - -",
"Test Invincibles": "3x(dummy)x(dummy)/7x(nwall)/x(dummy)3x(block)1X(fortress)/4K3/5x(stone)X(fort)/8/1kX(block)1X(stone)/1X(block)x(block)3X(nwall) w - -",
"Test Consumables": "4k/pppppppp/1pppppp1/2pppp2/X(bomb)2X(superbomb)/8/PPPPPPPP/4K w - -",
"Test Diminished": "/1X(b4)5X(q4)//4X(b3)//3X(r3)X(honorablehorse)/2X(r4)/7X(q3) w - -",
"Test Mix 1": "X(airplane)x(airplane)/3x(pawnattackrook)x(caliph)x(pope)X(elephantwarmachine)/8/8/8/4S/X(lance)fwZ1X(pawnattackrook)/AcDeIFvT w - -",
"Test Mix 2": "//2/1X(silvergeneral)2X(mushroom)/3X(crab)X(wizard)/4X(barc)1X(goldgeneral)//7m w - -",
"Test Mix 3": "x(zebracamel)//3X(2moveferz)//3X(bishop)1X(2movewazirferz)/2X(2movewazir) w - -",
"Test Custom": "8/8/8/8/4X(custom)/8/8/8 w - -"
    },

    "Test Rules": {
"Test Checkmate": "r1bknbrN/pppppppp/8/8/8/8/PPPPPPPP/nRBNKB1R b - -",
"Test Stalemate":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmnv=5",
"Test Stalemate (win)":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmvn=5 stalemate=win",
"Test Stalemate (half-win)":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmvn=5 stalemate=halfwin",
"Test Stalemate (loss)":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmvn=5 stalemate=loss",
"Test Remove Check by Capture":     "4k3/1p6/2Q5/8/8/8/8/7K b - - 0 5",
"Test Double-check": "4k/3N/2Q w - - -",
"Test Promotion":     "K/1X(fiveriderpawn)1X(ccpawn)X(rrpawn)X(nnpawn)X(pkpawn)/8/PX(makrukpawn)/5X(makrukpawn).X(chinesepawn)/8/pppppppp/7k w - -",
"Test Promotion to Rook": "8/k1P5/p7/P3K3/8/8/8/8 w - - 0 53", // from http://chessteacher.110mb.com/2008/10/22/minor-promotion/
"Test Promotion to Bishop": "8/5P1k/5K1p/7P/8/8/8/8 w - - 0 51",
"Test En Passant (alone)":     "8/8/8/3pP3/8/8/8/8 w - d6",
"Test En Passant":     "rnbqkbnr/ppp2ppp/8/3pP3/3Qn/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5",
"Test En Passant into Check": "qk6/8/8/3pP3/8/8/8/7K w - d6 0 5",
"Test Lone King": "K w KQkq -",
"Test K + K":     "k7/8/K7/8/8/8/8/8 b - - 0 30",
"Test K + KQ":     "k7/8/8/8/8/8/8/5KQ1 w - d6 0 50",
"Test K + KR":     "k7/8/8/8/8/8/8/5KR1 w - d6 0 50",
"Test K + KB":     "k7/8/K7/8/8/8/8/B b - - 0 30",
"Test K + KN":     "k7/8/K7/8/8/8/8/N b - - 0 30",
"Test KB + KB opposite colors":     "k7/8/K7/8/8/8/b/B b - - 0 30",
"Test KB + KB same colors":     "k7/8/K7/8/8/8/3b/B b - - 0 30",
"Test KBB + KBB same colors":     "k7/8/K7/8/8/8/3b1b/B3B b - - 0 30",
"Test KBB + KBB opposite colors":     "k7/8/K7/8/8/8/3b1b/B2B b - - 0 30",
"Test Castling K/Q": "1k/8/8/8/8/8/8/R3K2R w KQ -",
"Test Castling Unable": "1k/8/8/8/8/8/8/R3K2R w - -",
"Test Castling Through Check Short":     "1k3r/8/8/8/8/7Q/8/R3K2R w KQ -",
"Test Castling Through Check Long":     "1k1r/8/8/8/8/7Q/8/R3K2R w KQ -",
"Test Castling Not Through Check (Rook)":     "1r/3k/8/8/8/5Q/8/R3K2R w KQ -",
"Test Castling Through Check (pawn)": "rnbqkbnr/pppp2pp/8/6N1/4p3/3B4/PPPP2pP/RNBQK2R w KQkq - 0 7",
"Test Castling out of Check":     "4r3/8/8/8/8/8/8/R3K2R w KQ -",
"Test Castling A/H king B": "1k/8/8/8/8/8/8/RK5R w AH -",
"Test Castling A/H king C": "1k/8/8/8/8/8/8/R1K4R w AH -",
"Test Castling A/H king D": "1k/8/8/8/8/8/8/R2K3R w AH -",
"Test Castling A/H king E": "1k/8/8/8/8/8/8/R3K2R w AH -",
"Test Castling A/H king F": "1k/8/8/8/8/8/8/R4K1R w AH -",
"Test Castling A/H king G": "1k/8/8/8/8/8/8/R5KR w AH -",
"Test Castling D/F king E": "1k/8/8/8/8/8/8/3RKR w DF -",
"Test Castling B/D king C": "7k/8/8/8/8/8/8/1RKR w BD -",
"Test Castling w/ Intervening Pieces":     "1k/8/8/8/8/8/8/R3KQ1R w KQ -",
"Test Only Move ":     "rnbqkbnr/ppp2ppp/8/8/8/8/PPP2PPP/RNBQKBNR w KQkq -",
"Test Disambiguation by File":     "k7/8/8/8/8/8/3N4/6N1 w - -",
"Test Disambiguation by Rank":     "k7/8/8/6N1/8/8/8/6N1 w - -",
"Test Disambiguation by File+Rank":     "k7/8/8/4N1N1/3N3N/8/3N3N/4N1N1 w - -",
"Test Disambiguation w/ 8 Queens": "3Q4/6q1/2Q5/7q/1Q6/4q3/7Q/5q2 w - -",
"Test vboard Check-Checking": "8/8/R2k2p1/3n1bp1/1p6/1P3P1P/5KP1/8 b - - 0 36",
"Test Getting out of Check": "rnbqkbnr/ppp1p1pp/4P3/3p3Q/5p2/8/PPPP1PPP/RNB1KBNR b KQkq - 0 4",
"Test Check Checking": "rnbQ1bnr/ppp1kppp/8/4p3/7q/8/PPPP1PPP/RNBQKBNR b KQ - 0 5",
"Test Parlett Move Interference": "r/8/8/1N3b2/3PP3/1P1BBN/8/8 w - - 0 17",
"Test Captures": "8/MMMMMMMM/mmmmmmmm/8/QQQQQQQQ/qqqqqqqq/NNNNNNNN/xlxlxlxlxlxlxlxl w - -",
"Test Guarding": "8/8/8/2P/3P/4B/3P/ w KQkq -",
"Test Extended Position Description": "r/8/8/1N3b2/3PP3/1P1BBN/8/8 w - - hmvc=0 fmvn=17",
"Test Bare King": "///4k//p/1P w - -"
    }
};

// Opening positions along with extended ECO codes and common names
// Extended ECO codes are from scid.eco, see http://scid.sourceforge.net/help/ECO.html
//  and http://scid.sourceforge.net/help/EPD.html
// These are listed keyed by FEN without move information, so they can be recognized
// directly from the board position, rather than the move history, allowing for easier
// transposition.
var OPENINGS = {
    // 0th level
    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -": "A00a Standard Start Position",

    // 1st level
    "rnbqkbnr/pppppppp/8/8/8/P7/1PPPPPPP/RNBQKBNR b KQkq -": "A00f Anderssen Opening",
    "rnbqkbnr/pppppppp/8/8/P7/8/1PPPPPPP/RNBQKBNR b KQkq a3": "A00e Ware Opening / Meadow Hay",
    "rnbqkbnr/pppppppp/8/8/8/N7/PPPPPPPP/R1BQKBNR b KQkq -": "A00h Durkin Opening / Sodium Attack",
    "rnbqkbnr/pppppppp/8/8/8/2N5/PPPPPPPP/R1BQKBNR b KQkq -": "A00l Van Geet (Dunst) Opening",
    "rnbqkbnr/pppppppp/8/8/8/1P6/P1PPPPPP/RNBQKBNR b KQkq -": "A01 Nimzowitsch-Larsen Attack",
    "rnbqkbnr/pppppppp/8/8/1P6/8/P1PPPPPP/RNBQKBNR b KQkq b3": "A00p Polish Opening / Orangutan",
    "rnbqkbnr/pppppppp/8/8/8/2P5/PP1PPPPP/RNBQKBNR b KQkq -": "A00i Saragossa Opening / Hempel's",
    "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq c3": "A10 English Opening",
    "rnbqkbnr/pppppppp/8/8/8/3P4/PPP1PPPP/RNBQKBNR b KQkq -": "A00j Mieses Opening",
    "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3": "A40a Queen's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/4P3/PPPP1PPP/RNBQKBNR b KQkq -": "A00k Van 't Kruijis Opening",
    "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3": "B00a King's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/5P2/PPPPP1PP/RNBQKBNR b KQkq -": "A00b Barnes Opening / Gedult's",
    "rnbqkbnr/pppppppp/8/8/5P2/8/PPPPP1PP/RNBQKBNR b KQkq f3": "A02 Bird's Opening / Dutch Attack",
    "rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -": "A04 R\u00e9ti Opening",
    "rnbqkbnr/pppppppp/8/8/8/7N/PPPPPPPP/RNBQKB1R b KQkq -": "A00g Amar Opening / Drunken Knights / Ammonia",
    "rnbqkbnr/pppppppp/8/8/8/6P1/PPPPPP1P/RNBQKBNR b KQkq -": "A00t Benko's Opening / Hungarian",
    "rnbqkbnr/pppppppp/8/8/6P1/8/PPPPPP1P/RNBQKBNR b KQkq g3": "A00n Grob's Attack",
    "rnbqkbnr/pppppppp/8/8/8/7P/PPPPPPP1/RNBQKBNR b KQkq -": "A00d Clemenz Opening",
    "rnbqkbnr/pppppppp/8/8/7P/8/PPPPPPP1/RNBQKBNR b KQkq h3": "A00c Desprez Opening / Reagen's Attack",

    // A few common 2nd level responses - not comprehensive! Keep this short.
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6": "B20 Sicilian Defense",
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq -": "B27a Sicilian Defense Main Line",
    "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6": "C20 Open Game / Mutual King's Pawn",
    "rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq d6": "B01a Scandinavian Centre Counter Game",
    "r1bqkbnr/pppppppp/2n5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B00l Nimzowitsch Defense",
    "rnbqkb1r/pppppppp/5n2/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B02a Alekhine Defense",
    "rnbqkbnr/pp1ppppp/2p5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B10a Caro-Kann Defense"

    // TODO: Ajax to load scid.eco from a server optionally, to get deeper into the
    // openings. scid.eco has 20K+ lines, not practical to load into this file.
};


// TODO: library of interesting games, in PGN format. See
// http://www.xs4all.nl/~timkr/records/records.htm and http://www.xs4all.nl/~timkr/ChessTutor/pgnview.htm


/* Global functions for jslint to recognize. TODO: move to objects? */

/*global edit_pgn restore_edit save_pgn reload_pgn load_pgn parse_pgn output_pgn_dict load_ply set_next_back_accesskeys move_link decode_ply encode_ply mv should_promote promote in_check calculate_notations disambiguate_notations calculate_moves computer_move_if_applicable would_check piece_moved unfiltered_moves filtered_moves relative_decode_direction parse_move_flags nested_flags decode_explicit_move decode_one_parlett without_dupes opposite_color set_turn set_check_message check_repetition load_notations capture_piece notation_from_piece_square forwards_vector move_piece_to_square mark_repeated_moves move_dropped_piece save_fen load_fen clear_board load_starting_position init_board name_pieces algebraic_letter piece_letter2name full_piece_prefix algebraic_piece_prefix figurine_piece_prefix pc_or_offboard pc image_path_for create_piece create_piece_by_letter highlight_moves unhighlight_all filerank2xy xy2filerank x2descriptive short_descriptive sq randint ucfirst AssertException assert enable_document_selection make_move_by_menu populate_make_a_move_list realize_vboard*/
 
function main() {
// http://o.aolcdn.com/dojo/1.0.0/dojo/cookie.xd.js
// This file is small enough to just include here (without the module provisions)
dojo.cookie=function(_2,_3,_4){var c=document.cookie;if(arguments.length==1){var _6=c.lastIndexOf(_2+"=");if(_6==-1){return null;}var _7=_6+_2.length+1;var _8=c.indexOf(";",_6+_2.length+1);if(_8==-1){_8=c.length;}return decodeURIComponent(c.substring(_7,_8));}else{_4=_4||{};_3=encodeURIComponent(_3);if(typeof (_4.expires)=="number"){var d=new Date();d.setTime(d.getTime()+(_4.expires*24*60*60*1000));_4.expires=d;}document.cookie=_2+"="+_3+(_4.expires?"; expires="+_4.expires.toUTCString():"")+(_4.path?"; path="+_4.path:"")+(_4.domain?"; domain="+_4.domain:"")+(_4.secure?"; secure":"");return null;}}

    // Log each argument individually since only the first 8586917 argument is logged
    /*
    window.log = function() {
        for (var i = 0; i < arguments.length; i += 1) {
            console.log(arguments[i]);
        }
    }*/


    // Safari and IE7: Disable text selection to stop interfering with dragging 
    enable_document_selection(false);    

    // Hide address bar. TODO: Get this working
    //setTimeout(function() { window.scrollTo(0, 1); }, 0);

    init_remote_server();

    // Let the games begin
    load_notations();
    init_board();
    init_dnd();

    // test 50 move rule (game from http://www.chessville.com/misc/History/Mad_Aussie_Trivia_Archive_12.htm)
    //load_pgn('[White "Filipowicz,A"]\n[Black "Smederevac,P"]\n[Site "Rubinstein mem 04th Polanica Zdroj (14)"]\n[Date "1966"]\n\n1. e4 e6 2. d3 Ne7 3. g3 c5 4. Bg2 Nbc6 5. Be3 b6 6. Ne2 d5 7. 0-0 d4 8. Bc1 g6 9. Nd2 Bg7 10. f4 f5 11. a3 0-0 12. e5 a5 13. a4 Ba6 14. b3 Rb8 15. Nc4 Qc7 16. Kh1 Nd5 17. Bd2 Rfd8 18. Ng1 Bf8 19. Nf3 Be7 20. h4 h5 21. Qe2 Ncb4 22. Rfc1 Bb7 23. Kh2 Bc6 24. Na3 Ra8 25. Qe1 Rdb8 26. Qg1 Qb7 27. Qf1 Kg7 28. Qh1 Qd7 29. Ne1 Ra7 30. Nf3 Rba8 31. Ne1 Bd8 32. Nf3 Rb8 33. Ne1 Bc7 34. Nf3 Rh8 35. Ng5 Bd8 36. Nf3 Be7 37. Qg1 Bb7 38. Nb5 Raa8 39. Na3 Ba6 40. Qf1 Rab8 41. Nc4 Bd8 42. Qd1 Ne7 43. Nd6 Bc7 44. Qe2 Ng8 45. Ng5 Nh6 46. Bf3 Bd8 47. Nh3 Ng4+ 48. Kg1 Be7 49. Nc4 Nd5 50. Nf2 Bb7 51. Nh3 Bc6 52. Qg2 Rhc8 53. Re1 Rc7 54. Re2 Ra7 55. Ree1 Ra6 56. Re2 Rba8 57. Ree1 R8a7 58. Na3 Ra8 59. Nc4 Nh6 60. Na3 Nf7 61. Nf2 Rd8');

    // test PGN embedded notes
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 {This opening is called the Ruy Lopez.} 3... a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    

     /* Note: chessos generates PGNs with minimal algebraic notation, sometimes, 
      * not always standard algebraic. 4. ... Bb4 should be Bxb4. Need synonym 
      * support in order to read this, or MAN support. 
      *
pgn = load_pgn(
"[Event \"ChesSOS Game\"]\n" + 
"[Site \"http://www.chessos.com\"]\n" + 
"[Date \"2009.03.18\"]\n" + 
"[Round \"-\"]\n" + 
"[White \"Dema9o9ue\"]\n" + 
"[Black \"shellreef\"]\n" + 
"[WhiteElo \"1500\"]\n" + 
"[BlackElo \"1500\"]\n" + 
"[Result \"0-1\"]\n" + 
"[URL \"http://www.chessos.com/p/?m=board" + AMP + "g=15722\"]\n" + 
"\n" + 
"1. b4 e5 2. Nc3 Bb4 3. a3 Bc3 4. dxc3 Nf6 5. h3 O-O 6. f3 d5 \n" + 
"7. e3 Nc6 8. a4 Qd6 9. Ba3 Qd8 10. g4 g5 11. h4 gxh4 12. Rh4 \n" + 
"Ne4 13. fxe4 Qh4 14. Ke2 Bg4 15. Nf3 Qh2 16. Kd3 dxe4 17. Ke4 \n" + 
"f5 18. Kd5 Rad8 19. Ke6 Qh6 \n" + 
"0-1");*/

     /* TODO: support 1.move in addition to 1. move  */
     /* TODO: support [White "Foo"][Black "Bar"], without newlines. Ignore whitespace. */
     /*
     pgn = load_pgn("[Event \"Berlin\"]\n" + 
"[Site \"?\"]\n" + 
"[Date \"1842\"]\n" + 
"[Round \"?\"]\n" + 
"[White \"Hanstein\"]\n" + 
"[Black \"Von der Lasa\"]\n" + 
"[Result \"1-0\"]\n" + 
"\n" + 
"1.e4 e5 2.f4 exf4 3.Nf3 g5 4.Bc4 Bg7 5.d4 d6 6.O-O h6 7.c3 Ne7 8.h4 Ng6\n" + 
"9.h5 Ne7 10.g3 fxg3 11.Nxg5 hxg5 12.Bxf7+ Kd7 13.Bxg5 c6 14.e5 d5\n" + 
"15.e6+ Kc7 16.Bf4+ Kb6 17.Qb3+ Ka6 18.Qa3+ Kb6 19.b4 a5 20.Bxb8 Nf5\n" + 
"21.Rxf5 Qh4 22.Qb2 Rxb8 23.b5 Qe4 24.Na3 Qxf5 25.bxc6+ Kc7 26.Nb5+\n" + 
"Kxc6 27.Na7+ Kc7 28.Nb5+ Kd8 29.Rf1 Qh3 30.e7+ Kxe7 31.Qa3+ Kd8\n" + 
"32.Qd6+ Qd7 33.Qb6+ Ke7 34.Re1+ Kxf7 35.Qg6+ Kg8 36.Re8+ Qxe8\n" + 
"37.Qxe8+ Kh7 38.Qg6+ Kg8 39.Qd6 Ra8 40.Qxd5+ Kh7 41.Qe4+ Kg8\n" + 
"42.Qe8+ Kh7 43.Qg6+ Kg8 44.Nc7 Ra6 45.Nxa6 bxa6 46.h6 Rxh6 47.Qe8+\n" + 
"Bf8 48.Qxc8 Kf7 49.Kg2 Bd6 50.Qb7+ Ke8 51.Qc6+ Kf8 52.c4 Rf6 53.c5\n" + 
"Rf2+ 54.Kg1 Bf4 55.Qf6+ Ke8 56.d5 Kd7 57.Qf7+ Kc8 58.Qe8+ Kc7\n" + 
"59.Qe7+ Kb8 60.c6 1-0");*/


}

//// PGN (PORTABLE GAME NOTATION) FUNCTIONS

// Load the chess notations into the input/output notation select boxes
function load_notations()
{
    var menu = dojo.byId("output_notation");

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var name = AVAILABLE_NOTATIONS[notation];

            menu.appendChild(dojo.create("option", {value:notation, innerHTML:name}));
        }
    }

    menu.selectedIndex = 0;
}

// Open a mail message with a link to the board state
// If get_text, then return the email body instead
function email_board(get_text)
{
    var to, subject, body, url, dots, link, link_text, ply, ply_info;
    
    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fmvn) - 1;
    ply_info = decode_ply(ply);

    to = "shellreef@gmail.com";
    subject = "Chess game";
    dots = ply_info.color ? (ply_info.color === "black" ? "... " : " ") : "";

    link = dojo.byId("copyable_link").href;
    link_text = GAME_STATE.made_moves[ply] ? GAME_STATE.made_moves[ply].notations[PREFS.output_notation] : "*";
    // Note: IE ActiveXObject for Outlook: http://www.webdeveloper.com/forum/showthread.php?t=176548
    // Got an automation error when I tried it, but it could supposedly allow HTML bodies on Windows
    //body = ply_info.fmvn + ". " + dots + '<a href="' + link + '">' + link_text + '</a>';
    // Plain text
    body = ply_info.fmvn + ". " + dots + link_text + " <" + link + ">";

    if (get_text) {
        return body;
    }

    url = "mailto:" + encodeURIComponent(to) + 
        "?subject=" + encodeURIComponent(subject) + 
        "&body=" + encodeURIComponent(body);
    window.open(url);
}

// Make the PGN content editable (not to be confused with edible).
var ORIGINAL_UI_HTML;
function edit_pgn()
{
    var game_ui = dojo.byId("game_ui");

    ORIGINAL_UI_HTML = game_ui.innerHTML;

    game_ui.innerHTML = "<textarea id='edited_pgn' name='edited_pgn' cols='80' rows='35'>" + escape_html(save_pgn()) + 
        "<\/textarea>" + 
        "<button type='button' name='ok' accesskey='k' " + 
        "onclick='reload_pgn()'>OK<\/button>" +
        "<button type='button' name='cancel' onclick='restore_edit()' accesskey='x'>Cancel<\/button>";

    dojo.byId("edited_pgn").focus();
}

// Restore the game interface, removing the edit area.
function restore_edit()
{
    dojo.byId("game_ui").innerHTML = ORIGINAL_UI_HTML;
}

// Return a string of color-coded captured piece codes.
function export_captured()
{
    var captureds = [];

    for (var i = 0; i < GAME_STATE.captured.white.length; i += 1) {
        var p = GAME_STATE.captured.white[i];
        captureds.push(color_piece_prefix(p));
    }
    for (i = 0; i < GAME_STATE.captured.black.length; i += 1) {
        var p = GAME_STATE.captured.black[i];
        captureds.push(color_piece_prefix(p));
    }

    return captureds.join("");
}


// Import a color-coded string of captured pieces from export_captured() into GAME_STATE
function import_captured(captured)
{
    GAME_STATE.captured = {white:[], black:[]};

    if (!captured) {
        return;
    }

    for (var i = 0; i < captured.length; i += 1) {
        var length = piece_code_length(captured.substr(i));
        var letter = captured.substr(i, length);
        i += length - 1;

        var decoded_piece = decode_piece_letter(letter);
        GAME_STATE.captured[decoded_piece.color].push(decoded_piece);
    }
}

// Export game as PGN.
function save_pgn()
{
    var pgns = [], dict, captured;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
  
    // PGN header information
    dict = {};
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var elt = dojo.byId("PGN_" + tag);

        if (elt.style.display !== "none") {
            dict[tag] = elt.innerHTML;
        }
    }

    // Non-standard: captured pieces
    captured = export_captured();
    if (captured !== "") {
        dict.Captured = captured;
    }

    // Generate move text (not in a tag) 
    var move_texts = [];
    for (var ply = 1; ply < GAME_STATE.made_moves.length; ply += 1) {
        var made = GAME_STATE.made_moves[ply];
        if (!made) {
            // Missing move, for one reason or another. Game started late?
            continue;
        }

        var ply_info = decode_ply(ply);

        if (ply_info.color === "white") {
            move_texts.push(ply_info.fmvn + ". ");
        }
        // TODO: include +, #, ?, !, $n notations
        move_texts.push(made.notations.SAN);
        move_texts.push(" ");
    }

    pgns.push(output_pgn_dict(dict));
    pgns.push("");
    pgns.push(move_texts.join("") + (GAME_STATE.ended ? " " + GAME_STATE.ended : ""));

    return pgns.join("\n");
}

// Reload PGN after editing it.
function reload_pgn()
{
    var pgn = form_value("edited_pgn");

    restore_edit();

    load_pgn(pgn);
}

// Load a game from a URL, at the given textual offset
function load_pgn_from_url(url, offset)
{
    dojo.xhrGet({
        url: url,
        load: function(text) {
                load_pgn(text.substring(offset));
                dojo.byId("game-browser").style.display = "none";
            },
        error: function(text) {
                alert("load_pgn_from_url(" + url + ", " + offset + "): xhrGet error: " + text);
            }
        });
}

// Load Portable Game Notation data
// TODO: support a tag for captured pieces
// TODO: support tags for FEN at each move so don't need to compute ("Fast-FEN"). This is
//  especially important for quickly loading remote games. Iterate through FEN-# tags and
//  populate GAME_STATE.position_after
// TODO: http://www.mafiascum.net/wiki/index.php?title=Chess
function load_pgn(pgn)
{
    var games = parse_pgn(pgn);
    var game;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
    var time_started = new Date().getTime();
    var fast_fen = false;

    // TODO: UI to list all games in a PGN and pick one to load, move out parsing from this function
    assert(games.length === 1,
            "load_pgn(" + pgn + "): multiple games (" + games.length + ") found, but only one can be loaded at a time");

    game = games[0];

    // Header
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var node = dojo.byId("PGN_" + tag);

        assert(node, "load_pgn(" + pgn + "): no element for tag " + tag);

        if (game[tag] && game[tag].substr(0, 1) !== "?") {
            var value = game[tag];

            node.style.display = "";

            node.innerHTML = value;

            dojo.query(".show_" + tag).forEach(function(node) {
                    node.style.display = "";
                });
        } else {
            node.style.display = "none";
            dojo.query(".show_" + tag).forEach(function(node) {
                    node.style.display = "none";
                });
        }
    }

    // Starting position
    load_fen(game.FEN);
    GAME_STATE.position_after[0] = game.FEN;

    // Captured pieces
    if (game.Captured) {
        import_captured(game.Captured);
        update_captured_piece_images();
    }

    // Does this PGN have "FastFEN" tags? FEN-<ply> stores the  board state after 
    // each ply, so it loads faster, without having to replay each move.
    fast_fen = !!game["FEN-1"];

    // Movetext given in SAN
    GAME_STATE.annotations = [];
    for (ply = 1; ply < game.moves.length; ply += 1) {
        var move = game.moves[ply];

        if (fast_fen) {
            var fen = game["FEN-" + ply];

            if (!fen) {
                console.log("Warning: FastFEN: tag missing: FEN-" + ply);
                continue;
            }

            GAME_STATE.position_after[ply] = fen;
           
            // TODO: all other notations; all other move info! Necessary for 
            // full fidelity in FastFEN.
            info = {notations:{SAN:move}};
            GAME_STATE.made_moves[ply] = info;

            // Adds to GAME_STATE.position_moves
            check_repetition(ply, fen);
            // TODO: populate GAME_STATE.move_annotations from movetext
        } else {
            mv(move, true);

            GAME_STATE.annotations[ply] = game.move_annotations[ply];
        }
    }

    realize_vboard();

    populate_make_a_move_list();
    show_move_history();

    // Benchmark
    var time_took = new Date().getTime() - time_started;
    if (window.console) {
        console.log("load_pgn took " + time_took + " ms");
    }
}

// Parse PGN into an array of dictionaries, one dictionary per game.
function parse_pgn(pgn)
{
    var dict = {};
    var dicts = [dict];
    var move_texts = [];

    // DOS-style ^M newline
    pgn = pgn.replace("\r", "\n");

    // Parse headers into dictionaries
    for (var i = 0; i < pgn.length; i += 1) {
        var ch = pgn.charAt(i);

        // Tag
        if (ch === "[") {
            var key, start, quoted;

            // Read tag key name
            for (i += 1, start = i; pgn.charAt(i) !== " "; i += 1) {
                assert(i < pgn.length && pgn.charAt(i) !== "]",
                    "parse_pgn(" + pgn + "), at " + i + ", tag without space, like [foo] instead of [foo bar]");
            }
            key = pgn.substring(start, i);

            // Read value, terminated by end of tag. It can be quoted, which
            // allows for the value to contain the ] character.
            quoted = false;
            for (i += 1, start = i; !quoted ? pgn.charAt(i) !== "]" : true; i += 1) {
                if (pgn.charAt(i) === '"') {
                    quoted = !quoted;
                }

                assert(i < pgn.length, 
                    "parse_pgn(" + pgn + "), at " + i + ", tag value for " + key + " without ]");
            }
            value = pgn.substring(start, i);
            // Dequote value, as the quotes were only there for including ] characters
            if (value.charAt(0) === '"' && value.charAt(value.length - 1) == '"') {
                value = value.substr(1, value.length - 2);
            }

            if (dict[key]) {
                // Duplicate key means this is a new game
                dict.move_text = move_texts.join("");
                dict = {};
                move_texts = [];
                dicts.push(dict);
            }
            dict[key] = value;

        } else if (ch === "\n") {
            move_texts.push(" ");
        } else {
            move_texts.push(ch);
        }
    }
    dict.move_text = move_texts.join("");

    // Process each game, parsing move text
    for (var k = 0; k < dicts.length; k += 1) {
        dict = dicts[k];

        // Standard FEN
        if (!dict.FEN) {
            dict.FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
            dict.SetUp = 1;
        }

        // Parse move text
        var tokens = dict.move_text.split(" ");
        delete dict.move_text;  // not for anyone but this function
        var fmvn = 1, outcome, moves = [], move_annotations = [], color = "white";
        var in_comment = false, comment = [];

        for (i = 0; i < tokens.length; i += 1) {
            var token = tokens[i];
            var ply = encode_ply(color, fmvn);

            if (token === "") {
                // Skip
            } else if (token.substr(0, 1) === "{") {
                in_comment = true;
                comment.push(token.substring(1));
            } else if (in_comment) {
                if (token.substr(token.length - 1) === "}") {
                    comment.push(token.substr(0, token.length - 1));

                    in_comment = false;

                    if (!move_annotations[ply]) {
                        move_annotations[ply] = [];
                    }
                    move_annotations[ply].push(comment.join(" "));
                    comment = [];
                }  else {
                    comment.push(token);
                }
            } else if (token.charAt(0) === "$") {
                // NAG, Numerical Annotation Glyph
                if (!move_annotations[ply]) {
                    move_annotations[ply] = [];
                }
                move_annotations[ply].push(token);
            } else if (token.substring(token.length - 1) === ".") {
                fmvn = parseInt(token, 10);

                // 3... means black moves
                if (token.substring(token.length - 3) === "...") {
                    color = "black";
                } else {
                    color = "white";
                }
            } else if (token === "1-0") {
                outcome = "White wins";
            } else if (token === "0-1") {
                outcome = "Black wins";
            } else if (token === "1/2-1/2") {
                outcome = "Draw";
            } else if (token === "*") { 
                outcome = "(In progress)";
            } else if (token.match(/^[\r\n ]+$/)) {
                // Ignore whitespace
                continue;
            } else {
                // Move 
                // TODO: handle #, + for checkmate and check, part of move
                // and TODO: handle ?, !, ??, !?, etc. in move_annotations

                if (moves[ply] === undefined) {
                    // White's move
                    moves[ply] = token;
                } else {
                    // White has already moved, now it is black's turn for this fmvn.
                    // The color has to be alternated here, not just after reading 
                    // white's move, since white could have arbitrarily many annotations
                    // associated with the ply, following the move text.
                    color = opposite_color(color);
                    ply = encode_ply(color, fmvn);

                    moves[ply] = token;
                } 
            }
        }

        dict.outcome = outcome;
        dict.moves = moves;
        dict.move_annotations = move_annotations;
    }

    return dicts;
}

// Export a PGN tag dictionary to PGN format, opposite of parse_pgn.
function output_pgn_dict(dict)
{
    var lines, quoted_value, have_key, keys;

    // PGN Seven Tag Roster (STR) appears first
    keys = ["Event", "Site", "Date", "Round", "White", "Black", "Result"];
    have_key = {Event:1, Site:1, Date:1, Round:1, White:1, Black:1, Result:1};

    // Other keys
    for (var key in dict) {
        if (dict.hasOwnProperty(key)) {
            if (!have_key[key]) {
                keys.push(key);
                have_key[key] = 1;
            }
        }
    }

    lines = [];
    for (var i = 0; i < keys.length; i += 1) {
        var key = keys[i];
        var value = dict[key];

        if (value === undefined) {
            value = "?";
        }

        // TODO: unparenthetize, uncommaify, etc. .. or just set attributes
        // to exactly what we want in load_pgn(), then fetch it.
        // TODO: rules for quoting values?
        quoted_value = '"' + value + '"';
        lines.push("[" + key + " " + quoted_value + "]");
    }

    return lines.join("\n");
}


// Load a move by ply. Used to navigate to past moves.
function load_ply(ply)
{
    // TODO: would be cool to be able to also decode
    // color + fullmove number, for ease of human use.
    // Make "1." be ply 1, and "1..." or "1. ..." be ply 2.
    // Maybe make it a user function, go()
    
    dojo.query("a.active_move").removeClass("active_move");

    load_fen(GAME_STATE.position_after[ply], true);

    dojo.addClass(dojo.byId("ply_" + ply), "active_move");

    set_next_back_accesskeys(ply);
   
    unhighlight_all();

    if (ply !== 0) {
        highlight_recent_move(GAME_STATE.made_moves[ply].from_square, 
                GAME_STATE.made_moves[ply].square);
    }
}

// Setup accesskeys for next and back given the current ply.
function set_next_back_accesskeys(ply)
{
    var next_link, prev_link, last;

    dojo.query("a.accessible_move").forEach(function(x) {
            dojo.removeClass(x, "accessible_move");
            x.removeAttribute("accesskey");
        });


    // Note: first/last keys won't work on the 1st and penultimate move,
    // since the accesskey attributes are overwritten by the next/prev!
    // Note2: HTML5 allows multiple, space-separated accesskeys, which would solve this problem:
    // http://www.whatwg.org/specs/web-apps/current-work/#the-accesskey-attribute
    // "If specified, the value must be an ordered set of unique space-separated tokens, each of which must be exactly one Unicode code point in length."

    // first
    dojo.byId("ply_0").setAttribute("accesskey", ";"); // ctrl+option+;

    // last
    last = dojo.byId("ply_" + (GAME_STATE.made_moves.length - 1));
    if (last) {
        last.setAttribute("accesskey", "'"); // ctrl+option+,
    }
  
    // next
    next_link = dojo.byId("ply_" + (ply + 1));
    if (next_link) {
        // Not the last move.. there is another one ahead.
        next_link.setAttribute("accesskey", ".");       // ctrl+option+.
        dojo.addClass(next_link, "accessible_move");
    }

    prev_link = dojo.byId("ply_" + (ply - 1));

    // previous
    if (prev_link) {
        prev_link.setAttribute("accesskey", ",");       // ctrl+option+,
        dojo.addClass(prev_link, "accessible_move");
    }
}

// Make a link to a ply, which can be clicked to load the board after this move was made.
function move_link(ply, text)
{
    return '<a id="ply_' + ply + '" class="active_move" ' +
        'href="#" onclick="load_ply(' + 
            ply +
        ')">' + text + "<\/a>";
}

// Decode ply number to color and fullmove number.
function decode_ply(ply)
{
    var color, fmvn;

    color = (ply % 2 === 1) ? "white" : "black";
    fmvn = Math.ceil(ply / 2);

    return {color: color, fmvn: fmvn};
}

// Encode color and fullmove number back to ply. Ply is useful for 
// arrays of moves, since it is one integer, instead of integer+color.
function encode_ply(color, fmvn)
{
    var ply;

    ply = fmvn * 2;
    ply -= (color === "white" ? 1 : 0);

    return ply;
}

//// USER FUNCTIONS

// Make a move using any notation. Useful to use for moving within the JavaScript
// console (Develop -> Show Error Console in Safari), if you prefer CLI over GUI,
// and computer moves also use this function. 
// If is_not_immediate is true, then the UI is not updated after the move (the
// piece images are not physically moved, nor animated); useful for quickly making 
// many moves without UI slowness.
// Examples:
// mv("e4")
// mv("P-K4")
function mv(alg_move, is_not_immediate)
{
    var piece_square, piece, square;

    if (!alg_move) {
        assert(VALID_MOVE_NOTATIONS, "mv(" + alg_move + "): called with VALID_MOVE_NOTATIONS false");
        return own_properties(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    }

    // Find move in precalculated notations. 
    piece_square = find_legal_move(alg_move) || find_legal_move(alg_move, true);

    // Illegal move.. This can happen on over-the-board games where the
    // move is not recognized as illegal, or with buggy software.
    if (!piece_square) {
        // Give some context of what happened.
        realize_vboard();
        show_move_history();

        assert(false, "mv(" + alg_move + "): illegal move");
    }

    // TODO: do some moving animation, optionally (make two functions)
 
    // There is only one choice..
    var promote_to = piece_square.move.promote_to;
    var choices = {};
    choices[promote_to] = piece_square;

    execute_move(promote_to, choices, false, !is_not_immediate);
}

// Find a legal move, given the move text, precalculated already with calculate_notations().
// If lenient, replace or replace superfluous characters
function find_legal_move(text, lenient)
{
    var piece_square;

    if (lenient) {
        // Accept digits, but prefer the letter oh.
        text = text.replace("0-0-0", "O-O-O").replace("0-0", "O-O");

        // Check/mate indicators not part of move.
        text = text.replace("+", "").replace("#", "");

        // Promotions, e1=Q, not needed, e1Q is fine
        text = text.replace("=", "")
    }

    // Prefer these move notations, in this order.
    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            if (notation === "descr" || notation === "adesc") {
                text = text.replace(/Kt/g, "N");
            }

            piece_square = VALID_MOVE_NOTATIONS[notation][text];

            if (piece_square) {
                // Found one.
                break;
            }
        }
    }

    // Allow alternate, non-canonical forms. These are overly-descriptive
    // notations for ambiguous move notation formats. For example, in SAN
    // the canonical form of a particularly bad opening move is Nh3, but 
    // it can also be written as N1h3 or Ngh3 or Ng1h3, even though this longer
    // form is only supposed to be used when Nh3 is ambiguous, and it is not
    // standard. But you might see it, so allow it.
    if (!piece_square) {
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                if (notation === "descr" || notation === "adesc") {
                    text = text.replace(/Kt/g, "N");
                }

                piece_square = ALT_MOVE_NOTATIONS[notation][text];

                if (piece_square) {
                    //console.log("Warning: non-canonical move notation: ", notation);
                    break;
                }
            }
        }
    }

    if (piece_square) {
        // Find move in all other notations
        // TODO: avoid calling get_notations() which loops; the answer should be above
        piece_square.notations = get_notations(piece_square.piece,
                piece_square.square, 
                piece_square.move.promote_to)[piece_square.move.promote_to].notations;
    }

    return piece_square;
}
 
//// SPECIAL MOVE FUNCTIONS

// Return whether a piece should be promoted
function should_promote(piece)
{
    var square, relative_rank, promotion_rank;

    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    square = piece.square;

    // Get rank from player's perspective (as in descriptive notation, not algebraic)
    relative_rank = GAME_STATE.active_color === "white" ? square.y : (GAME_STATE.ranks + 1) - square.y;

    // Default to last rank
    promotion_rank = PIECE_TYPES[piece.type].promotion_rank || GAME_STATE.ranks;

    return relative_rank === promotion_rank;
}

// Return whether the move would cause the piece to promote
function would_promote(piece, move)
{
    var relative_rank, promotion_rank;

    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

     // Get rank from player's perspective (as in descriptive notation, not algebraic)
    relative_rank = GAME_STATE.active_color === "white" ? move.y : (GAME_STATE.ranks + 1) - move.y;

    // Default to last rank
    promotion_rank = PIECE_TYPES[piece.type].promotion_rank || GAME_STATE.ranks;

    return relative_rank === promotion_rank;
}


// Finish up a promotion move.
function promote(piece, square, type, notation, is_immediate)
{
    // TODO: Puff out, or fade in from new to old piece. Is there an
    // effect that can fade from one image to another? Like IE page transitions.
    // http://sachiniscool.blogspot.com/2006/01/implementing-page-transitions-in.html
    // ... except when changing images. Safari has CSS animations.
    // or try CSS transitions, see CSS at the top of this document.
    //piece.style.background = image_path_for(promotes_to, piece.color);
    // or TODO: create another img, same place same time, change opacity to reveal it
    // but this leaves the old image behind..
    piece.type = type;

    dojo.byId("promote_container").style.display = "none";

    // TODO: call with a correct tieback. Re-find it?
    var tieback = get_notations(piece, square, type);

    finish_up_move(tieback, is_immediate, type);
}

// Change a piece to whatever it promotes to.
function ask_to_promote(piece, tieback, is_immediate)
{
    var element, container, choice;

    realize_vboard();

    // Clear previous container
    var container = dojo.byId("promote_container");

    while(container.firstChild) {
        container.removeChild(container.firstChild);
    }

    // Create clickable promotion pieces
    for (var type in tieback) {
        if (tieback.hasOwnProperty(type)) {
            // The move the user selected that will be made
            var notation = tieback[type].notations[PREFS.output_notation];

            // Create a faux piece to click on
            element = create_piece(piece.color, type, true);

            // TODO: pass this via the closure instead of through the DOM
            dojo.attr(element, "piece_type", type);
            dojo.attr(element, "notation", notation);

            element.onclick = function() {
                // Finishes up the move
                promote(piece, tieback[type].square, dojo.attr(this, "piece_type"), dojo.attr(this, "notation"), is_immediate);
            };
            container.appendChild(element);
        }
    }

    container.style.display = "";

}

//// VALID MOVE FUNCTIONS
//
// TODO: step through moves, like on http://www.pgnview.com/ (jspgnviewer) as used on http://www.zenpawn.com/chessblog/

// Check if any royal pieces of victim_color are being attacked; that is:
// victim_color's royal pieces could be captured after any of all_moves.
function in_check(victim_color, all_moves)
{
    var royals;
    var attacked = 0;

    // Pieces that can't be captured and need to move if attacked
    royals = [];
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var piece;

            piece = VBOARD[x][y].piece;

            if (piece && PIECE_TYPES[piece.type].royal) {
                royals.push(piece);
            }
        }
    }

    // Attack the royal pieces?
    for (var filerank in all_moves) {
        if (all_moves.hasOwnProperty(filerank)) {
            var moves = all_moves[filerank];

            dojo.forEach(moves, function(move) {
                dojo.forEach(royals, function(royal) {
                    var square = royal.square;

                    if (move.x === square.x && move.y === square.y) { 
                        // Being attacked!
                        //console.log("CHECKED BY",piece,filerank,xy2filerank(move));
                        attacked += 1;  // number of times checked (check, double-check, triple-check, quadruple-check, etc.)
                    }
                });
            });
        }
    }

    return attacked;
}

// Calculate and save the move notations for a move.
// Note: only do this if not hypothetical.
function calculate_notations(color, piece, moves, starting_filerank, ps, square_from)
{
    dojo.forEach(moves, function(move) {
        var square = VBOARD[move.x][move.y];

        // Building blocks
        var dest_file = x2file(move.x);                         // e
        var dest_rank = y2rank(move.y);                         // 4
        var dest_filerank = dest_file + dest_rank;              // e4
        var dest_y_from_perspective = y_from_perspective(color, move.y);
        // starting_filerank (passed in as parameter)           // e2
        var starting = filerank2xy(starting_filerank);          // {x:5, y:2}
        var starting_file = x2file(starting.x);                 // e
        var starting_rank = y2rank(starting.y);                 // 2
        var starting_y_from_perspective = y_from_perspective(color, starting.y);                    // 2

        var descriptive_origin_file = x2descriptive(starting.x);                                    // K
        var descriptive_origin_rank = y_from_perspective(color, starting.y).toString();             // 2
        var descriptive_origin = descriptive_origin_file + descriptive_origin_rank;                 // K2

        var descriptive_dest_file = x2descriptive(move.x);                                          // K
        var descriptive_dest_rank = y_from_perspective(color, move.y).toString();                   // 4
        var descriptive_dest = descriptive_dest_file + descriptive_dest_rank;                       // K4

        var adescriptive_dest_rank = y_from_perspective(color, move.y).toString();                  // 4
        var adescriptive_dest = dest_file + adescriptive_dest_rank;                                 // e4
        var adescriptive_origin_rank = y_from_perspective(color, move.y).toString();                // 2
        var adescriptive_origin = starting_file + adescriptive_origin_rank;                         // e2



        var capture_x;                  // x/blank
        var capture_slash;              // slash/blank
        var capture_or_dash;            // x/-
        var captured_letter = "";       // capital letter of piece, P for pawn, etc. or blank
        var captured_colon_letter = ""; // colon if captured, then piece letter if not pawn
        var captured_piece = move.capture; 

        var promote_or_blank = "";      // Q/blank
        var promote_figurine = "";      // ♕/blank
        var promote_iccf = "";          // 1/blank
        var promote_paren = "";         // (Q)/blank

        if (move.promote_to) {
            var promote_piece = {type:move.promote_to};

            promote_or_blank = full_piece_prefix(promote_piece);
            promote_figurine = figurine_piece_prefix(GAME_STATE.active_color, promote_piece);
            promote_iccf = PIECE_TYPES[move.promote_to].iccf_number;
            promote_paren = "(" + promote_or_blank + ")";
        }

        if (captured_piece) {
            capture_x = "x";
            capture_slash = "/";
            capture_or_dash = "x";
            captured_letter = full_piece_prefix(captured_piece);
            captured_colon_letter = ":" + (captured_letter === "P" ? "": captured_letter);
        } else {
            capture_or_dash = "-";
            capture_x = "";
            capture_slash = "";
            captured_letter = "";
            captured_colon_letter = "";
        }


        // Compute notations: SAN, FAN, MAN, LAN, RAN, CRAN and also descriptive.
        // But first check if the move text was overridden in decode_one_parlett(), for the
        // notations where it can be overridden. Not all have special notation for castling.
        if (move.notation_override) {
            // Override notation; used for special moves (castling)
            // Note: not all notations have special notation for castling.
            ps.SAN.push([piece, square, [move.notation_override], move]);
            ps.LAN.push([piece, square, [move.notation_override], move]);
            ps.MAN.push([piece, square, [move.notation_override], move]);
            ps.RAN.push([piece, square, [move.notation_override], move]);
            ps.CRAN.push([piece, square, [move.notation_override], move]);
            ps.descr.push([piece, square, [move.notation_override], move]);
            ps.adesc.push([piece, square, [move.notation_override], move]);
        } else {
            var algs, figurine_prefix, algebraic_prefix, piece_letter, minimal_algs;

            if (capture_x === "x" && piece.type === "pawn") {
                // Pawn captures begin with file of pawn.
                algs = [starting_file + capture_x + dest_filerank]; // ?xd5
            } else {
                algs = [
                    capture_x + dest_filerank,                      // ?f3
                    starting_file + capture_x + dest_filerank,      // ?gf3
                    starting_rank + capture_x + dest_filerank,      // ?1f3
                    starting_filerank + capture_x + dest_filerank   // ?g1f3
                ];
            }

            piece_letter = full_piece_prefix(piece);               // P, N, etc.
            algebraic_prefix = algebraic_piece_prefix(piece);      // blank, N, etc.
            figurine_prefix = figurine_piece_prefix(color, piece); // ♟, ♞, ♙, ♘, etc.

            ps.SAN.push([piece, square, dojo.map(algs, function(a) { return algebraic_prefix + a + promote_or_blank; }), move]);  // N??
            ps.FAN.push([piece, square, dojo.map(algs, function(a) { return figurine_prefix + a + promote_figurine; }), move]);   // ♘??

            // Minimal notation, supposedly used in Informant
            minimal_algs = [
                algebraic_prefix + dest_filerank + promote_or_blank,                      // ?f3
                algebraic_prefix + starting_file + dest_filerank + promote_or_blank,      // ?gf3
                algebraic_prefix + starting_rank + dest_filerank + promote_or_blank,      // ?1f3
                algebraic_prefix + starting_filerank + dest_filerank + promote_or_blank]; // ?g1f3
            ps.MAN.push([piece, square, minimal_algs, move]);

            ps.LAN.push([piece, square, [algebraic_prefix + starting_filerank + 
                    capture_or_dash + dest_filerank + promote_or_blank], move]);

            // TODO: Find out for sure how promotions are shown in RAN
            ps.RAN.push([piece, square, [algebraic_prefix + starting_filerank + capture_or_dash + 
                captured_letter + dest_filerank + promote_or_blank], move]);

            // Best online documentation I could find on CRAN: 
            //  http://main.uschess.org/forums/viewtopic.php?f=2&t=1428&start=30
            // Always gives origin square filerank, then only non-redundant file/rank of dest square
            // Uses ':' for capture instead of 'x', and piece letter isn't given if pawn
            // Full description will have to wait until I receive the book
            //  http://www.amazon.com/Play-Stronger-Chess-Examining-Chess960/dp/0977452107
            ps.CRAN.push([piece, square, [
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_filerank + promote_or_blank,  // Rd3:d7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_file + promote_or_blank,      // Rd3:7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_rank + promote_or_blank       // Rd3:e
                ], move]);

            // English descriptive notation
            // TODO: 
            // - alt_letter (Kt for knight instead of N) and
            //   alt_descriptive_dest (QKt1 for b1 instead of QN1) - currently, Kt is preprocessed to N in mv()
            //   would be nice to have an option to prefer Kt over N, for using old books (though N/Kt would be synonyms)
            // - allow slashes in addition to parenthesises, or maybe not, since would be shorter and therefore preferred
 
            // Descriptive vs algebraic is like imperial vs. metric units, in some ways. Descriptive
            // is from each player's perspective, so 1. P-K4 P-K4 is easily recognizable as the same
            // move from both players, more readily than 1. e4 e5. And 2. PxP PxP more clearly shows
            // a pawn trade than 10. exd5 cxd5. Smith notation shows the latter, too, but the coordinates
            // are still not symmetric from each player's perspective. I like descriptive. Problem is
            // just that it needs to be disambiguated often, algebraic less so.
            // This paper mentions how a book on openings for black showed all of the diagrams from
            // white's perspective: http://www.castlelong.com/essay/Essay_HSym_fd47b_Doc_Prn.PDF
            // -- it discusses symmetric figurines, interesting. Although it says algebraic is superior.
          
            var piece_name = piece.descriptive_name;
            var short_piece_name = short_descriptive(piece_name);
            var short_descriptive_dest = short_descriptive(descriptive_dest_file) + descriptive_dest_rank;

            var piece_aname = piece.adescriptive_name;

            if (capture_or_dash === "-") { 
                // non-capturing move
                ps.descr.push([piece, square, 
                    // Must uniq() the array, since some of the notations actually appear twice
                    // in the list above, and disambiguate_moves() will delete both since it'll think they
                    // are ambiguous. This would have occurred when piece_name === short_piece_name, that is,
                    // for KP, QP, K, and Q. 
                    uniq([
                    piece_letter + capture_or_dash + short_descriptive_dest + promote_paren,        // P-B4
                    piece_name + capture_or_dash + short_descriptive_dest + promote_paren,          // QBP-B4
                    short_piece_name + capture_or_dash + short_descriptive_dest + promote_paren,    // BP-B4
                    piece_letter + capture_or_dash + descriptive_dest + promote_paren,              // P-QB4
                    short_piece_name + capture_or_dash + descriptive_dest + promote_paren,          // BP-QB4
                    piece_name + capture_or_dash + descriptive_dest + promote_paren,                // QBP-QB4

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + descriptive_dest + promote_paren,      // P(K2)-K4
                    piece_letter + "(" + descriptive_origin_rank + ")" + capture_or_dash + descriptive_dest + promote_paren, // P(2)-K4
                    piece_letter + "(" + descriptive_origin_file + ")" + capture_or_dash + descriptive_dest + promote_paren  // P(K)-K4
                ]), move]);


                ps.adesc.push([piece, square, uniq([
                    piece_letter + capture_or_dash + adescriptive_dest + promote_paren,             // P-c4
                    piece_aname + capture_or_dash + adescriptive_dest + promote_paren,              // cP-c4
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + adescriptive_dest + promote_paren,       // P(c2)-c4
                    piece_letter + "(" + adescriptive_origin_rank + ")" + capture_or_dash + adescriptive_dest + promote_paren,  // P(2)-c4
                    piece_letter + "(" + starting_file + ")" + capture_or_dash + adescriptive_dest + promote_paren   // P(c)-c4
                ]), move]);
            } else if (capture_or_dash === "x") {
                var captured_name = captured_piece.descriptive_name;
                var short_captured_name = short_descriptive(captured_name);
                
                var captured_aname = captured_piece.adescriptive_name;

                // capture
                ps.descr.push([piece, square, uniq([
                    // Note: a permutation function would be handy here
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + short_captured_name + promote_paren,       // PxBP
                    piece_letter + capture_or_dash + captured_name + promote_paren,             // PxQBP
                    short_piece_name + capture_or_dash + captured_letter + promote_paren,       // NPxP
                    short_piece_name + capture_or_dash + short_captured_name + promote_paren,   // NPxBP
                    short_piece_name + capture_or_dash + captured_name + promote_paren,         // NPxQBP
                    piece_name + capture_or_dash + captured_letter + promote_paren,             // QNPxP
                    piece_name + capture_or_dash + short_captured_name + promote_paren,         // QNPxBP
                    piece_name + capture_or_dash + captured_name + promote_paren,               // QNPxQBP

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_name + promote_paren,    // P(K4)xQP
                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren,  // P(K4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren,    // PxP(Q4)
                    piece_name + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren       // KPxP(Q4)
                ]), move]);

                ps.adesc.push([piece, square, uniq([
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + captured_aname + promote_paren,            // PxcP
                    piece_aname + capture_or_dash + captured_letter + promote_paren,            // bPxP
                    piece_aname + capture_or_dash + captured_aname + promote_paren,             // bPxcP

                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_aname + promote_paren,  // P(b4)xcP
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren, // P(b4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren,   // PxP(c5)
                    piece_aname + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren     // bPxP(c5)
                ]), move]);
            } else {
                assert(false, "calculate_notations: " + capture_or_dash + " is not - or x");
            }
        }

        // Coordinate notation - least descriptive notation possible, but must include promotion to be non-ambiguous
        ps.coord.push([piece, square, [starting_filerank.toUpperCase() + "-" + dest_filerank.toUpperCase() + promote_paren], move]);

        // ICCF numeric notation
        var starting = filerank2xy(starting_filerank);
        ps.ICCF.push([piece, square, [starting.x + "" + starting.y + "" + move.x + "" + move.y + promote_iccf], move]);

        // Smith notation, reversible, non-ambiguous: https://www.chessclub.com/chessviewer/smith.html
        var smith_capture_letter;
        if (move.smith_castle) {
            // c = short castle, C = long castle
            smith_capture_letter = move.smith_castle;
        } else if (move.en_passant_capture) { 
            // E = en passant capture
            smith_capture_letter = "E";
        } else if (move.capture) {
            // pnbrqk = captured respective piece. This is what makes it reversible.
            smith_capture_letter = captured_letter.toLowerCase();
        } else {
            smith_capture_letter = "";
        }
        ps.smith.push([piece, square, [starting_filerank + dest_filerank + smith_capture_letter + promote_or_blank], move]);

        // WXF Notation http://www.wxf.org/xq/computer/wxf_notation.html and http://www.wxf.org/xq/computer
        // for Chinese Chess (Xiangqi), as used in _First Syllabus on Xiangqi: Chinese Chess 1_ by David H. Li
        var has_horizontal_component = starting.x !== move.x;
        var has_vertical_component = starting.y !== move.y;
        var direction, wxf_dest;
        if (has_horizontal_component && !has_vertical_component) {
            // K4=# lateral (traverse, sideways) to # file
            direction = "=";        // TODO: or "."
            wxf_dest = file_from_perspective(color, move.x);
        } else if (has_vertical_component && !has_horizontal_component) {
            // Up/down is from from player's perspective
            var points_up = dest_y_from_perspective - starting_y_from_perspective;
            if (points_up > 0) {
                // K4+# up relative # point(s)
                direction = "+";
            } else {
                // K4-# down relative # point(s)
                direction = "-";
            }
            wxf_dest = Math.abs(points_up);
        } else {
            // A4+# diagonal to # file
            if (dest_y_from_perspective > starting_y_from_perspective) {
                direction = "+";
            } else {
                direction = "-";
            }
            wxf_dest = file_from_perspective(color, move.x);
        }

        // TODO: disambiguate if on same file! + and -, and special case for pawns; tandem positions
        var wxf_piece_letter = PIECE_TYPES[piece.type].wxf_letter || piece_letter;

        var wxf = wxf_piece_letter + file_from_perspective(color, starting.x) + direction + wxf_dest;

        ps.wxf.push([piece, square, [wxf], move]);

        // Optional " xP" if capture
        var wxf_capture = "";
        if (captured_piece) {
            var wxf_captured_letter = PIECE_TYPES[captured_piece.type].wxf_letter || captured_letter;
            ps.wxf.push([piece, square, [wxf + " " + capture_x + wxf_captured_letter], move]);
        } 

        // Traditional Chinese Xiangqi is same as WXF, but uses Chinese characters 
        // http://www.chessvariants.org/xiangqi.html
        var cn_direction = {
            "=": "平",    // "píng"
            "+": "進",    // "jìn"
            "-": "退",    // "tùi"
            }[direction];

        var cn_piece_letter = PIECE_TYPES[piece.type].cn_letter || piece_letter;
        if (dojo.isArray(cn_piece_letter)) {
            // different letters for each player
            cn_piece_letter = cn_piece_letter[color === "white" ? 0 : 1];
        }

        // Chinese numerals for first player, Arabic for second, as on image at end of http://skookumpete.com/chess_intro.htm
        var cn_from_file = number2repr(color === "white" ? "Chinese" : "Arabic", file_from_perspective(color, starting.x));
        var cn_dest = number2repr(color === "white" ? "Chinese" : "Arabic", wxf_dest);

        // TODO: disambiguate tandem positions, similar to wxf
            
        ps.xq.push([piece, square, [cn_piece_letter + cn_from_file + cn_direction + cn_dest], move]);

    });

    // TODO: check for cross-notation ambiguities. Inputs are tested in the order of
    // AVAILABLE_NOTATIONS, but a notation that matches two different moves in
    // two different notations, if it exists, is sure to cause trouble!
}

// Used for sorting a function by length
function by_length(x, y) 
{ 
    return x.length - y.length; 
}

// Given a list of all valid move notations, remove the ambiguous 
// (Nf3 and Nf3, remove both) overly-disambiguated (Ng1f3 if Ngf3
// or N1f3 is not ambiguous).
function disambiguate_notations(notations)
{
    var freq_count = {};
    var canonical_notations = {};
    var synonymous_notations = {};
    var piece, square, same_moves, abs_move;

    // Count occurrences of each notation text, so know if is ambiguous.
    for (var i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];

        for (var j = 0; j < same_moves.length; j += 1) {
            var move = same_moves[j];

            if (!freq_count[move]) {
                // Store index so can delete if is a dupe
                freq_count[move] = [[i, j]];
            } else {
                freq_count[move].push([i, j]);
            }
        }
    }

    // Delete ambiguous moves (or actually, replace with 'undefined')
    for (notation in freq_count) {
        if (freq_count.hasOwnProperty(notation)) {
            var locations = freq_count[notation];

            if (locations.length > 1) {
                for (var k = 0; k < locations.length; k += 1) { 
                    var i = locations[k][0], j = locations[k][1];
                    delete notations[i][2][j];
                }
            }
        }
    }

    // Find shortest notation text
    for (i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];
        var shortest, synonyms;

        // Remove undefined elements
        same_moves = dojo.filter(same_moves, function(x) { return x !== undefined; });
       
        // Choose shortest (now unambiguous) notation
        // Could also do: min_length = same_moves.pluck("length").min();, then partition
        // Rather, sort by length, ascending.
        same_moves.sort(by_length);

        // The shortest, non-ambiguous move is canonical. But also keep the
        // synonymous moves around.
        shortest = same_moves.shift();
        synonyms = same_moves;

        canonical_notations[shortest] = {piece:piece, square:square, move:abs_move};

        for (j = 0; j < synonyms.length; j += 1) {
            synonymous_notations[synonyms[j]] = {piece:piece, square:square, move:abs_move};
        }
    }

    // TODO: also return synonymous_notations, so overly-disambiguated move
    // notations can be used, too, but return them separately so they won't be
    // listed as unique, canonical moves.
    return [canonical_notations, synonymous_notations];
}

// After the board changes and it is the next person's turn, calculate 
// what the next possible allowable moves are, and update the globals with this information.
//
// If is_hypothetical, do not update globals, and allow "moves" that put in
// check (useful for attacks, see is_hypothetical elsewhere).
//
// This operates on VBOARD only.
function calculate_moves(color, is_hypothetical)
{
    var valid_moves = {}, is_valid_move = {}, blocked_moves = {};
    var possible_notations, notation;

    if (!is_hypothetical) { 
        // Values are [ [ [piece, square ], [possible move names] ], ... ]
        // Instead of a hash or assocative array, because I couldn't use
        // [piece, square] as a key, even with Prototype's Hash. Could use
        // http://www.tutorials4html.com/2009/02/06/true-javascript-hash-table/
        // but instead, using an array with linear lookup.
        possible_notations = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                possible_notations[notation] = [];
            }
        }
    }

    // Look at all the active pieces
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var starting_filerank, square_from, moves, moves_all, piece;

            square_from = VBOARD[x][y];
            piece = square_from.piece;
 
            // Skip blank squares 
            if (!piece) {
                continue;
            }

            // Skip inactive pieces: not player's color, and not neutral (anyone can move it) 
 	    if (piece.color !== color && piece.color !== "neutral") {
                continue;
            }

            // Convert xy to filerank notation (a string), so it can be easily used
            // as a hash key, class name for droppables, and also for notations.
            starting_filerank = square_from.filerank;

            moves_all = filtered_moves(piece, color, is_hypothetical);
            moves = moves_all.legal;
            if (!is_hypothetical) {
                // Fills in possible_notations with possibly-ambiguous move notations in each system
                calculate_notations(color, piece, moves, starting_filerank, possible_notations, square_from);
            }

            // Store valid moves for mouseovers etc.
            if (moves.length !== 0) {
                // For move highlighting
                valid_moves[starting_filerank] = moves;

                // Lookup for accepts()
                is_valid_move[starting_filerank] = {};
                dojo.forEach(moves, function(m) {
                    is_valid_move[starting_filerank][xy2filerank(m)] = m;
                });
            }

            if (blocked_moves.length !== 0) {
                blocked_moves[starting_filerank] = moves_all.blocked;
            }

            //console.log(starting_filerank, moves);
        }
    }


    // Gather all the notations, disambiguate and apply
    if (!is_hypothetical) {
        var notations = possible_notations;
        VALID_MOVE_NOTATIONS = {};
        ALT_MOVE_NOTATIONS = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                var canonical_and_synonyms;

                canonical_and_synonyms = disambiguate_notations(notations[notation]);
                VALID_MOVE_NOTATIONS[notation] = canonical_and_synonyms[0];
                ALT_MOVE_NOTATIONS[notation] = canonical_and_synonyms[1];
            }
        }

        // For reals.
        VALID_MOVES = valid_moves;
        BLOCKED_MOVES = blocked_moves;
        IS_VALID_MOVE = is_valid_move;
    }
    
    return {moves:valid_moves, blocked:blocked_moves};
}

// Get the number of properties an object has on its own.
// Conceptually, the "size" of an "associative array"
function own_property_count(obj)
{
    var count = 0;

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            count += 1;
        }
    }

    return count;
}

// Get the properties of an object as an array
function own_properties(obj)
{
    var props = [];

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            props.push(prop);
        }
    }

    return props;
}



// Populate the menu of valid moves, where you can make a move
// by selection instead of moving a piece with your mouse.
function populate_make_a_move_list()
{
    var active_name = AVAILABLE_NOTATIONS[PREFS.input_notation];
    var move_group, change_group, count, menu;

    menu = dojo.byId("make_move_menu");
    menu.innerHTML = "";

    count = own_property_count(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    if (count === 0) {
        // TODO: This fails, _35e. Fix.
        menu.appendChild(dojo.create("option", {value:"", innerHTML:"No legal moves"}));
        return;
    }

    menu.appendChild(dojo.create("option", 
                {value:"", innerHTML:"Make a move... (" + count + ")"}));
   
    // Moves in active input notation.
    move_group = dojo.create("optgroup", {label:active_name});
    menu.appendChild(move_group);

    for (var notation in VALID_MOVE_NOTATIONS[PREFS.input_notation]) {
        if (VALID_MOVE_NOTATIONS[PREFS.input_notation].hasOwnProperty(notation)) {
            move_group.appendChild(dojo.create("option", 
                        {value: notation, innerHTML:notation}));
        }
    }

    // Change the input notation.
    change_group = dojo.create("optgroup", {label:"Other notation..."});
    menu.appendChild(change_group);

    for (var n in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(n) && n !== PREFS.input_notation) {
            var name = AVAILABLE_NOTATIONS[n];
            change_group.appendChild(dojo.create("option", 
                        {value: "change_" + n, innerHTML:name}));
        }
    }

    menu.selectedIndex = 0;
}

// Make a move in the VBOARD, which can be undone. Only makes the move.
function do_virtual_move(piece, move)
{
    var did = {};

    did.piece = piece;
    did.move = move;

    did.from_square = piece.square;

    did.to_square = VBOARD[move.x][move.y];
 
    // Special case: en passant captures to an empty square
    if (move.en_passant_capture) {
        var forward = forwards_vector(GAME_STATE.active_color);

        did.capture_square = VBOARD[did.to_square.x][did.to_square.y - forward];
    } else {
        did.capture_square = did.to_square;
    }

    // The piece that was captured, not always where the piece moved to.
    did.captured = did.capture_square.piece;

    // This flag prevents a move from causing the piece to capture itself
    // when it "moves" to the same square that it is on.
    if (move.ignore_self_capture && did.captured === piece) {
        return {};
    }

    // Piece that was on destination square, if any. For restoring old piece.
    did.piece_moved_over = did.to_square.piece;

    if (did.captured) { 
        VBOARD[did.capture_square.x][did.capture_square.y].piece = null;
        did.captured.square = null;
    }

    if (move.snapback) {
        // Projectile attack, withdrawals back to where it came from
        did.to_square = did.from_square;    // this is key
        did.piece_moved_over = did.captured;
        return did;
    }
    if (move.self_destruct) {
        VBOARD[did.to_square.x][did.to_square.y].piece = null;
        did.self_destructed = true;
        VBOARD[did.from_square.x][did.from_square.y].piece = null;
        return did;
    }

    piece.square = VBOARD[did.to_square.x][did.to_square.y];
    VBOARD[did.to_square.x][did.to_square.y].piece = piece;
    if (did.from_square) {
        VBOARD[did.from_square.x][did.from_square.y].piece = null;
    }

    return did;
}

// Undo a move given the result of do_virtual_move().
function undo_virtual_move(did)
{
    // Restore captured piece
    if (did.captured) {
        did.captured.square = VBOARD[did.capture_square.x][did.capture_square.y];
        did.captured.square.piece = did.captured;
    }

    // Piece that was clobbered by the move
    VBOARD[did.move.x][did.move.y].piece = did.piece_moved_over;

    // Move piece back
    did.piece.square = VBOARD[did.from_square.x][did.from_square.y];
    VBOARD[did.from_square.x][did.from_square.y].piece = did.piece;
}


// Return whether moving piece to move would mean that
// color is in check. Note, that doesn't mean that the move
// *caused* the check, they could have already been in check and
// this move didn't take them out. Either way, its illegal.
function would_check(piece, move, color)
{
    var from_square = piece.square;
    var to_square = VBOARD[move.x][move.y];
    var checked, all_moves, did;


    // Hypothetical move, with possible capture
    did = do_virtual_move(piece, move);

    // TODO: This is a lot of calculation to do, see if can speed it up
    all_moves = calculate_moves(opposite_color(color), true);
    checked = in_check(color, all_moves.moves);

    // Restore move
    undo_virtual_move(did); 

    return checked;
}

// Return whether a pawn has moved from its initial position. Unfortunately,
// the starting ranks of black and white pawns are hardcoded, so that games
// in-progress can be loaded and pawns that have moved, but we haven't seen move,
// are recognized as in fact having moved. Other games with pawns in ranks other
// than 2nd and 7th (Chinese Chess, etc.) will need to have this modified.
// TODO: store initial rank in piece information
function piece_moved(piece)
{
    // Bit of a hack, but castling privileges take care of this.
    if (piece.type === "king") {
        return false;
    }

    // TODO: don't hardcode! Give rank in piece type, mirror black/white.
    //assert(piece.type === "pawn" || piece.type === "berolina_pawn" || piece.type === "pawnattackrook", "piece_moved(" + piece + "): can only tell if pawns moved, not " + piece.type);

    var square = piece.square;

    if (piece.color === "white") {
        return square.y !== 2;    // 2nd rank
    } else if (piece.color === "black") {
        return square.y !== 7;    // 7th rank
    } else {
        assert("piece_moved(" + piece + "): neither white nor black");
    }
}


// Called when the make a move menu is changed, either to change the
// input notation or actually make a move by the menu.
function make_move_by_menu(menu)
{
    var choice = form_value("make_move_menu");

    // Notation change
    if (choice.indexOf("change_") === 0) {
        var new_notation = choice.substring("change_".length);
   
        PREFS.input_notation = new_notation;
        populate_make_a_move_list();
        return;
    }

    mv(choice);
}

//// AI - COMPUTER MOVES

// Do this after a delay, so that when playing computer vs. computer, you can
// see the move, since they are not animated (Effect.Move) yet.
function computer_move_if_applicable(clicked)
{
    if (clicked) {
        if (form_value("black_computer") || form_value("white_computer")) {
            dojo.byId("skill_level").value = PREFS.skill;
            dojo.byId("show_skill").style.display = "";
        } else {
            dojo.byId("show_skill").style.display = "none";
        }
    }

    if (!form_value(GAME_STATE.active_color + "_computer")) {
        return;
    }

    // TODO: better variables
    if (dojo.byId("check").innerHTML.indexOf("Checkmate") !== -1 ||
        dojo.byId("check").innerHTML.indexOf("Draw") !== -1) {
        // Game is completed, don't bug the computer
        return;
    }

    unhighlight_all();

    if (PREFS.skill === 0) {
        setTimeout(random_move, 1);
    } else {
        schedule_engine_move(PREFS.skill);
    }
}

// Update the skill level when the user changes the form field.
// TODO: Use HTML5 <input type="range">
function update_skill(element)
{
    var skill = parseInt(element.value, 10);

    if (skill < 0) {
        skill = 0;
    }  else if (skill > 100) {
        skill = 100;
    }

    element.value = skill;

    PREFS.skill = skill;
}

// Make a random move with equal probability. No intelligence.
function random_move()
{
    // simply choose a random move
    var keys = own_properties(VALID_MOVE_NOTATIONS.SAN);
    var alg_move = keys[randint(0, keys.length - 1)];
    //var alg_move = keys[0];

    //var piece_square = VALID_MOVE_NOTATIONS.SAN[alg_move];

    // TODO: do some animation when moving, Effect.Move, to slow it down so we can see it.
    mv(alg_move);
}

// Ask a chess engine, via Ajax, for its move and the board score.
// TODO: also allow remote human moves, for realtime games?
function schedule_engine_move(skill)
{
    var query;

    // TODO: pass skill, too.
    
    query = "?skill=" + skill + ";fen=" + encodeURIComponent(active_fen());

    dojo.xhrGet({
        url: PREFS.engine + query,
        handleAs: "json",
        load: got_engine_move,
        error: got_engine_error
        });

    set_check_message("Analyzing...");
}

// Callback for when the chess engine Ajax request move is received.
function got_engine_move(response)
{
    if (!response.error) {
        set_check_message("");
        mv(response.next_move);
        // TODO: show a meter for the board position
        dojo.byId("score").innerHTML = "Score: " + response.score;
    } else {
        disable_engine("Engine error: " + response.error);
    }
}

// Called when the Ajax request fails
function got_engine_error(response)
{
    disable_engine("Engine unavailable: " + response);
}

// Disable the external chess engine usage and make a random move in its place.
function disable_engine(why)
{
    PREFS.skill = 0;
    dojo.byId("skill_level").value = PREFS.skill;
    dojo.byId("skill_level").title = "Reset because of: " + why;
    window.status = "Skill level reset because: " + why;

    // It'll have to do
    random_move();
}

//// REMOTE / SERVER-SIDE BACKEND / MULTIPLAYER
// These functions are for interacting with the backend server (this app can
// also be used standalone, with no server - but not this functionality).

// Initialize remote server connections
function init_remote_server()
{
    if (running_locally()) {
        //console.log("Not updating server session");
        return;
    }

    update_session();

    // Receive push events
    // http://pusherapp.com/docs/quickstart
    load_script("http://js.pusherapp.com/1.5/pusher.min.js", function() {
        var pusher, channel;

        pusher = new Pusher("5d47347e06c56e1bd292");
        channel = pusher.subscribe("game-5"); // TODO: game id

        channel.bind("move", receive_remote_move);
        //TODO: channel.bind("chat"
    });
}

// Dynamically load a remote JavaScript
function load_script(url, onload) {
    var script;
    
    // Note: xhrGet has handleAs:"javascript", but XHR cross-domain is restricted.
    // So we have to create a new <script> tag and insert it
    script = dojo.create("script", {src:url, type:"text/javascript", onload:onload});

    dojo.body().appendChild(script);
}

// Return whether we're running on a local disk, and don't have server access
function running_locally()
{
    return document.location.protocol === "file:";
}

// Clear the session
function logout()
{
    dojo.xhr("DELETE", {url:PREFS.server + "session",
            load:function(response, args) {
                console.log("Logout successful");
                update_session();
            },
            error:function(response, args) {
                assert(False, "Failed to logout: " + response);
            }
            });
}

// Login with Google Accounts
function login()
{

    // TODO: allow logging in without leaving the page and losing state!
    /* 
    dojo.byId("login_iframe").style.display = "";
    dojo.byId("login_iframe").src = PREFS.server + "session/new";
    */

    
    location = PREFS.server + "session/new";
    // redirected back here
}

// Update the login state and session information from the remote server
function update_session()
{
    // So we were served off of localhost
    PREFS.server = location.protocol + "//" + location.hostname + ":" + location.port + "/";

    dojo.xhr("GET", {url:PREFS.server + "session.json", handleAs: "json",
            load:function(response, args) {
                if (response.player) {
                    console.log("Logged in");
                    SESSION = response.player;
                    SESSION.logged_in = true;
                } else {
                    console.log("Not logged in");
                    SESSION = {logged_in: false};
                }
                update_session_welcome();
                load_remote_game(active_remote_game());
            },
            error:function(response, args) {
                console.log("Error updating session");
                console.log("Response: " + response);
            }
            });
}

// Welcome the user
function update_session_welcome()
{
    var html;

    if (SESSION.logged_in) {
        dojo.byId("welcome_name").textContent = SESSION.first_name + " (user #" + SESSION.player_id + ")";
    }

    dojo.byId("not_logged_in").style.display = SESSION.logged_in ? "none": "";
    dojo.byId("login_link").style.display = SESSION.logged_in ? "none" : "";

    dojo.byId("logout_link").style.display = SESSION.logged_in ? "" : "none";
    dojo.byId("welcome").style.display = SESSION.logged_in ? "" : "none"

}


// Send move to remote server, if logged in
function send_remote_move(color, move_text, fen, ply)
{
    if (!SESSION.logged_in) {
        return;
    }

    // Send move to server
    console.log("Send remote:"+color+" "+move_text);
    dojo.xhrPut({url:PREFS.server + "games/" + active_remote_game(), content:{color:color, move:move_text, fen:fen, ply:ply},
            load:function(response) {
                //console.log("load xhrPut",response);
            },
            error:function(response) {
                console.log("error xhrPut",response);
            }});
}

// Process an move from the server, which could be from our opponents
function receive_remote_move(event) 
{
    // Received move from backend
    console.log("Got a push: "+JSON.stringify(event));

    if (!GAME_STATE.made_moves[event.ply]) {   // if move wasn't already made
        mv(event.move);
    }
}

// Get the active remote game ID
function active_remote_game()
{
    var n = SESSION.active_games.length;

    assert(n > 0, "No active remote games!");

    // Return most recent
    // TODO: selection of active
    return SESSION.active_games[n - 1];
}

// Load a remote game from the server
function load_remote_game(id)
{
    dojo.xhrGet({url:PREFS.server + "games/" + id + ".pgn",
            load:function(response) {
                console.log("load_remote_game(" + id + "): got response", response);
                load_pgn(response);
            },
            error:function(response) {
                console.log("load_remote_game(" + id + "): failed", response);
            }});
}

// TODO: Create a new remote game
function new_remote_game()
{
    // TODO: white, black remote players
    dojo.xhrPost({url:PREFS.server + "game", content:{color:color, move:move_text},  //authenticity_token:SESSION.auth_token},
            load:function(response) {
                console.log("load xhrPost",response);
            },
            error:function(response) {
                console.log("error xhrPost",response);
            }});
}

//// PARLETT NOTATION FUNCTIONS

// Convert an unfiltered moves array into a textual graphical representation
function movement_diagram(moves)
{
    var board = {}, texts;

    // Empty board
    for (var x = -GAME_STATE.files; x <= GAME_STATE.files; x += 1) {
        board[x] = {};
        for (var y = -GAME_STATE.ranks; y <= GAME_STATE.ranks; y += 1) {
            board[x][y] = " ";
        }
    }

    // Mark moves
    for (var i = 0; i < moves.length; i += 1) {
        var move = moves[i];
        var ch;

        if (!board[-move[1]]) {
            // Invalid move
            continue;
        }

        // Basic movement - leaper or rider
        if (move[2].if_blocked_skip) {
            // might block (rider)
            ch = "x";
        } else {
            // probably a leaper
            ch = "+";
        }

        if (move[2].capture_only) {
            ch = "c";
        }
        if (move[2].no_capture) {
            ch = "m";   // move only, no capture
        }
        if (move[2].initial_only) {
            ch = "i";
        }
        if (move[2].if_unblocked_dx !== undefined) {
            ch = "u";   // unblocked
        }
        if (move[2].if_blocked_dx !== undefined) {
            ch = "^";   // probably a hopper
        }

        // Flip directions
        board[-move[1]][move[0]] = ch;

        if (move[2].if_unblocked_dx !== undefined) {
            board[-move[2].if_unblocked_dy][move[2].if_unblocked_dx] = "|";
        }
    }

    // Origin
    board[0][0] = "O";

    // Stringify
    texts = [];
    for (var x = -GAME_STATE.files; x <= GAME_STATE.files; x += 1) {
        for (var y = -GAME_STATE.ranks; y <= GAME_STATE.ranks; y += 1) {
            var ch = board[x][y];
            var top = (x + GAME_STATE.files) * 10;
            var left = (y + GAME_STATE.ranks) * 10;
            texts.push("<div class='inspector-diagram-cell' style='top:" + top + "px; left: " + left + "px;'>" + ch + "</div>");
        }
    }


    return texts.join("");
}


// Get the unfiltered, relative moves for a Parlett string.
// Warning: do not modify the moves returned! Otherwise other moves will get confused.
var PARLETT_CACHE = {};
function unfiltered_moves(parlett)
{
    var choice_groups, rel_moves;

    // Cache for a performance improvement, since Parlett is constant per move.
    if (PARLETT_CACHE[parlett]) {
        //return deep_copy(PARLETT_CACHE[parlett]);
        //return PARLETT_CACHE[parlett].evalJSON();
        return PARLETT_CACHE[parlett];
    }

    // Get all the unfiltered moves for the mutually exclusive choices
    choice_groups = parlett.split(", ");

    rel_moves = [];
    for (var i = 0; i < choice_groups.length; i += 1) {
        // For each group, gather the move options. 
        // (Would be nice if JavaScript arrays had a Python-like .extend)
        rel_moves.push.apply(rel_moves, decode_one_parlett(choice_groups[i]));
    }   
    //rel_moves = without_dupes(rel_moves);

    PARLETT_CACHE[parlett] = rel_moves;
    //PARLETT_CACHE[parlett] = dojo.toJson(rel_moves);

    return rel_moves;
}

// Get the legal moves for a piece.
function filtered_moves(piece, color, is_hypothetical)
{
    var parlett, rel_moves, moves, blocked_moves, start, blocked;
    var start_x, start_y, piece_info;

    start = piece.square;
    if (!start) {
        return [];
    }

    start_x = start.x;
    start_y = start.y;

    piece_info = PIECE_TYPES[piece.type];
    parlett = piece_info.parlett;

    rel_moves = unfiltered_moves(parlett);

    // Absolutize and find what is allowed
    moves = [];
    blocked_moves = [];
    blocked = {};
    for (var i = 0; i < rel_moves.length; i += 1) {
        var rel_x, rel_y, flags, abs_move, x, y;
       
        rel_x = rel_moves[i][0];
        rel_y = rel_moves[i][1]; 
        flags = rel_moves[i][2];

        // Local copies of relative coords, so don't modify original.
        var if_unblocked_dx = flags.if_unblocked_dx, if_unblocked_dy = flags.if_unblocked_dy;
        var if_blocked_dx = flags.if_blocked_dx, if_blocked_dy = flags.if_blocked_dy;
        var if_unblocked2_dx = flags.if_unblocked2_dx, if_unblocked2_dy = flags.if_unblocked2_dy;
        var if_unblocked3_dx = flags.if_unblocked3_dx, if_unblocked3_dy = flags.if_unblocked3_dy;
        //var capture_at_dx = flags.capture_at_dx, capture_at_dy = flags.capture_at_dy;
        var mark_ep_target_dx = flags.mark_ep_target_dx, mark_ep_target_dy = flags.mark_ep_target_dy;

        // Positive is forwards, so mirror for black (this is the player's color, so it also
        // applies to neutral pieces being moved by the black player)
        if (color === "black") {
            rel_y = -rel_y;
            // Reverse any embedded relative coordinates.
            if (if_unblocked_dy) { if_unblocked_dy = -if_unblocked_dy; }
            if (if_blocked_dy) { if_blocked_dy = -if_blocked_dy; }
            if (if_unblocked2_dy) { if_unblocked2_dy = -if_unblocked2_dy; }
            if (if_unblocked3_dy) { if_unblocked3_dy = -if_unblocked3_dy; }
            //if (capture_at_dy) { capture_at_dy = -capture_at_dy; }
            if (mark_ep_target_dy) { mark_ep_target_dy = -mark_ep_target_dy; }
        }

        x = rel_x + (flags.absolute_x ? 0 : start_x);
        y = rel_y + (flags.absolute_y ? 0 : start_y);

        abs_move = {x: x, y: y};

        // Default to limiting movement based on board dimensions, but
        // allow boards to also limit based on a river or palace
        var x1 = 1, y1 = 1, x2 = GAME_STATE.files, y2 = GAME_STATE.ranks;
        if (GAME_STATE.boundaries[piece.type]) {
            var boundary = GAME_STATE.boundaries[piece.type][color];

            x1 = boundary[0];
            y1 = boundary[1];
            x2 = boundary[2];
            y2 = boundary[3];
        }

        if (x < x1 || y < y1 || x > x2 || y > y2) {
            // Out of bounds
            blocked[rel_x + "," + rel_y] = true;
            continue;
        }

        var dest_square = VBOARD[x][y];
        var capture_piece = dest_square.piece;

        // If there is any piece there, it may block other moves
        if (capture_piece) {
            blocked[rel_x + "," + rel_y] = true;

            if (flags.if_blocked_skip) {
                i += flags.if_blocked_skip;
            }
        
            // Can't move to self-occupied square
            if (capture_piece.color === color) {
                // Castling moves can never guard, since the destination must be unoccupied
                if (!flags.if_can_castle) {
                    // to indicate we are guarding this piece
                    blocked_moves.push(abs_move);
                }

                if (flags.if_can_castle) {
                    // You move your king over your rook to castle, so this _can_ be legal.
                    if (!PIECE_TYPES[capture_piece.type].castle && !PIECE_TYPES[capture_piece.type].castles_with) {
                        continue;
                    }
                } else {
                    // Non-castling move to self-occupied square is illegal
                    continue;
                }
            }

            // Can't move to invincible piece
            if (PIECE_TYPES[capture_piece.type].invincible) {
                continue;
            }

            // For move notations
            abs_move.capture = capture_piece;
        } 

        // Must be a capture
        if (flags.capture_only && !capture_piece) {
            continue;
        }

        // Must not be capture
        if (flags.no_capture && capture_piece) {
            continue;
        }

        // TODO: Does piece_moved() need to be virtualized?
        if (flags.initial_only && piece_moved(piece)) {
            continue;
        }

        // Blocked by an obstruction. Can check for up to three spaces. To check
        // more, chain the moves. 
        var key;
        if (if_unblocked_dy !== undefined) {
            key = if_unblocked_dx + "," + if_unblocked_dy;

            // If was either blocked by a previous move (faster), or there is a
            // piece there but it wasn't a valid move. For example, elephant (2X)
            // can be blocked, since it is not a leaper (sticking the elephant's eye),
            // non-hippogonal rider.
            if (blocked[key] || pc_or_offboard(if_unblocked_dx + start_x, if_unblocked_dy + start_y)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }

        // Only if *is* blocked
        if (if_blocked_dy !== undefined) {
            key = if_blocked_dx + "," + if_blocked_dy;
            if (!blocked[key] && !pc_or_offboard(if_blocked_dx + start_x, if_blocked_dy + start_y)) {
                continue;
            }
        }

        if (if_unblocked2_dy !== undefined) {
            key = if_unblocked2_dx + "," + if_unblocked2_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked2_dx + start_x, if_unblocked2_dy + start_y)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }
        if (if_unblocked3_dy !== undefined) {
            key = if_unblocked3_dx + "," + if_unblocked3_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked3_dx + start_x, if_unblocked3_dy + start_y)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }

        // Snap back after moving - for guns
        if (flags.snapback !== undefined) {
            abs_move.snapback = true;
        }
       
        // Self-destruct - for kamikaze pieces (disappears when making capture, along with captives - P.Monreal Probleme, 1965)
        if (flags.self_destruct !== undefined) {
            abs_move.self_destruct = true;
        }


        // Map pawn moves to what the en passant target will be if
        // the pawn moves there.

        if (!is_hypothetical) {
           if (mark_ep_target_dx !== undefined) {
                abs_move.create_ep_target = {x: mark_ep_target_dx + start_x, y:mark_ep_target_dy + start_y};
            }

        }

        // Only valid if this move is to an ep target.
        if (flags.if_ep_target) {
            if (!GAME_STATE.ep_target || GAME_STATE.ep_target.x !== x ||
                GAME_STATE.ep_target.y !== y)  {
                continue;
            }

            abs_move.en_passant_capture = true;
        }

        // Castling moves
        if (flags.if_can_castle) {
            // long=a-side, short=h-side, but exact file depends on castles_come_from()
            var castle_side = flags.if_can_castle;
            // Where the "castle" (such as a rook, NOT the king) comes from
            var castle_from_file = castles_come_from()[castle_side + "_file"];
            if (!castle_from_file) {
                // No privileges, no information available
                continue;
            }

            var castle_from_x = castle_from_file.charCodeAt(0) - "a".charCodeAt(0) + 1;

            // Moved and lost castling privileges
            if (!GAME_STATE.can_castle[color][castle_from_file]) {
                continue;
            }

            if (start.y !== (color === "white" ? 1 : (GAME_STATE.ranks))) {
                // It is not the job of this function to determine whether the
                // castle or king has moved; we rely on the castling eligibility codes.
                // They are probably incorrect if this happens, since the king is not
                // on its first rank.
                assert(false, "filtered_moves: " + color + " is eligible to castle, but the king is on rank start.y=" + start.y + ", instead of the first rank. Is the castling eligibility correct?");
            }


            // Can't castle if in check
            if (GAME_STATE.active_in_check) {
                continue;
            }


            var found = false;
            var goes_to;

            // King captures rook
            abs_move.x = castle_from_x;

            if (castle_from_x < start.x) {
                // a-side castling
                abs_move.notation_override = "O-O-O";
                goes_to = GAME_STATE.castle_moves.clong;
            } else if (castle_from_x > start.x) {
                // h-side castling
                abs_move.notation_override = "O-O";
                goes_to = GAME_STATE.castle_moves.cshort;
            } else {
                assert(false, "filtered_moves: castling: castle_from_x === start.x (" + castle_from_x + " === " + start.x + "). This may happen if the FEN says that castling is possible, but in fact the king or rook have moved.");
            }

            var first_rank = color === "white" ? 1 : GAME_STATE.ranks;
            var castle_piece = VBOARD[castle_from_x][first_rank].piece;
            if (!castle_piece) {
                continue;
            }

            // Check the path that the rook takes during castling.
            // It must be unobstructed, otherwise castling is temporarily not possible.
            if (!dojo.every(inclusive_range(castle_from_x, goes_to.castle_to), function(x) {
                var piece_between = VBOARD[x][first_rank].piece;
                if (piece_between && 
                        piece_between.unique_id !== piece.unique_id &&          // king can be in the way
                        piece_between.unique_id !== castle_piece.unique_id) {   // this rook only " " "
                    if (PREFS.show_castling_impediments) {
                        push_highlight(sq(x,1),"orange");
                    }
                    return false;
                }

                // Return true if unblocked, or false if blocked and this move is invalid
                return true;
            })) {
                continue;
            }

            // King's path must be unobstructed, too.
            if (!dojo.every(inclusive_range(start.x, goes_to.king_to), function(x) {
                var piece_between = VBOARD[x][first_rank].piece;
                if (piece_between && 
                        piece_between.unique_id !== piece.unique_id &&          // king can be in the way
                        piece_between.unique_id !== castle_piece.unique_id) {   // castling rook only " " "
                    if (PREFS.show_castling_impediments) {
                        push_highlight(sq(x,1),"darkorange");
                    }
                    return false;
                }

                // Check that the king is not moving through check on its path
                for (var attack_from in VALID_MOVES_OPP) {
                    if (VALID_MOVES_OPP.hasOwnProperty(attack_from)) {
                        var attacks = VALID_MOVES_OPP[attack_from];
                        for (var k = 0; k < attacks.length; k += 1) 
                        {
                            var attack = attacks[k];

                            if (attack.x === x && attack.y === first_rank) {
                                return false;
                            }
                        }
                    }
                }

                return true;
            })) {
                continue;
            }
        }

        // Capture at relative location, instead of at destination square.
        // Not actually implemented. En passant capture location is hardcoded.
        /*
        if (capture_at_dx !== undefined) {
           var cx = capture_at_dx + start_x, cy = capture_at_dy + start_y;

           if (cx < 1 || cy < 1 || cx > GAME_STATE.ranks || cy > GAME_STATE.files) {
               continue;
           }

           var capture = VBOARD[cx][cy].piece;
           //console.log("C",xy2filerank({x:cx,y:cy}));
           if (capture) {
               abs_move.capture = capture;
           } else {
               // Nothing there to capture.
               continue;
           }
        }*/

        // TODO: faster check checking? maybe split into:
        // 1. if not in check, can't move into
        //   a. can't move a pinned piece that would cause check, unblocks attack
        //   b. can't move royal piece into attacked square
        // 2. if in check, must move out of
        //   a. move royal piece (if double check, only can move)
        //   b. capture with another piece
        //   c. block with another piece
        if (!is_hypothetical && would_check(piece, abs_move, color)) { 
            continue; 
        }

        if (would_promote(piece, abs_move)) {
            // Expand promotions; make a move for each piece you can promote to
            for (var j = 0; j < piece_info.promote.length; j += 1) {
                var prom_move = {promote_to: piece_info.promote[j]};

                dojo.mixin(prom_move, abs_move);
               
                moves.push(prom_move);
            }
        } else {
            // Just one move
            moves.push(abs_move);
        }
    }

    var unique = [];
    var unique_xy = {};

    // Remove/merge duplicate absolute moves. They must be removed after
    // making absolute, not when they are relative, since riders may have
    // multiple rays that need to be blocked (such as the griffon).
    for (var i = 0; i < moves.length; i += 1) {
        var move = moves[i];
        var key = move.x + "," + move.y + "," + move.promote_to;

        if (!unique_xy[key]) {
            unique.push(move);
            unique_xy[key] = unique.slice(-1);
        } else {
            // Merge flags
            dojo.mixin(unique_xy[key], move);
        }
    }

    return {legal:unique, blocked:blocked_moves};
}

// Rotate a direction vector by the given number of degrees, clockwise,
// rounded to nearest 45 degree multiple.
//
// Example:
//
//  rotate_direction([0,1], 180) === [0,-1]
//
function rotate_direction(vector, degrees)
{
    var rotate45 = {
        v01: [1,1],
        v11: [1,0],
        v10: [1,-1],
        "v1-1": [0,-1],
        "v0-1": [-1,-1],
        "v-1-1": [-1,0],
        "v-10": [-1,1],
        "v-11": [0,1]
    };
    // TODO: support non-unit vectors, like [0,2] hippogonal rider moves?
    // Could get complicated.

    if (degrees < 0) {
        degrees = 360 - (-degrees);
    }

    var ticks = Math.round(degrees / 45);

    for (var i = 0; i < ticks; i += 1) {
        var vector_string = "v" + vector[0] + vector[1];

        vector = rotate45[vector_string];
        assert(vector !== undefined, "rotate_direction(" + vector + ", " + degrees + "): failed to rotate " + vector_string);
    }


    return vector;
}

// Return {vectors, consumed}. The vectors are positive for forward/right, 
// negative for backwards/left. Consumed is number of characters, 1 or 2.
function relative_decode_direction(ch, ch2)
{
    var vectors, consumed;

    consumed = 1;
    if (ch === "+") { 
        // orthogonally four possible directions
        vectors = [[1, 0], [0, 1], [-1, 0], [0, -1]];
    } else if (ch === "=") {
        // orthogonally sideways
        vectors = [[1, 0], [-1, 0]];
    } else if (ch === ">") {
        if (ch2 === "=") {
            // >= orthogonally forwards or sideways
            vectors = relative_decode_direction(">", undefined).vectors.concat(relative_decode_direction("=", undefined).vectors);
            consumed += 1;
        } else if (ch2 === ">") {
            // >> right (Extended Parlett)
            vectors = [[1, 0]];
            consumed += 1;
        } else {
            // > orthogonally forward
            vectors = [[0, 1]];
        }
    } else if (ch === "<") {
        if (ch2 === ">") {
            // <> orthogonally forwards and backwards
            vectors = [[0, 1], [0, -1]];
            consumed += 1;
        } else if (ch2 === "=") {
            // <= orthogonally backwards or sideways
            vectors = relative_decode_direction("<", undefined).vectors.concat(relative_decode_direction("=", undefined).vectors);
            consumed += 1;
        } else if (ch2 === "<") {
            // << left (Extended Parlett)
            vectors = [[-1, 0]];
            consumed += 1;
        } else {
            // < orthogonally backwards
            vectors = [[0, -1]];
        }
    } else if (ch === "X") { 
        if (ch2 === ">") {
            // X> diagonally forwards
            vectors = [[1, 1], [-1, 1]];
            consumed += 1;
        } else if (ch2 === "<") {
            // X< diagonally backwards
            vectors = [[1, -1], [-1, -1]];
            consumed += 1;
        } else {
            // X diagonally four possible directions
            vectors = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        }

    // Unicode arrows - see http://www.alanwood.net/unicode/arrows.html for a
    // good list - since we were running out of ASCII..
    } else if (ch === "↖") {
        // ↖ diagonally left up (Extended Parlett)
        vectors = [[-1, 1]];
    } else if (ch === "↗") {
        // ↗ diagonally right up (Extended Parlett)
        vectors = [[1, 1]];
    } else if (ch === "↘") {
        // ↘ diagonally right down (Extended Parlett)
        vectors = [[1, -1]];
    } else if (ch === "↙") {
        // ↙ diagonally left down (Extended Parlett)
        vectors = [[-1, -1]];
    } else if (ch === "*") {    
        // orthogonally or diagonally (eight possible directions)
        vectors = relative_decode_direction("+", undefined).vectors.concat(relative_decode_direction("X", undefined).vectors);
    } else {
        assert(false, "relative_decode_direction('" + ch + "', '" + ch2 + "'): invalid direction");
    }

    return {vectors:vectors, consumed:consumed};
}

// Attempt to parse an integer in base 10, but if it fails, return the input.
function parseInt10(x) 
{ 
    var number = parseInt(x, 10); 

    return isNaN(number) ? x : number;
}

// Parse semicolon separated flags, possibly key/value pairs
// foo;bar sets foo:true and bar:true, can also set relative coordinates:
// if_unblocked=1,2.
function parse_move_flags(text, flags)
{
    var flags_text;

    if (flags === undefined) {
        flags = {};
    }

    if (dojo.isArray(text)) {
        flags_text = text;
    } else {
        flags_text = text.split(";");
    }

    // Semicolon-separated flags
    for (var i = 0; i < flags_text.length; i += 1) {
        var flag_text = flags_text[i];
        var value;
       
        // Allow if_unblocked=0,1, etc.
        if (flag_text.indexOf("=") !== -1) { 
            // Unfortunately, need JavaScript 1.8 to do [x,y] = ...
            var ary = flag_text.split("=");
            var left = ary[0], right = ary[1];
            value = right.split(",");
            value = dojo.map(value, parseInt10);
            if (value.length === 1) {
                flags[left] = value[0];
            } else if (value.length === 2) {
                flags[left + "_dx"] = value[0];
                flags[left + "_dy"] = value[1];
            } else {
                assert(false, "parse_move_flags(" + text + ", " + flags + "): not 1 or 2 elements: " + value);
            }
        } else {
            flags[flag_text] = true;
        }
    }

    return flags;
}

// Decode the Extended Parlett {} construct, which adds flags
// to arbitrary move text. {parlett, flags}
function nested_flags(parlett)
{
    var rel_moves, flags_text, flags;
    
    flags_text = parlett.split(";");
    // Do not cache, since can be modified
    rel_moves = dojo.clone(unfiltered_moves(flags_text.shift()));

    flags = parse_move_flags(flags_text);

    for (var flag in flags) {
        if (flags.hasOwnProperty(flag)) {
            for (var j = 0; j < rel_moves.length; j += 1) {
                rel_moves[j][2][flag] = flags[flag];
            }
        }
    }

    return rel_moves;
}

// Decodes an explicit relative move that was in square brackets: [0,2;initial_only]
function decode_explicit_move(text_move, existing_flags)
{
    var xy_text_flags, xy_text, xy, x, y, flags;
    
    xy_text_flags = text_move.split(";");
    xy_text = xy_text_flags.shift();

    if (xy_text.indexOf(",") !== 0) {
        // Relative x,y
        xy = xy_text.split(",");
        x = parseInt(xy[0], 10);
        y = parseInt(xy[1], 10);
    } else {
        // TODO: call decode_one_parlett, to allow
        // [oi2>;flags] or oi[2>;flags], etc.
        assert(false, "decode_explicit_move(" + text_move + ", " + existing_flags + "): not [x,y;flags], missing comma");
    }

    flags = parse_move_flags(xy_text_flags, existing_flags);

    return [x, y, flags];
}

// Decode a Parlett notation into a list of [x,y,flags], where
// x and y are destinations relative to the piece origin, and flags describes
// under what conditions the move can be made. + is forward, - is backwards,
// from the perspective of the active color. Has no knowledge of board state.
// The moves must be filtered to determine their validity.
// TODO: Other notations?
function decode_one_parlett(parlett)
{
    var distances, directions, flags, movement, rel_moves, limit, inner_moves, rotates;
    var hippogonal = false, hopper = false;

    flags = {};
    distances = [];
    rotates = [];
    rel_moves = [];
    movement = "rider";

    // Hippogonal riders, like the nightrider, can be specified as 
    // either ~1/2& or n(~1/2). The first notation, due to David Parlett's
    // _The Oxford History of Board Games_, is less flexible but more compact.
    if (parlett.substr(parlett.length - 1) === "&") {
        parlett = "n(" + parlett.substr(0, parlett.length - 1) + ")";
    }

    for (var i = 0; i < parlett.length; i += 1) {
        var ch = parlett.substr(i, 1);

        if (ch === "~") {
            movement = "leaper";
            // TODO: "darters", blockable 'leapers' - 1//2, elban knight, horse (0,1 then 1,1), moa (1,1 then 0,1)
            // http://www.mayhematics.com/v/gm.htm

        // Flags, documented on http://en.wikipedia.org/wiki/Fairy_chess_piece#Additions_to_Parlett.27s
        } else if (ch === "i") { 
            // Initial move: Can only if the piece is in its original position
            // (pawn's 2 move forward)
            flags.initial_only = true;
        } else if (ch === "c") {
            // Capture only: may only be used if destination is occupied by enemy piece
            // (pawn's diagnal capture)
            flags.capture_only = true;
        } else if (ch === "o") {
            // Can not capture: destination square must be unoccupied; since by default, piece
            // can move to enemy square in order to capture it
            // (pawn's forward move)
            flags.no_capture = true;
        
        // Hopping rider
        } else if (ch === "^") {
            hopper = true;

        // Grouping
        } else if (ch === "(") {
            var inner_move_text = "";
            var nest_level = 1;
            while(i < parlett.length)
            {
                i += 1;
                var chi = parlett.substr(i, 1);
                if (chi === ")") { nest_level -= 1; }
                if (chi === "(") { nest_level += 1; }
                if (nest_level === 0) { break; } 

                inner_move_text += chi;
            }

            inner_moves = unfiltered_moves(inner_move_text);

        // Extended Parlett
        
        // Include an existing piece movement, possibly with flags
        } else if (ch === "#") {
            var type = parlett.substr(i + 1);
            assert(PIECE_TYPES[type], "in Parlett #include, piece name not found: " + type);
            var included = dojo.clone(unfiltered_moves(PIECE_TYPES[type].parlett));

            for (i = 0; i < included.length; i += 1) {
                dojo.mixin(included[i][2], flags);
            }

            return included;

        // Direct move text: [rel_x,rel_y;flag1;flag2;...] 
        } else if (ch === "[") {
            var text_move = "";
            var nest_level = 1;
            while(i < parlett.length)
            {
                i += 1;
                var chi = parlett.substr(i, 1);
                if (chi === "]") { nest_level -= 1; }
                if (chi === "[") { nest_level += 1; }
                if (nest_level === 0) { break; } 

                text_move += chi;
            }
            rel_moves.push(decode_explicit_move(text_move, flags));

        // Nested flags: {oi2>, asdf.. ;flag1;flag2;flag3...}
        } else if (ch === "{") {
            var inner, nest;
            
            inner = "";
            nest = 1;
            while(i < parlett.length)
            {
                i += 1;
                var cho = parlett.substr(i, 1);
                if (cho === "}") { nest -= 1; }
                if (cho === "{") { nest += 1; }
                if (nest === 0) { break; } 

                inner += cho;
            }

            return nested_flags(inner);

        // Limit on distances, for diminished pieces
        } else if (ch === ".") {
            // Only one digit for now
            limit = parseInt(parlett.substr(i + 1, 1), 10);
            i += 1;

        // Rotating riders
        } else if (ch === "\\") {
            var inner, ary;
            
            inner = "";
            while(i < parlett.length)
            {
                i += 1;
                var cho = parlett.substr(i, 1);
                if (cho === "\\") { break; }

                inner += cho;
            }

            // List of rotations in degrees, like \\45,-45\\
            ary = inner.split(",");
            for (var k = 0; k < ary.length; k += 1) {
                rotates.push(parseInt(ary[k], 10));
            }

        // Standard Parlett
        } else if (/[0-9]/.test(ch)) {
            distances.push(parseInt(ch, 10));
        } else if (ch === "n" || ch === "m") {
            distances.push(Infinity);
        } else if (ch === "/") {
            hippogonal = true;
        } else if (ch === " ") {
            assert(false, "decode_one_parlett(" + parlett + "): whitespace encountered, did you forget a comma?");
        } else {
            var maybe_directions = relative_decode_direction(ch, parlett.substr(i + 1, 1));

            if (maybe_directions) {
                directions = maybe_directions.vectors;
                if (maybe_directions.consumed > 1) {
                    i += maybe_directions.consumed - 1; // two-character (or more) direction
                }
            } else {
                assert(false, "decode_one_parlett(" + parlett + "): unsupported: '" + ch + "'");
            }
        }
    }

    if (hippogonal) {
        assert(!hopper, "decode_one_parlett(" + parlett + "): sorry, hippogonal hoppers are not supported");
        assert(distances.length === 2, "decode_one_parlett(" + parlett + "): for hippogonal, expected exactly two distances");
        var a = distances[0], b = distances[1];

        if (a !== Infinity && b !== Infinity) {
            // Hippogonals in all directions
            // TODO: support direction modifiers, vector
            rel_moves.push.apply(rel_moves, without_dupes([
                [-a, -b, flags],
                [-a, +b, flags],
                [+a, -b, flags],
                [+a, +b, flags],

                [-b, -a, flags],
                [-b, +a, flags],
                [+b, -a, flags],
                [+b, +a, flags]
                ]));
        } else {
            // ~n/m, any square on board. Remember, these are relative moves.
            for (var x = -GAME_STATE.files; x <= +GAME_STATE.files; x += 1) {
                for (var y = -GAME_STATE.ranks; y <= +GAME_STATE.ranks; y += 1) {
                    rel_moves.push([x, y, flags]);
                }
            }
        }

        // Hippogonal can be optionally bounds by direction
        if (directions) {
            var keep_relmoves = [];

            for (i = 0; i < directions.length; i += 1) {
                var dir = directions[i];

                for (var j = 0; j < rel_moves.length; j += 1) {
                    var move = rel_moves[j];

                    if ((!dir[0] || signum(move[0]) === signum(dir[0])) &&
                        (!dir[1] || signum(move[1]) === signum(dir[1]))) {
                        keep_relmoves.push(move);
                    }
                }
            }

            rel_moves = keep_relmoves;
        }

    } else if (directions) {
        expand_directions(directions, distances, limit, flags, movement, rel_moves, rotates, hopper);
    }


    // Expand grouping
    if (inner_moves) {
        var outer_moves = rel_moves;
        rel_moves = [];

        if (distances[0]) {
            if (distances[0] === Infinity || !distances[0]) {
                // Close enough
                distances[0] = 5;
            }

            // Nightrider-like piece (hippogonal rider)
            expand_directions(inner_moves, [], distances[0], flags, movement, rel_moves, rotates, hopper);
        }

        // Add inner and outer moves, if both were given, for gryphon, slip pieces
        for (i = 0; i < outer_moves.length; i += 1) {
            var outer = outer_moves[i];

            for (var j = 0; j < inner_moves.length; j += 1) {
                var inner = inner_moves[j];

                var flags = {};
                dojo.mixin(flags, inner[2]);
                dojo.mixin(flags, outer[2]);

                rel_moves.push([outer[0] + inner[0], outer[1] + inner[1], flags]);
            }
        }
    }

    return rel_moves;
}

// Expand a piece in the given directions, distances, up to
// an optional limit, pushing the moves to rel_moves.
// directions: array of direction vectors
// distances: length from origin in direction, often an Infinity
// limit: maximum distance to go in direction, or Infinity
// flags: move flags to add
// movement: "rider" or "leaper"
// rotates: array of degrees to rotate moves after each step
// TODO: hopper: whether a intervening piece (hurdle) is required in the direction to be able to move
function expand_directions(directions, distances, limit, flags, movement, rel_moves, rotates, hopper)
{
    for (i = 0; i < directions.length; i += 1) {
        var dir = directions[i];

        var rel_x, rel_y, prev_rel_x, prev_rel_y, distance;

        // Optional explicit distance instead of all in between (n)
        // Example: 2X, can only move two diagonally, unblocked
        if (distances.length !== 0) {
            distance = distances[0];

            assert(distances.length === 1, "expand_directions(" + distances + "): multiple distances given for rider, expected one or none");
        } else {
            distance = Infinity;
        }

        rel_x = rel_y = 0;
        prev_rel_x = null;
        prev_rel_y = null;

        // Iterate to either given limit or maximum
        var max = limit || Math.max(GAME_STATE.ranks, GAME_STATE.files);

        var count = 0;

        for (var j = 1; j <= max; j += 1) {
            var these_flags = {};

            if (rotates) {
                dir = rotate_direction(dir, rotates[j % rotates.length]);
            }

            // Riders get blocked. Note that you can have a non-hippogonal leaper.
            // ~n* for example, is like a queen, but not blocked by intervening pieces.

            // Blocked on a square which you CANNOT move to - riders w/ distance limits
            if (prev_rel_x !== null && prev_rel_y !== null && 
                    movement === "rider" && distance !== Infinity) { 
                // TODO: Support multiple squares. This only works for one square, for
                // pawn's double-moves. 2> means two forward, unblocked, and it works,
                // but 3> for three forward, unblocked, won't work yet.
                assert(distance === 2,
                        "expand_directions: sorry, only a fixed distance of 2 is " + 
                        "currently supported for riders");

                these_flags.if_unblocked_dx = prev_rel_x;
                these_flags.if_unblocked_dy = prev_rel_y;

            }

 
           // Directions - these were either specified by direction vector code
            // as in n* or hippogonally using ~1/2& (both these expand to >1 direction)
            rel_x += dir[0];
            rel_y += dir[1];

            if (hopper) {
                // Hoppers require a blocking piece (hurdle)
                if (prev_rel_x !== null) {
                    these_flags.if_blocked_dx = prev_rel_x;
                    these_flags.if_blocked_dy = prev_rel_y;

                    // TODO: only allow hopping over one piece (not an overhopper)
                    //these_flags.if_blocked_skip = max - count - 1;
                }  else {
                    // This is one square away from the moving piece.
                    // Skip this move, since no hurdle can fit within in here.
                    // But, set previous x and y since they won't be set at the end
                    // of the loop since we're continue'ing out of it.
                    prev_rel_x = rel_x;
                    prev_rel_y = rel_y;
                    continue;
                }
            }


            dojo.mixin(these_flags, flags);

            // Blocked by a square which you CAN move to - riders w/ no limits except board dimensions
            if (distance === Infinity && movement === "rider" && !hopper) {
                these_flags.if_blocked_skip = max - count - 1;
            }

            if (distance === Infinity || j === distance) {
                rel_moves.push([rel_x, rel_y, these_flags]);
                count += 1;

                if (j === distance) { 
                    break;
                }
            }

            prev_rel_x = rel_x;
            prev_rel_y = rel_y;
        }
    }
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//    [1,2] in [[1,2], [3,4]]
// is false, since 
//    [1,2] === [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
// Note: flags also differentiate a move.
function without_dupes(a)
{
    var hash = {};
    var result = [];

    for (var i = 0; i < a.length; i += 1) {
        // Add if not a dupe
        if (!hash[dojo.toJson(a[i])]) {
            result.push(a[i]);
        }

        // Record that this element was added. Converts to a string,
        // unfortunately, so can't just use own_properties() after filling 
        // in the hash.
        hash[dojo.toJson(a[i])] = true;
    }

    return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
    return {white: "black", black: "white"}[color];
}

function update_check()
{
}

// Set the active color to white or black, or go to the next color (toggling).
// Returns a character for algebraic notation, + = check, etc., if applicable
// If historical, do not check for threefold repetition.
function set_turn(color, historical)
{
    var new_color, checked, no_moves, text_move, text_end, old_color, old_fullmove, repeats;

    old_color = GAME_STATE.active_color;

    if (color === "next") {
        new_color = opposite_color(GAME_STATE.active_color);
    } else if (color === "black" || color === "white") {
        new_color = color;
    } else if (color === "ask") {
        new_color = confirm("Do you want black to start first?") ? "black" : "white";
    } else {
        assert(false, "set_turn(" + color + "): invalid color");
    }

    dojo.byId("status").innerHTML = ucfirst(new_color) + "'s Turn";

    // Move number is incremented after black moves, according to rules.
    old_fullmove = GAME_STATE.fmvn;
    if (color === "next" && GAME_STATE.active_color === "black") {
        GAME_STATE.fmvn += 1;
    }

    GAME_STATE.active_color = new_color;

    // Active player in check?
    var all_opp = calculate_moves(opposite_color(new_color), true);
    VALID_MOVES_OPP = all_opp.moves;
    BLOCKED_MOVES_OPP = all_opp.blocked;
    checked = GAME_STATE.active_in_check = in_check(GAME_STATE.active_color, VALID_MOVES_OPP);

    // Note: this takes some time... is there any way to run it right AFTER the piece has
    // gone through the endeffect? This is called in onDrop.
    // TODO: find out how to run something *after* the endeffect, for smoother UI.
    calculate_moves(GAME_STATE.active_color);

    // Zero mobility? For detecting stalemate, checkmate.
    no_moves = own_property_count(VALID_MOVES) === 0;

    // Results. 
    if (checked && !no_moves) {
        set_check_message("Check!");
        // Show + number of times piece is checked
        // + check, ++ double-check, +++ triple-check, ++++ quadruple-check etc.
        text_move = new Array(checked + 1).join("+")
        // TODO: still use only "+" for algebraic (but keep ++ etc. for descriptive and others)
    } else if (!checked && no_moves) {
        if (GAME_STATE.stalemate === undefined) {
            // Usual rules: stalemate is a draw
            set_check_message("Draw (stalemate)");
            text_end = "&frac12;-&frac12;";

            // Other rules for stalemate for variants, see:
            // http://en.wikipedia.org/wiki/Stalemate#History_of_the_stalemate_rule
        } else if (GAME_STATE.stalemate === "win") {
            // Win for player administering the stalemate (Shatranj, medieval Europe)
            set_check_message(ucfirst(old_color) + " wins (stalemate)");
            text_end = old_color === "white" ? "1-0" : "0-1";
        } else if (GAME_STATE.stalemate === "halfwin") {
            set_check_message(ucfirst(old_color) + " half-wins (stalemate)");
            text_end = old_color === "white" ? "&frac12;-0" : "0-&frac12;";
        } else if (GAME_STATE.stalemate === "loss") { 
            // Win for player being stalemated (9th century India)
            set_check_message(ucfirst(new_color) + " wins (stalemate)");
            text_end = new_color === "white" ? "1-0" : "0-1";
        } else {
            assert(false, "set_turn: invalid stalemate rule: " + GAME_STATE.stalemate);
        }
    } else if (checked && no_moves) {
        set_check_message("Checkmate.");
        if (new_color === "white") { 
            text_move = "#";
            text_end = "0-1";  // white lost
        } else {
            text_move = "#";
            text_end = "1-0";
        }
    } else if (check_insufficient_material()) {
        set_check_message("Draw (material)");
        text_end = "&frac12;-&frac12;";
    } else if (GAME_STATE.hmvc >= 50) {
        set_check_message("Draw (fifty move) claimable");
    } else {
        set_check_message("");
    }

    if (text_end) {
        // So can programmatically tell the game is finished.
        GAME_STATE.ended = text_end;
    }

    var new_state = save_fen();

    var ply = encode_ply(old_color, old_fullmove);

    if (!old_color) {
        // If no one has moved yet, ply is 0 for initial board position.
        ply = 0;
    }

    if (!historical) {
        repeats = check_repetition(ply, active_fen(true));
    }

    if (color === "next") { 
        GAME_STATE.position_after[ply] = new_state;
    }

    set_copyable_link();

    return {text_move: text_move, text_end: text_end, repeats: repeats};
}

// Update the copyable link that goes to the board state
// If this_position, then exports the current board state, otherwise,
// exports the previous board state plus the last move.
function set_copyable_link(this_position)
{
    var fen, captured, last, prior, perspective, url;

    if (this_position) {
        fen = save_fen();
        captured = export_captured();
        perspective = PREFS.flipped;
    } else {
        last = GAME_STATE.position_after.slice(-1)[0];
        prior = GAME_STATE.position_after.slice(-2)[0];

        // TODO: up to N last moves
        var last_move = GAME_STATE.made_moves.slice(-1)[0];

        if (last_move) {
            // Store the previous move and the board state _before_ the move,
            // so it can be made.
            last_move = ";m=" + last_move.notations[PREFS.output_notation];
            if (!prior) {
                // No move has been made yet
                dojo.byId("copyable_link").href = document.URL;
                return;
            }

            fen = prior;
        } else {
            last_move = "";
            fen = last;
        }

        captured = GAME_STATE.last_captured;

        // Flipped if black's turn
        perspective = GAME_STATE.active_color === "black" ? ";f=1" : "";
    }

    if (captured !== "") {
        captured = ";c=" + captured;
    } else {
        captured = "";
    }

    url = make_copyable_link(fen) + captured + last_move + perspective;
    dojo.byId("copyable_link").href = url;
}

// Make a URL that can be clicked to go to this board state
function make_copyable_link(fen)
{
    var base, base_split, query, href;

    assert(fen, "make_copyable_link(" + fen + "): board is required");

    // Get current URL without query string
    base_split = document.URL.split("?");
    base = base_split[0];

    // Replace with characters that do not need to be encoded
    fen = fen.replace(/ /g, "~").replace(/\//g, "|");
    query = "?b=" + encodeURIComponent(fen);

    href = base + query;

    return href;
}

// Set the game check status (or draw, checkmate) message.
function set_check_message(msg)
{
    dojo.byId("check").innerHTML = msg;
    dojo.byId("dash").style.display = msg ? "" : "none";
}

// Return whether there is insufficient material to mate
function check_insufficient_material()
{
    var counts = {}, total = 0, total_bishops = 0;
    var bishops = {white:{white:0, black:0}, black:{white:0, black:0}};
   
    // Count how many of each piece type are on the board
    // TODO: piece lists?
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var square = VBOARD[x][y];

            if (square.piece) {
                // Count all pieces
                if (counts[square.piece.type] === undefined) {
                    counts[square.piece.type] = 1;
                } else {
                    counts[square.piece.type] += 1;
                }
                total += 1;

                // Count color of bishops and squares they are bound to
                if (square.piece.type === "bishop") {
                    bishops[square.color][square.piece.color] += 1;
                    total_bishops += 1;
                }
            }
        }
    }

    // FIDE rules 
    if (total === 2 && counts.king === 2) {
        // king v. king
        return true;
    } else if (total === 3 && counts.king === 2) {
        // king v. king + bishop
        // king v. king + knight
        return counts.bishop === 1 || counts.knight === 1;
    } else if (total === total_bishops + 2 && counts.king === 2 && 
            (bishops.black.black === bishops.black.white ||
             bishops.white.black === bishops.white.white)) {
        // king and bishop(s) versus king and bishop(s) all on same color
        return true;
    }

    return false;
}

// Check for three-move repetition, which allows a draw to be claimed (not compulsory)
function check_repetition(ply, new_state)
{
    var reps;

    // Save new board state for three-move repetition
    if (GAME_STATE.position_moves[new_state] === undefined) {
        GAME_STATE.position_moves[new_state] = [ply];
    } else {

        reps = GAME_STATE.position_moves[new_state].slice();

        // This occurred here, too.
        GAME_STATE.position_moves[new_state].push(ply);

        if (GAME_STATE.position_moves[new_state].length >= 3) {
            // Player can claim a draw, but its not required (you might have a better position)
            // See http://en.wikipedia.org/wiki/Threefold_repetition
            set_check_message("Draw (repetition) claimable");

            // Return moves for highlighting, except this move (it is too early
            // for mark_repeated_moves to highlight, so move_piece_to_square will
            // add the current move, if we return something).
            return reps;
        }
    }

    return null;
}

//// GAME BROWSER FUNCTIONS

// Toggle display of the saved game browser.
function toggle_game_browser()
{
    var browser = dojo.byId("game-browser");
    var grid = dojo.byId("grid");

    if (!grid) {
        // Create once, lazily.
        make_game_browser();
    }

    browser.style.display = (browser.style.display === "none" ? "" : "none");
}

// Create the game library browser widgets.
function make_game_browser()
{
    dojo.require("dojox.grid.DataGrid");
    dojo.require("dojo.data.ItemFileWriteStore");

    // Required CSS, loaded on-demand for faster page load
    load_css("http://o.aolcdn.com/dojo/1.3.1/dojox/grid/resources/tundraGrid.css");
    load_css("http://o.aolcdn.com/dojo/1.3.1/dojox/grid/resources/Grid.css");

    dojo.addOnLoad(function() {
        dojo.xhrGet({url: PREFS.saved_games_path + "index",
            handleAs: "json",
            load: function(games) {
                var browser = dojo.byId("game-browser");
                var grid = new dojox.grid.DataGrid({
                    id: "grid",
                    store: new dojo.data.ItemFileWriteStore({data: 
                            {identifier: "id",
                            label: "id",
                            items: games,
                        }}),
                    structure: [[
                        {name: "White", field: "White", width: "105px"},
                        {name: "Black", field: "Black", width: "105px"},
                        {name: "Event", field: "Event", width: "180px"},
                        {name: "Date", field: "Date", width: "100px"},
                        {name: "Result", field: "SmallResult", width: "70px"},
                        {name: "Moves", field: "MoveCount", width: "90px"},
                        {name: "WhiteElo", field: "WhiteElo", width: "90px"},
                        {name: "BlackElo", field: "BlackElo", width: "90px"},
                        {name: "Opening", field: "OpeningMoves", width: "250px"},
                        {name: "Filename", field: "Filename", width: "100%"}

                    ]]}, document.createElement("div"));
                browser.appendChild(grid.domNode);

                dojo.connect(grid, "onRowClick", function(event) {
                        var item = grid.getItem(event.rowIndex);
                        load_pgn_from_url(PREFS.saved_games_path + item.Filename[0], item.Offset[0]);
                    });

                grid.columnReordering = true;
                //grid.domNode.style.height = "100%";
                grid.domNode.style.overflow = "hidden";
                grid.startup();
                browser.style.display = "";
            },
            error:function(text) {
                      alert("toggle_game_browser XHR error: " + text);
                }
        });
    });
}

// Dynamically load a Cascading Style Sheet
function load_css(url)
{
    var link, head;

    // Based on http://www.javascriptkit.com/javatutors/loadjavascriptcss.shtml
    link = dojo.create("link", {rel: "stylesheet", type:"text/css", href:url});
    head = dojo.query("head")[0];
    head.appendChild(link);
}

//// DISPLAY FUNCTIONS

// Initially draw a board, saving the image data so it can be quickly redrawn 
function create_board()
{
    var canvas, ctx, board_width, board_height, start_x, start_y, max_x, max_y;
    
    canvas = document.getElementById("canvas-board");
    DISPLAY.canvas = canvas;

    if (!canvas.getContext) {
        alert("Sorry, your browser does not support the HTML5 canvas element.");
        return;
    }

    ctx = canvas.getContext("2d");
    DISPLAY.context = ctx;

    canvas.width = GAME_STATE.files * DISPLAY.square_width + DISPLAY.board_left + DISPLAY.board_border*2;
    canvas.height= GAME_STATE.ranks * DISPLAY.square_height + DISPLAY.board_top + DISPLAY.board_border*2;

    // Border
    ctx.strokeStyle = "#000";
    ctx.lineWidth = DISPLAY.board_border;
    board_width = GAME_STATE.files * DISPLAY.square_width;
    board_height = GAME_STATE.ranks * DISPLAY.square_height;
    ctx.strokeRect(DISPLAY.board_left, 
            DISPLAY.board_top, 
            board_width + DISPLAY.board_border, 
            board_height + DISPLAY.board_border);

    ctx.font = DISPLAY.label_font;

    // Draw features below
    draw_features(false);

    ctx.strokeStyle = "#000";
    ctx.lineWidth = DISPLAY.board_border;

    start_x = 0;
    start_y = 0;
    max_x = GAME_STATE.files;
    max_y = GAME_STATE.ranks;

    if (GAME_STATE.on_intersections) {
        // Fewer lines are needed if the pieces are placed on the line intersections.
        start_y = 1;
        max_x -= 1;
    }
    
    for (var x = 0; x < GAME_STATE.files; x += 1) {
        // File labels, on top for white
        var file = (PREFS.flipped ? GAME_STATE.files - x : x + 1);
        var file_label;

        if (PREFS.file_label_style === "Latin") {
            file_label = x2file(file);
        } else if (PREFS.file_label_style === "Arabic") {
            file_label = file.toString();
        } else {
            assert(file, "invalid file_label_style: " + PREFS.file_label_style);
        }

        ctx.fillStyle = DISPLAY.text_color;
        ctx.fillText(file_label, 
                DISPLAY.board_left + DISPLAY.file_labels_left + x * DISPLAY.square_width,
                DISPLAY.file_labels_top);
        // TODO: Optional file labels on bottom for black
    }

    for (var x = start_x; x < max_x; x += 1) {
        // Squares
        ctx.fillStyle = DISPLAY.white;
        for (var y = start_y; y < max_y; y += 1) {
            var rx, ry, rw, rh;

            if (!GAME_STATE.uncheckered) {
                // TODO: look at VBOARD[x][y].color
                ctx.fillStyle = (x + y % 2) % 2 ? DISPLAY.white : DISPLAY.black;
            }
            rx = get_square_x(x + 1);
            ry = get_square_y(y + 1);
            rw = DISPLAY.square_width;
            rh = DISPLAY.square_height;

            if (GAME_STATE.on_intersections) {
                // Pieces on intersections of lines, instead of squares formed by those lines.
                rx += DISPLAY.square_width / 2;
                ry += DISPLAY.square_height / 2;
            }

            if (!GAME_STATE.transparent) {
                ctx.fillRect(rx, ry, rw, rh);
            }

            if (GAME_STATE.ruled) {
                ctx.strokeRect(rx, ry, rw, rh);
            }
        }
    }

    // Rank labels
    // Left side, for white
    ctx.fillStyle = DISPLAY.text_color;
    ctx.textAlign = "center";
    for (var y = 0; y < GAME_STATE.ranks; y += 1) {
        var rank = PREFS.flipped ? y + 1 : GAME_STATE.ranks - y;
        var rank_label;

        if (PREFS.rank_label_style === "Arabic") {
            rank_label = y2rank(rank);
        } else if (PREFS.rank_label_style === "Roman") {
            rank_label = y2rank_wxf("white", rank);
        } else {
            assert(false, "invalid rank label style: " + PREFS.rank_label_style);
        }

        ctx.fillText(rank_label, DISPLAY.rank_labels_left, 
                DISPLAY.rank_labels_top + DISPLAY.square_height * (y + 1), DISPLAY.board_left);
    }
    // TODO: optional rank labels on right side, for black

    ctx.lineWidth = DISPLAY.feature_border_width;

    // Draw features on top
    draw_features(true);

    DISPLAY.clean_board = ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// Board "features": cosmetic embellishments that indicate something
// draw_over determines whether to draw features to be drawn after the board, or before
function draw_features(draw_over)
{
    var ctx = DISPLAY.context;

    if (!GAME_STATE.features) {
        return;
    }

    for (var i = 0; i < GAME_STATE.features.length; i += 1) {
        var feature = GAME_STATE.features[i];
        var rx, ry, rw, rh, color;

        if (!!feature.over !== !!draw_over) {
            continue;
        }

        // White's side first
        if (feature.color === "same") {
            color = DISPLAY.white;
        } else if (feature.color === "opposite") { 
            color = DISPLAY.black;
        } else {
            color = feature.color;
        }

        ctx.strokeStyle = color;
        ctx.fillStyle = color;

        rx = get_square_x(feature.file), 
        ry = get_square_y(feature.rank), 
        rw = feature.width * DISPLAY.square_width, 
        rh = feature.height * DISPLAY.square_height;

        // Shift by half of square, for drawing in between squares.
        // Most useful with on_intersections.
        if (feature.shift_x) {
            rx += DISPLAY.square_width / 2;
        }
        if (feature.shift_y) {
            ry += DISPLAY.square_height / 2;
        }

        draw_feature(ctx, feature, rx, ry, rw, rh);

        // Mirror to black's side of board
        if (feature.color === "same") {
            color = DISPLAY.black;
        } else if (feature.color === "opposite") { 
            color = DISPLAY.white;
        } else {
            color = feature.color;
        }
        ctx.strokeStyle = color;
        ctx.fillStyle = color;

        ry = get_square_y(feature.rank + (GAME_STATE.ranks - feature.height));
        if (feature.shift_y) {
            ry += DISPLAY.square_height / 2;
            // Ugly hack to get black aligned right.
            ry += DISPLAY.square_height;
        }

        draw_feature(ctx, feature, rx, ry, rw, rh);
    }
}

// Draw an individual feature on the board.
function draw_feature(ctx, feature, rx, ry, rw, rh)
{
    if (feature.fill) {
        ctx.fillRect(rx, ry, rw, rh);
    } else if (feature.cross) {
        // Draw an X cross in this area
        ctx.beginPath();

        // \
        ctx.moveTo(rx, ry);
        ctx.lineTo(rx + rw, ry + rh);

        // /
        ctx.moveTo(rx, ry + rh);
        ctx.lineTo(rx + rw, ry);

        ctx.stroke();

    } else {
        ctx.strokeRect(rx, ry, rw, rh);
    }
}


// Restore the board to the clean state, unhighlighting all highlighted black/white squares.
function unhighlight_all()
{
    DISPLAY.highlights = {};
    DISPLAY.context.putImageData(DISPLAY.clean_board, 0, 0);
}

// Get the upper-left x coordinate of a square given file
function get_square_x(file)
{
    return DISPLAY.board_left + DISPLAY.board_border/2 + (PREFS.flipped ? GAME_STATE.files - file : file - 1) * DISPLAY.square_width;
}

// Get the upper-left y coordinate of a square given rank
function get_square_y(rank)
{
    return DISPLAY.board_top + DISPLAY.board_border/2 + (PREFS.flipped ? rank - 1 : GAME_STATE.ranks - rank) * DISPLAY.square_height;
}

// Highlight a square with a given color, or unhighlight it if color is false
function highlight_square(square, color)
{
    var ctx;

    file = square.x;
    rank = square.y;

    ctx = DISPLAY.context;

    if (!color) {
        color = DISPLAY[square.color];
    }

    ctx.fillStyle = color;
    ctx.fillRect(get_square_x(file), get_square_y(rank), DISPLAY.square_width, DISPLAY.square_height);
}

// Push a layer of a highlight color to a square, coloring the square that color.
function push_highlight(square, color)
{
    if (!DISPLAY.highlights[square.filerank] || DISPLAY.highlights[square.filerank].length === 0) {

        var sx = get_square_x(square.x);
        var sy = get_square_y(square.y);
        var sw = DISPLAY.square_width;
        var sh = DISPLAY.square_height;

        DISPLAY.highlights[square.filerank] = [];
        DISPLAY.native_square_images[square.filerank] = DISPLAY.context.getImageData(sx, sy, sw, sh);
    }


    DISPLAY.highlights[square.filerank].push(color);

    highlight_square(square, color);

    return DISPLAY.highlights[square.filerank];
}

// Peel off a highlighted color and reveal the color underneath.
function pop_highlight(square)
{
    var stack, color, old_color;

    if (!square) { 
        return;
    }

    stack = DISPLAY.highlights[square.filerank];

    if (!stack || stack.length === 0) {
        // Nothing to pop
        return;
    }

    // Remove current color
    old_color = stack.pop();

    if (!stack || stack.length === 0) {
        // Native square color
        var native_image = DISPLAY.native_square_images[square.filerank];

        assert(native_image, "pop_highlight(" + square.filerank + "): no native image");

        DISPLAY.context.putImageData(native_image, get_square_x(square.x), get_square_y(square.y));

        return native_image;
    } else {
        // Color underneath is now top of stack
        color = stack[stack.length - 1];
        
        highlight_square(square, color);

        return color;
    }
}

//// BOARD FUNCTIONS

// Load the virtual board into the displayed board. Any number of operations
// can be conducted on the virtual in-memory board, then when it is finished,
// only then does the board need to be rendered in HTML. 
function realize_vboard()
{
    var time_started = new Date().getTime();

    // Delete all prior onboard pieces
    dojo.query(".piece").forEach(function(piece) {
            if (!dojo.hasClass(piece, "tear-off") && !dojo.hasClass(piece, "captured")) {
                piece.parentNode.removeChild(piece);
            }
    });

    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var v = VBOARD[x][y];
            var piece;

            if (v.piece) {
                piece = create_piece(v.piece.color, v.piece.type);

                dojo.attr(piece, "id", "piece-at-" + xy2filerank({x:x, y:y}));

                piece.square = VBOARD[x][y];
                // TODO: what about descriptive_name, adescriptive_name?? It is important.
                piece.unique_id = v.piece.unique_id;

                piece.style.position = "absolute";

                // TODO: find out why this is off
                piece.style.left = get_square_x(x) + 4 + "px";
                piece.style.top = get_square_y(y) + 3 + "px";
                dojo.body().appendChild(piece);
            }
        }
    }

    // On my machine:
    // Safari 4: 5 ms
    // Firefox 3.0.10: 21 ms
    // MSIE7: 100+ ms, noticeably slower piece dropping
    var time_took = new Date().getTime() - time_started;
    //alert("realize_vboard took " + time_took + " ms");
}

// Toggle perspective of board
function flip()
{
    PREFS.flipped = !PREFS.flipped;
    dojo.byId("enable_flip").checked = PREFS.flipped;

    create_board();
    load_fen(save_fen(), true);

    // BUG: if edit board, then flip it, lose changes. TODO: fix
}

// Initialize the VBOARD square cells with their (x,y) coordinates
// and filerank notation, once when the page loads. 
function clear_board()
{
    VBOARD = [];
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        VBOARD[x] = [];
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            VBOARD[x][y] = {virtual:true};
            var square = VBOARD[x][y];

            square.x = x;
            square.y = y;
            square.filerank = xy2filerank({x:x, y:y});
            // Store the square color here once, so can always lookup .color, 
            // never have to check the white/black class name again.
            square.color = (x + y % 2) % 2 ? "white" : "black";

            square.descriptive = {};
            square.descriptive.white = x2descriptive(x) + y_from_perspective("white", y).toString();
            square.descriptive.black = x2descriptive(x) + y_from_perspective("black", y).toString();
        }
    }
}

// Key is pressed
function onkeydown(event)
{
    event = event || window.event;

    if (!event.keyCode) { 
	return;
    }
    // TODO: type move to do it

    // Shift opens piece inspector. Usually it is invoked on mouse
    // over if shiftKey is held down; this case catches if shift is
    // pressed while the mouse is /already/ over the piece.
    if (event.keyCode === 16) {
	GAME_STATE.shift = true;
	if (GAME_STATE.piece_under) {
	    show_piece_inspector(GAME_STATE.piece_under);
	    over_piece(GAME_STATE.piece_under, {});
	}
    }
}

// Key is released
function onkeyup(event) 
{
    event = event || window.event;

    if (!event.keyCode) {
        return;
    }

    // Releasing shift closes piece inspector
    if (event.keyCode === 16) {
        if (GAME_STATE.shift === 1) {
            // When releasing shift, unhighlight opponent's moves, if any
            var save = GAME_STATE.piece_under;
            out_piece(GAME_STATE.piece_under, {});
            GAME_STATE.piece_under = save;
        } else if (GAME_STATE.shift && GAME_STATE.piece_under) {
            // When releasing shift, unhighlight our own blocked moves.
            highlight_moves(GAME_STATE.piece_under, false, false);

            // TODO: fix highlights when mousing over w/ shift
            pop_highlight(GAME_STATE.piece_under.square);
        }

        GAME_STATE.shift = false;
        hide_piece_inspector();
    }

    // If typing in custom movement field, update it
    if (GAME_STATE.update_custom) {
        var control = dojo.byId("custom-movement");
        var custom_pieces = dojo.query(".custom.piece");
        var should_alert = GAME_STATE.alert_assert;

        unhighlight_all();

        PIECE_TYPES.custom.parlett = control.value;
        GAME_STATE.alert_assert = false;
        try {
            calculate_moves(GAME_STATE.active_color);
            control.style.backgroundColor = "";
            dojo.attr(control, "title", "");
        } catch(err) {
            control.style.backgroundColor = "red";
            dojo.attr(control, "title", "Error: " + err);
        }
        for (var i = 0; i < custom_pieces.length; i += 1) {
            highlight_moves(custom_pieces[i], true);
        }

        GAME_STATE.alert_assert = should_alert;
    }

    if (GAME_STATE.update_piece_query) {
        update_piece_library();
    }
}

// Initialize the board - menu, load from query string if present.
// Only needs to be performed once per page load.
function init_board()
{
    GAME_STATE = dojo.clone(GAME_STATE_DEFAULT);

    var board_menu = dojo.byId("saved_board_menu");

    // Create saved boards for openings, since they are stored by
    // board position rather than name.
    SAVED_BOARDS["Chess Openings"] = {};
    for (var opening_board in OPENINGS) {
        if (OPENINGS.hasOwnProperty(opening_board)) {
            var opening_name = OPENINGS[opening_board];

            SAVED_BOARDS["Chess Openings"][opening_name] = opening_board;
        }
    }

    document.onkeydown = onkeydown;
    document.onkeyup = onkeyup;


    // Get board name in cookie, if any. This lets the user select
    // their favorite board, and revisit the page, and it will
    // automatically load, instead of standard chess.
    var selected_board_group = dojo.cookie("board_group");
    var selected_board_name = dojo.cookie("board_name");
    if (!selected_board_name) {
        selected_board_group = DEFAULT_BOARD_GROUP;
        selected_board_name = DEFAULT_BOARD_NAME;
    }

    // Saved boards by group
    var index = 0, sel_index;
    for (var group_name in SAVED_BOARDS) {
        if (SAVED_BOARDS.hasOwnProperty(group_name)) {
            var members = SAVED_BOARDS[group_name];

            var group = dojo.create("optgroup", {label:group_name});
            board_menu.appendChild(group);

            for (var board_name in members) {
                if (members.hasOwnProperty(board_name)) {
                    var fen = members[board_name];
                    if (group_name === selected_board_group && board_name === selected_board_name) {
                        sel_index = index;
                    }
                    group.appendChild(dojo.create("option", 
                                {value: fen, innerHTML:board_name}));
                    index += 1;
                }
            }
        }
    }

    // Select loaded board. Could use selected attribute, but Firefox selects last item,
    // unless we set selectedIndex, so just do that.
    board_menu.selectedIndex = sel_index;

    var fen = SAVED_BOARDS[selected_board_group] && SAVED_BOARDS[selected_board_group][selected_board_name];
    if (!fen) {
        // Cookie corrupted? Load default.
        fen = SAVED_BOARDS[DEFAULT_BOARD_GROUP][DEFAULT_BOARD_NAME];
        board_menu.selectedIndex = 0;
    }

    if (!load_from_query_string()) {
        load_fen(fen);
    }

}

// Load board from URL query string, if any
function load_from_query_string()
{
    var query = query_string();
    if (!query.b) {
        // No board given
        return false;
    }

    // Flip/unflip board as needed. Avoid doing this unless
    // there is a change in the flip state, as it is expensive.
    // Needs to be done before loading.
    if (!!query.f !== !!PREFS.flipped) {
        PREFS.flipped = !!query.f;
    }


    // TODO: convert query to PGN, then load that

    query.b = query.b.replace(/~/g, " ").replace(/\|/g, "/");
    load_fen(query.b);

    if (query.m) {
        dojo.forEach(query.m.split(","), function(move_text) {
                mv(move_text);
            });
    }

    if (query.c) {
        import_captured(query.c);
        update_captured_piece_images();
    }

    // Succeeded
    return true;
}



// Load a board from the drop down menu of SAVED_BOARDS.
function change_loaded_board(menu)
{
    var fen;

    if (!menu.value) {
        return;
    }

    var option = menu.options[menu.selectedIndex];
    var group = option.parentNode.label;        // optgroup 
    var name = option.innerHTML;
    dojo.cookie("board_group", group);
    dojo.cookie("board_name", name);

    fen = SAVED_BOARDS[group][name];

    dojo.byId("variant_code").style.display = "none";

    load_fen(fen);
}

// Acknowledge that a piece was captured. Called by move_piece_to_square(), which
// does all the board manipulation. 
function piece_was_captured(piece, square)
{
    // If rook captured, remove castling privileges
    if (PIECE_TYPES[piece.type].castle) {
        // Note that this is the first rank of the *other* player
        var opponent = opposite_color(GAME_STATE.active_color);
        var first_rank = opponent === "white" ? 1 : GAME_STATE.ranks;
       
        var castles_at = castles_come_from();

        // If captured rook, opponent cannot castle with it.
        if (square.y === first_rank) {
            if (square.x === castles_at.long_x) {
                GAME_STATE.can_castle[opponent][castles_at.long_file] = false;
            } else if (square.x === castles_at.short_x) {
                GAME_STATE.can_castle[opponent][castles_at.short_file] = false;
            }
        }
    }

    GAME_STATE.captured[piece.color].push(piece);
    update_captured_piece_images();
}

// Show captured with icons from GAME_STATE.captured
function update_captured_piece_images(piece)
{
    var captured = dojo.byId("captured_piece_images");

    captured.innerHTML = "";

    // Make miniature images. In this case it is better to specify the full
    // image size and have the browser scale it, instead of having it reference
    // a pre-scaled image, because of the higher latency involved in another request.
    var html = "";
    for (var i = 0; i < GAME_STATE.captured.white.length; i += 1) {
        var p = GAME_STATE.captured.white[i];
        // TODO: Allow in some games for these pieces to be dragged back to board.
        // Currently you can't really, even in setup mode.
        // For Shogi (but captured pieces would need to change colors), where can drop
        // captured pieces back onto the board. create_piece() then add captured class.
        var piece = create_piece(p.color, p.type);
        dojo.addClass(piece, "captured");

        captured.appendChild(piece);
    }
    for (var i = 0; i < GAME_STATE.captured.black.length; i += 1) {
        var p = GAME_STATE.captured.black[i];

        var piece = create_piece(p.color, p.type);
        dojo.addClass(piece, "captured");

        captured.appendChild(piece);
    }
}

// Get all the move notation texts and moves for a given piece and destination
// square combination. Returns an object structured by a property for each
// promotion piece type (queen, knight, etc.) or undefined if not a promotion,
// then with keys: move, piece, square, and notations. The notations
// object has properties for each notation type, with strings as values.
// promote_to optionally narrows down the move to a specific promotion, otherwise,
// all promotion moves are returned (if it is a promotion).
function get_notations(piece, square, promote_to)
{
    var finds = {};
    var last_key;

    assert(piece.unique_id !== undefined, "get_notations(" + piece + ", " + square +
            ", " + promote_to + "): unique_id not defined for piece");

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var texts = VALID_MOVE_NOTATIONS[notation];

            for (var text in texts) {
                if (texts.hasOwnProperty(text)) {
                    var this_square = texts[text].square;
                    var this_piece = texts[text].piece;
                    var this_move = texts[text].move;

                    if (this_square.x === square.x && this_square.y === square.y && 
                        this_piece.unique_id === piece.unique_id &&
                        (!promote_to || this_move.promote_to === promote_to)) {

                        // Key by final piece type. Promotion type, if any.
                        var key = this_move.promote_to || "undefined";
                        last_key = key;

                        if (!finds[key]) {
                            finds[key] = {
                                move: this_move, 
                                square: this_square,
                                from_square: this_piece.square,
                                piece: this_piece,
                                notations: {}};
                        }

                        finds[key].notations[notation] = text;
                    }
                }
            }
        }
    }
  
    // Ensure that the 'undefined' key is always defined, so that for
    // promotions, the first half of the move can still be completed
    // without having a chosen promotion piece.
    // TODO
    /*if (!finds.undefined) {
        finds.undefined = finds[last_key];
    }*/

    return finds;
}

// Get the move(s) for the given piece moving to the given square, in all of the
// available move notations.
// TODO: kill XXX
function all_notations_from_piece_square(piece, square, text_input)
{
    var notation, results = {};

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            results[notation] = notation_from_piece_square(piece, square, text_input, notation);
        }
    }

    return results;
}

// Find precomputed algebraic notation for this move. Called when
// user drags a piece to a square and we don't know what move it is.
function notation_from_piece_square(piece, square, text_input, notation_type)
{
    notation_type = notation_type || PREFS.output_notation;
    var notations = VALID_MOVE_NOTATIONS[notation_type];
    var finds = {}, find_count = 0, one;

    // TODO: better data structure, inverted hash table lookup
    for (var notation in notations) {
        if (notations.hasOwnProperty(notation)) {
            var this_piece = notations[notation].piece;
            var this_square = notations[notation].square;
            var this_move = notations[notation].move;

            if (this_square.x === square.x && this_square.y === square.y && 
                this_piece.unique_id === piece.unique_id &&
                // TODO: if given text_input, lookup more directly
                (!text_input || text_input === notation)) {

                notation.move = this_move;

                one = {notation:notation, move:this_move};
                finds[notation] = one;
                find_count += 1;

                if (!this_move.promote_to) {
                    // Speed hack: no-promotion moves are unique by pc+sq
                    return one;
                }
            }
        }
    }

    if (find_count === 0) {
        return null;
    } else if (find_count === 1) {
        return one;
    } else {
        // When player drags a pawn to the last rank to be promoted,
        // four moves will be found, and they'll have to choose. Make this appear
        // to be the last found promotion option, since they all have the same
        // location, and the piece will be able to move into place before the 
        // user piece selection is made.
        return dojo.mixin(one, {multiple:true, choices:finds});
    }
}

// Get the direction vector (y component only) that is "forward" for the given color
function forwards_vector(color)
{
    if (color === "white") {
        return 1;
    } else { 
        return -1;
    } 
}



// Make a ply or half-ply move (promotion) on the virtual board given piece + square.
// If is_hypothetical is true, this is an internal move part of another move
// (castling) so it shouldn't be logged.
// If is_immediate, then finish_up_move() will realize the virtual board.
// If piece_square.promote_to is given, it is the name of the piece type to promote to - along with
// piece and square, this uniquely identifies a move (a1Q, a1N, etc.) whereas if only
// piece + square are given, the promotion piece type will have to be queried.
function move_piece_to_square(piece, square, is_hypothetical, is_immediate)
{
    var choices, surrogate;

    // Get all possible moves for this piece+square combination, keyed
    // by promotion type (or undefined). A move like c8 as invoked by drag
    // and drop expands here to c8Q, c8N, c8R, c8B.
    choices = get_notations(piece, square);
    assert(choices, "move_piece_to_square(" + piece + ", " + square + "): could not find notation");

    execute_move(undefined, choices, is_hypothetical, is_immediate);
}

// Get the file numbers of where the castles are originally, or where they were.
// For chess1, this is {clong:1,cshort:8}, but in Chess960 it can be different.
function castles_come_from()
{
    var cs = GAME_STATE.can_castle.white;  // same existance for black and white
    var files = [], ret = {};

    for (var i = 0; i < GAME_STATE.files; i += 1) {
        var file = x2file(i + 1);
        var file_no = i + 1;

        if (cs[file] !== undefined) {
            files.push(file_no);
        }
    }

    ret.long_x = files[0];
    ret.short_x = files[1];

    if (ret.long_x !== undefined) {
        ret.long_file = x2file(ret.long_x);
    }

    if (ret.short_x !== undefined) {
        ret.short_file = x2file(ret.short_x);
    }

    return ret;
}

// Highlight the squares a piece recently moved from and to
function highlight_recent_move(from_square, to_square)
{
    push_highlight(from_square, DISPLAY["recent_move_" + from_square.color]);
    push_highlight(to_square, DISPLAY["recent_move_" + to_square.color]);
}

// Make a move, or half-move, given choices.
// promote_to is either the name of a piece to promote to, or undefined
// choices is an object keyed by the list of choices to promote to
// If is_hypothetical, the consequences of the move are not updated
// If is_immediate, the UI is updated
function execute_move(promote_to, choices, is_hypothetical, is_immediate) 
{
    var piece, square, promote_to, animate;
    var from_square, move_text, filerank, only_move, move, one;

    unhighlight_all();
  
    if (choices[promote_to]) {
        one = choices[promote_to];
    } else {
        // Surrogate move, for location only
        for (var any in choices) {
            if (choices.hasOwnProperty(any)) {
                one = choices[any];
                break;
            }
        }
    }

    assert(one, "execute_move(" + promote_to + ", " + choices[promote_to] + "): move not found!");

    move = one.move;
    piece = one.piece;
    square = one.square;
    from_square = piece.square;
    one.from_square = one.piece.square;

    // If castling, move the rook in place. 
    if (PIECE_TYPES[piece.type].castles_with) {
        var come_from = castles_come_from();

        // We rely on can_castle to indicate whether the king/rook have moved.
        if (GAME_STATE.can_castle[GAME_STATE.active_color][come_from.short_file] && 
                    (square.x === GAME_STATE.castle_moves.cshort.king_to    // king moves two spaces (Chess1)
                     || square.x === come_from.short_x)                     // king captures rook (Chess960)
                    ) {

            // Move rook. Use do_virtual_move instead of move_piece_to_square, since 
            // this rook move may not be valid otherwise. 
            do_virtual_move(pc(come_from.short_x, square.y), {x:GAME_STATE.castle_moves.cshort.castle_to, y:square.y, ignore_self_capture:true});

            // Move king to destination square, instead of over rook.
            move = {x:GAME_STATE.castle_moves.cshort.king_to, y:square.y, ignore_self_capture:true};

            if (!is_hypothetical) {
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.short_file] = false;
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.long_file] = false;
            }
        } else if (GAME_STATE.can_castle[GAME_STATE.active_color][come_from.long_file] && 
                    (square.x === GAME_STATE.castle_moves.clong.king_to
                     || square.x === come_from.long_x) 
                    ) {

            do_virtual_move(pc(come_from.long_x, square.y), {x:GAME_STATE.castle_moves.clong.castle_to, y:square.y, ignore_self_capture:true});

            move = {x:GAME_STATE.castle_moves.clong.king_to, y:square.y, ignore_self_capture:true};

            if (!is_hypothetical) {
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.short_file] = false;
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.long_file] = false;
            }
        }
    }


    if (!is_hypothetical) {
        // Pieces captured /before/ this move
        GAME_STATE.last_captured = export_captured();

        var castles_at = castles_come_from();

        // If moved either rook, can't castle on that side.
        if (PIECE_TYPES[piece.type].castle) {
            if (from_square.x === castles_at.short_x) {
                GAME_STATE.can_castle[GAME_STATE.active_color][castles_at.short_file] = false;
            } else if (from_square.x === castles_at.long_x) {
                GAME_STATE.can_castle[GAME_STATE.active_color][castles_at.long_file] = false;
            }
        }

        // If moved king, cannot castle on either side.
        if (PIECE_TYPES[piece.type].castles_with) {
            GAME_STATE.can_castle[GAME_STATE.active_color][castles_at.short_file] = false;
            GAME_STATE.can_castle[GAME_STATE.active_color][castles_at.long_file] = false;
        }


        // If moved pawn, or was a capture, reset fifty move rule counter
        if (move.capture || PIECE_TYPES[piece.type].resets_50move) {
            GAME_STATE.hmvc = 0;
        } else {
            GAME_STATE.hmvc += 1;
        }

        if (is_immediate) {
            // Animate the movement
            var from_image = dojo.byId("piece-at-" + from_square.filerank);
            dojo.anim(from_image, {left:get_square_x(square.x) + 4,
                    top:get_square_y(square.y) + 3}, PREFS.movement_animation_time, null, function() {
                        highlight_recent_move(from_square, square);
                        continue_execute_move(piece, square, move, 
                            is_hypothetical, choices, promote_to, is_immediate);
                    } 
                    );
        } else {
            // Not immediate, so do not animate or highlight square. 
            // Caller doesn't want any UI changes.
            continue_execute_move(piece, square, move, 
                is_hypothetical, choices, promote_to, is_immediate);
        }
    } else {
        continue_execute_move(piece, square, move, 
                is_hypothetical, choices, promote_to, is_immediate);
    }
}

// Continue execute_move(), after animating the piece movement, if desired.
function continue_execute_move(piece, square, move, is_hypothetical, choices, promote_to, is_immediate)
{
    var did, filerank;

    did = do_virtual_move(piece, move);
    if (did.captured) {
        piece_was_captured(did.captured, did.capture_square);
    }
    if (did.self_destructed) {
        piece_was_captured(did.piece, did.to_square);
    }

    if (!is_hypothetical) {
        // If double pawn move, this creates an en passant target square
        filerank = xy2filerank(square);
        if (move.create_ep_target) {
            GAME_STATE.ep_target = move.create_ep_target;
        } else {
            // En passant possibility disappears immediately after any other move
            GAME_STATE.ep_target = null;
        }
    }

    if (should_promote(piece)) {
        if (own_property_count(choices) > 1) {
            // Piece+square move, need input from user: what piece 
            ask_to_promote(piece, choices, is_immediate);
        } else {
            for (var a in choices) {
                if (choices.hasOwnProperty(a)) {
                    promote_to = a;
                }
            }
            // Piece+square+piece to promote has been given (probably from mv())
            promote(piece, square, promote_to, choices.notation, is_immediate);
        }
    } else {
        // If not a multi-move (moving rook in castling), log and go to next turn
        if (!is_hypothetical) {
            finish_up_move(choices, is_immediate, undefined);
        }
    }


    // TODO: return from finish_up_move, deferred? promotions..
    // To allow undo_virtual_move
    //return did;

}

// Perform bookkeeping on the move after it has been actually made, 
// in move_piece_to_square().
// promote_to is the type for promotions, or undefined otherwise.
function finish_up_move(tieback, is_immediate, promote_to)
{
    var alg_move, ply, turn_info, move_text, info;

    if (is_immediate) {
        // Display the new board state
        realize_vboard();
    }

    info = tieback[promote_to];

    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fmvn);
  
    info.only_move = own_property_count(VALID_MOVE_NOTATIONS.SAN) === 1;
    turn_info = set_turn("next", false);

    if (turn_info.text_move) { info.add_text = turn_info.text_move; }
    if (turn_info.text_end) { info.text_end = turn_info.text_end; } 
    // If there was a repetition, it occurred on this move. Indicate the moves.
    if (turn_info.repeats) { 
        turn_info.repeats.push(ply);
        info.repeats = turn_info.repeats;
    }

    // Save for history
    GAME_STATE.made_moves[ply] = info;

    var opening = OPENINGS[active_fen(true)];
    if (opening) {
        dojo.byId("opening_name").innerHTML = opening;
    }
    // If not recognized, do not clear it -- keep up opening during the game

    if (is_immediate) {
        set_copyable_link();

        // TODO: don't send if was remote! 
        send_remote_move(GAME_STATE.active_color, tieback[promote_to].notations.SAN, active_fen(true), ply);

        show_move_history();
        populate_make_a_move_list();
        computer_move_if_applicable();
   }
}

// Fill in move_history with the move history
function show_move_history()
{
    var htmls = [], repeats = [];
    var first = true;

    for (var ply = 1; ply < GAME_STATE.made_moves.length; ply += 1) {
        var color_fullmove, color, fmvn, move_text, move_info, only_move;

        color_fullmove = decode_ply(ply);
        color = color_fullmove.color;
        fmvn = color_fullmove.fmvn;

        move_info = GAME_STATE.made_moves[ply];
        if (!move_info && ply > 1) {
            // Skip missing moves, except ply 1
            continue;
        }


        if (move_info) {
            move_text = move_info.notations[PREFS.output_notation];
        } else {
            // Ply 1 does not exist. Include the fmvn, but not the link,
            // so that the period can link to ply_0.
            move_text = null;
            move_info = {};
        }

        if (color === "white") {
            htmls.push('<span class="fmvn">' + fmvn + '<\/span>');
            // Period goes to initial position, kind of strange, but its uninstrusive
            htmls.push(first ? move_link(0, ".") : ".");
        } else {
            // Ellipsis if black is first recorded move,
            // TODO: or intervening commentary
            if (first) {
                htmls.push('<span class="fmvn">' + fmvn + '<\/span>');
                htmls.push(first ? move_link(0, ".") : ".");
                htmls.push("&hellip; ");
            }
        }

        if (move_text !== null) {
            htmls.push(" " + move_link(ply, move_text));
        }

        if (move_info.only_move) {
            // NAG for "only move", see http://www.markalowery.net/Chess/Notation/NAG.html
            htmls.push("$7 ");
        }

        if (GAME_STATE.annotations[ply]) {
            // TODO: decode NAGs, like $n, into !!
            htmls.push('<span class="move_annotation">');
            for (var a = 0; a < GAME_STATE.annotations[ply].length; a += 1) {
                var note = GAME_STATE.annotations[ply][a];
                var note_text = "";

                if (note.charAt(0) === "$") {
                    var nag_code = parseInt(note.substring(1), 10);
                    if (NAGS[nag_code].length > 2) {
                        note_text = " ";
                    } 
                    note_text += NAGS[nag_code];
                } else {
                    note_text = " " + note;
                }
                htmls.push(note_text + " ");
            }

            htmls.push("</span>");
        }

        if (move_info.add_text) {
            htmls.push(move_info.add_text);
        }

        if (move_info.repeats) {
            repeats.push(move_info.repeats);
        }

        // End-text, not a move. Terminates the game.
        if (move_info.text_end) {
            htmls.push("\n" + move_info.text_end);
        }

        htmls.push(" ");

        first = false;
    }

    var last_ply = GAME_STATE.made_moves.length - 1;

    dojo.byId("move_history").innerHTML = htmls.join("");

    // Mark repeated moves for threefold repetition, after showing this move.
    dojo.forEach(repeats, function(peat) {
            mark_repeated_moves(peat);
        });

    // Last ply
    dojo.query("a.active_move").forEach(function(m) {
            dojo.removeClass(m, "active_move");
        });

    set_next_back_accesskeys(last_ply);
}

// Visually indicate the moves which after threefold repetition
// Unfortunately, we highlight the move *after* the board state was repeated. This is
// because the first clickable link, say 1. Nf3, loads the move after
// Nf3 was made, not before (the initial board position). But you can
// repeat the initial board position:
// 1. Nf3 Nf6 2. Ng1 Ng8 3. Nf3 Nf6 4. Ng1 Ng8
var HIGHLIGHT_COLORS = ["yellow", "aquamarine", "lime", "khaki", "aqua"];
var REPEAT_COLOR_COUNT = 0;
function mark_repeated_moves(reps)
{
    var color = HIGHLIGHT_COLORS[REPEAT_COLOR_COUNT];

    REPEAT_COLOR_COUNT += 1;
   
    for (var i = 0; i < reps.length; i += 1) {
        var ply = reps[i];
        var link = dojo.byId("ply_" + ply);

        // TODO: fix
        assert(link, "mark_repeated_moves(" + reps + "): no such ply " + ply);

        dojo.style(link, "background-color", color);
    }
}

// Handle graphically moving of a piece, dropping it to its new location
function move_dropped_piece(piece, square, event)
{
    if (PREFS.setup_mode) {
        var from_square = piece.square;

        if (piece.unique_id === undefined) {
            // Assign unique ID to new piece
            piece.unique_id = xy2filerank(square) + full_piece_prefix(piece);
        }
        do_virtual_move(piece, {x:square.x, y:square.y});
        unhighlight_all();

        realize_vboard();
        set_copyable_link(true);    // this board state
        return;
    }


    var virtual_square = VBOARD[square.x][square.y];
    var virtual_piece = VBOARD[piece.square.x][piece.square.y].piece;

    // Move the piece in the virtual board and realize it.
    setTimeout(function() { 
            move_piece_to_square(virtual_piece, virtual_square, false, true) 
        }, 0);
}

// Get the representation of the active board state in FEN.
// If strip_moves, return time-independent representation.
function active_fen(strip_moves)
{
    var fen = GAME_STATE.position_after.slice(-1)[0];

    if (strip_moves) {
        // Remove last two fields, move counts.
        fen = fen.split(" ").slice(0, -2).join(" ");
    } 

    return fen;
}

// Generate FEN from board state. Use active_fen() to get
// this if it already been calculated.
function save_fen()
{
    var fens = [], castles;

    // Board position
    for (var y = GAME_STATE.ranks; y > 0; y -= 1) {
        var blanks = 0;
        for (var x = 1; x <= GAME_STATE.files; x += 1) {
            var piece = VBOARD[x][y].piece;
            var letter;

            if (piece) {
                if (blanks) {
                    fens.push(blanks.toString());
                    blanks = 0;
                }
                letter = full_piece_prefix(piece);

                // Uppercase = white, lowercase = black
                if (piece.color === "black") {
                    letter = letter.toLowerCase();
                }

                fens.push(letter);
            } else {
                blanks += 1;
            }
        }
        if (blanks) {
            fens.push(blanks.toString());
        }
        if (y !== 1) {
            fens.push("/");
        }
    }

    // Active color
    fens.push(" ");
    if (GAME_STATE.active_color === "white") {
        fens.push("w");
    } else {
        fens.push("b");
    }

    // Castling availability. Use Shredder-FEN for non-corner rooks, or 
    // classical FEN if corner rooks. Unfortunately, this allows for a 
    // mix of both if one castle is at the edge (K/Q), and the other isn't (B-G).
    fens.push(" ");
    castles = false;
    var come_from = castles_come_from();

    if (GAME_STATE.can_castle.white[come_from.short_file]) { 
        fens.push(come_from.short_x === GAME_STATE.files ? "K" : come_from.short_file.toUpperCase()); 
        castles = true; 
    }
    if (GAME_STATE.can_castle.white[come_from.long_file])  { 
        fens.push(come_from.long_x === 1 ? "Q" : come_from.long_file.toUpperCase()); 
        castles = true; 
    }
    if (GAME_STATE.can_castle.black[come_from.short_file]) { 
        fens.push(come_from.short_x === GAME_STATE.files ? "k" : come_from.short_file); 
        castles = true; 
    }
    if (GAME_STATE.can_castle.black[come_from.long_file])  { 
        fens.push(come_from.long_x === 1 ? "q" : come_from.long_file); 
        castles = true; 
    }
    if (!castles) { fens.push("-"); }

    // En passant target square
    fens.push(" ");
    if (GAME_STATE.ep_target) {
        fens.push(xy2filerank(GAME_STATE.ep_target));
    } else {
        fens.push("-");
    }

    // TODO: EPD tags
    /*for (var i = 0; i < GAME_STATE.tags.length; i += 1) {
        var tag = GAME_STATE.tags[i];
        fens.push(" " + tag);
        if (tag */
    fens.push(" hmvc=" + GAME_STATE.hmvc);
    fens.push(" fmvn=" + GAME_STATE.fmvn);

    // Captured pieces
    var captured = export_captured();
    if (captured) {
        fens.push(" captured_pieces=" + captured);
    }

    return fens.join("");
}

// Fields to be parsed as integers instead of strings
var EPD_INTEGER_FIELDS = {acn:1, acs:1, ce:1, dm:1, fmvn:1, hmvc:1, rc:1};

// Parse the Extended Position Description (EPD) codes from the 
// end of a pre-split EPD field, returning a dictionary.
function parse_epd_opcodes(parts)
{
    var dict = {};

    for (var i = 4; i < parts.length; i += 1) {
        var part = parts[i];
        var a = part.split("=");
        var key, value;
        if (a.length === 1) {
            // Booleans: draw_accept, draw_claim, etc.
            key = a[0];
            value = true;
        } else {
            key = a.shift();
            value = a.join("=");
        }

        if (EPD_INTEGER_FIELDS[key]) {
            value = parseInt(value, 10);
        }

        dict[key] = value;
    }
    
    return dict;
}


// Load board state in Forsyth-Edwards Notation (FEN) or Extended Position Description (EPD).
// The fen can either be a string of EPD/FEN, or a function that returns the string.
// If replay is true, this is reloading an existing position, not loading a new game.
// TODO: support any base 10 number (10 for skip ten spaces), and asterisks for filling remainder of rank with empty
// spaces, and {} for labels, see http://play.chessvariants.org/pbm/devguide.html
// TODO: Shogi variants http://www.mafiascum.net/wiki/index.php?title=Shogi_variant
function load_fen(fen, replay)
{
    var parts, castling, color, back_castles;

    if (dojo.isFunction(fen)) {
        fen = fen();
    }

    parts = fen.split(" ");


    castling = parts[2]; // parsed below, after know dimensions

    color = {w:"white", b:"black", "?":"ask"}[parts[1]];
    assert(color, "load_fen(" + fen + "): bad active color: " + parts[1]);

    if (!replay) {
        GAME_STATE = dojo.clone(GAME_STATE_DEFAULT);
    }

    if (parts[3] === "-") {
        GAME_STATE.ep_target = null;
    } else {
        GAME_STATE.ep_target = filerank2xy(parts[3]);
    }

    if (!isNaN(parseInt(parts[4], 10))) {
        // FEN has halfmove clock and fullmove number in 5th and 6th fields
        GAME_STATE.hmvc = parseInt(parts[4], 10);
        GAME_STATE.fmvn = parseInt(parts[5], 10);
    } else {
        // EPD (Extended Position Description), has opcodes instead

        // defaults
        GAME_STATE.hmvc = 0;
        GAME_STATE.fmvn = 1;

        dojo.mixin(GAME_STATE, parse_epd_opcodes(parts));
    }

    if (GAME_STATE.rs) {
        // Game "rule set"
        dojo.mixin(GAME_STATE, RULE_SETS[GAME_STATE.rs]);

        if (RULE_SETS[GAME_STATE.rs].PREFS) {
            // Default preferences for this rule set
            delete GAME_STATE.PREFS;
            dojo.mixin(PREFS, RULE_SETS[GAME_STATE.rs].PREFS);
            dojo.byId("output_notation").value = PREFS.output_notation; // TODO: cleaner
        }
    }

    // Captured pieces (if no EPD tag present, initializes to empty)
    import_captured(GAME_STATE.captured_pieces);
    update_captured_piece_images();
  
    back_castles = load_starting_position(parts[0], replay);

    // Now that know rank & file count, and where the castles are, parse castling eligibilities
    GAME_STATE.can_castle = {white:{}, black:{}};
    for (var i = 0; i < castling.length; i += 1) {
        var ch = castling.charAt(i);
        var castle_color, file;

        if (ch === "-") { 
            continue;
        } else if (/[A-Z]/.test(ch)) {
            castle_color = "white";
        } else if (/[a-z]/.test(ch)) {
            castle_color = "black";
        } else {
            assert(false, "load_fen(" + fen + "): invalid castling code: " + castling);
        }
        file = ch.toLowerCase();

        // X-FEN / FEN compatibility, KQkq for left and rightmost rooks (from white's 
        // perspective). 
        //
        // Allowed by default, but for larger boards, K and Q are valid file names, 
        // so shredder_castle disables this support.
        if (!GAME_STATE.shredder_castle) {
            if (file === "k") {
                // "kingside", opposite from a-side (this is the h-side on an orthodox board)
                file = x2file(back_castles[castle_color][1]);
            } else if (file === "q") {
                // "queenside", a-side
                file = x2file(back_castles[castle_color][0]);
            }
        }

        GAME_STATE.can_castle[castle_color][file] = true;
    }


    if (replay) { 
        GAME_STATE.recent_piece = null;
    } else {
        // Game loading initialization
        GAME_STATE.position_moves = {}; 
        GAME_STATE.position_after = [fen];  // 0th ply = initial state

        var ply = encode_ply(color, GAME_STATE.fmvn);
        GAME_STATE.position_after[ply] = fen;

        GAME_STATE.ended = null; 
        GAME_STATE.made_moves = [null];
        GAME_STATE.made_moves[ply] = null;

        dojo.query(".recent-move-black").removeClass("recent-move-black");
        dojo.query(".recent-move-white").removeClass("recent-move-white");
        dojo.query(".dropped-square").removeClass("dropped-square");

        update_captured_piece_images();

        // Piece movement restrictions
        if (GAME_STATE.bounds1) {
            set_board_boundary(GAME_STATE.bounds1);
        }

        if (GAME_STATE.bounds2) {
            set_board_boundary(GAME_STATE.bounds2);
        }

        // Graphics
        create_board();
    }
   
    // Now that everything is loaded, set the turn.
    set_turn(color, replay);
    populate_make_a_move_list();
}

// Create a palace or river feature
function set_board_boundary(str)
{
    var ary = str.split(",");
    var bounds_name = ary.shift();
    var x1 = parseInt(ary.shift(), 10);
    var y1 = parseInt(ary.shift(), 10);
    var x2 = parseInt(ary.shift(), 10);
    var y2 = parseInt(ary.shift(), 10);
    var bounds_types = ary;

    // TODO: Replace with assertions, instead of clamping
    if (x1 < 1) { x1 = 1; }
    if (y1 < 1) { y1 = 1; }
    if (x2 > GAME_STATE.files) { x2 = GAME_STATE.files; }
    if (y2 > GAME_STATE.ranks) { y2 = GAME_STATE.ranks; }

    var white_area = [x1, y1, x2, y2];
    var black_area = [x1, (GAME_STATE.ranks + 1) - y2, x2, (GAME_STATE.ranks + 1) - y1];

    // Set boundaries for each piece type given, for quick lookup
    for (var i = 0; i < bounds_types.length; i += 1) {
        var type = bounds_types[i];
        // Note: ranks are from each player's perspective
        GAME_STATE.boundaries[type] = {name: bounds_name, 
            white:white_area, 
            black:black_area, 
            types:bounds_types};
    }
}

// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR.
// If !replay, name pieces.
// TODO: Support FFEN http://www.mafiascum.net/wiki/index.php?title=Faerie_Forsythe-Edwards_Notation 
//
// Returns object of x-coordinates of castles in the 1st rank, for black and white.
function load_starting_position(fen, replay)
{
    var i, x, y, code, back_castles = {white:[], black:[]};

    clear_board();

    // Note that ranks and files internally are represented here by
    // x,y coordinates, so a8 = 1,8. That is where FEN starts.
    x = 1;
    y = GAME_STATE.ranks;
    for (i = 0; i < fen.length; i += 1) {
        code = fen.charAt(i);

        if (/[a-zA-Z\(]/.test(code)) {
            // Read possibly multi-letter piece code
            var length = piece_code_length(fen.substr(i));
            var letter = fen.substr(i, length);
            i += length - 1;

            var piece = decode_piece_letter(letter);
            piece.virtual = true;
            piece.square = VBOARD[x][y];
            //piece.unique_id = letter + "," + x + "," + y;   // TODO: from name_pieces instead?

            VBOARD[x][y].piece = piece;

            // Store location of castles on 1st rank, for return value
            if (y === 1 && PIECE_TYPES[piece.type].castle && piece.color === "white") {
                back_castles.white.push(x);
            } else if (y === GAME_STATE.ranks && PIECE_TYPES[piece.type].castle && piece.color === "black") {
                back_castles.black.push(x);
            }

            x += 1;
        } else if (code === "/") {
            x = 1;
            y -= 1;
        } else if (code === ".") {
            // One empty square, from FFEN
            x += 1;
        } else if (/[0-9]/.test(code)) {
            x += code.charCodeAt(0) - "0".charCodeAt(0);
        } else if (code === " ") {
            break;
        } else {
            assert(false, "load_starting_position(" + fen + "): unknown code: '" + code + "' at i=" + i);
        }
    }

    // Re-init drag & drop since board size may have changed
    init_dnd();

    realize_vboard();

    if (!replay) {
        name_pieces();
        // Clear move history. TODO: Better way.
        dojo.byId("move_history").innerHTML = "";
    }

    return back_castles;
}

//// PIECE LIBRARY / INFO FUNCTIONS (War and Pieces)

// Show all available images, even those without movement
function show_library_images()
{
    var root = PREFS.image_root + PREFS.image_set + "/";
    var used_paths = {}, count;

    count = 0;
    // Map path of used image to piece type it is used for
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            // Mark all images used, including alternates
            var paths = image_path_for(type, "white", true);

            for (var i = 0; i < paths.length; i += 1) {
                // Get base image, and optional overlay text
                var path_split = paths[i].split("#", 2);
                var path = path_split[0];
                var text = path_split[1];

                if (!used_paths[path]) {
                    used_paths[path] = "";
                } else {
                    // Same base image for multiple pieces
                    used_paths[path] += "<br>";
                }

                used_paths[path] += type + (i === 0 ? "" : " (alternate image)") + (text ? " (overlaid " + text + ")" : "");
                count += 1;
            }
        }
    }

    // Get list of all images, even those not being used in a piece
    dojo.xhrGet({url:root + "list.txt", load:function(text) {
        var images = text.split("\n");

        document.write("<html><head><title>All piece images</title></head><body>");
        document.write("<h1>All piece images</h1>");
        document.write("<h2>" + count + " of " + images.length + " (" + 
            Math.round(count / images.length * 100) + "%) defined" + "</h2>");
        document.write("<p>This is a list of all blue and white piece images available in the <b>" + PREFS.image_set + "</b> image set, including those that are not assigned to a piece. See also: <ul>");
        document.write("<li><a href=\"" + PREFS.image_root + PREFS.image_set + "\">Directory listing</a>");
        document.write("<li><a href=\"" + PREFS.image_root + PREFS.image_set + "/README.html\">README</a>");
        document.write("</ul>");

        document.write("<table>");
        for (var i = 0; i < images.length; i += 1) {
            var image = images[i];

            if (!image) {
                continue;
            }

            var wpath = root + "w" + image + PREFS.image_extension;
            var bpath = root + "b" + image + PREFS.image_extension;

            document.write('<tr>');
            document.write('<td>' + i + '.</td>');
            document.write('<td><img src="' + wpath + '"></td>');
            document.write('<td><img src="' + bpath + '"></td>');
            document.write('<td>' + image + '</td>');
            document.write('<td>' + (used_paths[wpath] || "") + '</td>');
            document.write('</tr>');
        }
        document.write('</table></body></html>');
    }});
}

// Disable or enable game setup mode
function set_setup_mode(on)
{
    // Set setup mode as opening/closing piece library, since that is what it is for
    dojo.byId("enable_setup_mode").checked = on;
    PREFS.setup_mode = on;

    if (!on) {
        // Exited setup mode, so calculate moves with new setup
        calculate_moves(GAME_STATE.active_color);
    }
}

// Populate the piece library with the search query
function update_piece_library()
{
    var i, q, lib, tbody;
   
    lib = dojo.byId("piece-library");
    tbody = dojo.byId("piece-library-tbody");
    q = dojo.byId("piece-q").value;

    dojo.empty(tbody);

    i = 0;
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            // Filter matches based on tags 
            if (PIECE_TYPES[type].tags.indexOf(q) == -1) {
                continue;
            }

            var row = dojo.create("tr");
            var piece_colors = ["white", "black", "neutral"];
            for (var j = 0; j < piece_colors.length; j += 1) {
                var color = piece_colors[j];

                var piece = create_piece(color, type);

                // Not directly draggable, since these elements are absolutely 
                // positioned inside a relatively positioned element. But keep
                // them as pieces so you can shift-hover to open the piece inspector.
                dojo.addClass(piece, "tear-off");

                var cell = dojo.create("td", {"class": "square"}, row);
                cell.appendChild(piece);
            }

            dojo.create("td", {innerHTML:PIECE_TYPES[type].letter || ""}, row);

            if (type === "custom") {
                dojo.create("td", {innerHTML:"custom: <input id='custom-movement' onfocus='GAME_STATE.update_custom = true;' onblur='GAME_STATE.update_custom = false'> <a href='newchess.html#ep' target='_new'>help</a>"}, row);
            } else {
                dojo.create("td", {innerHTML:type}, row);
            }

    
            tbody.appendChild(row);
            i += 1;
        }
    }

    var summary_row = dojo.create("tr", {colspan:10}, tbody);
    var summary_cell = dojo.create("td", {colspan:10}, summary_row);
    dojo.create("p", {innerHTML: i + " pieces found"}, summary_cell);
    window.status = i + " pieces found";
    dojo.create("a", {href: "#", onclick:"show_library_images()", innerHTML:"show all images (clears page)"}, summary_cell);

}

// Programmatically add tags to the pieces in the library for searching
function tag_piece_library()
{
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            var piece = PIECE_TYPES[type];
            var tags = piece.tags;

            if (tags === undefined) { tags = ""; }

            // Add some tags automatically based on their movement
            if (piece.royal) { tags += "royal "; }
            if (piece.parlett.indexOf(", #") !== -1) { tags += "compound "; }
            if (piece.parlett.indexOf("~") !== -1) { tags += "leaper "; }
            if (piece.parlett.indexOf(", ~") !== -1) { tags += "amphibian "; }
            if (piece.parlett.indexOf("o#") !== -1 && piece.parlett.indexOf("c#") !== -1) { tags += "snipers "; }
            if (piece.parlett.indexOf("snapback") !== -1) { tags += "projectile "; }
            if (piece.invincible) { tags += "invincible "; }
            if (piece.parlett.indexOf("self_destruct") !== -1) { tags += "kamikaze "; }
            if (piece.parlett.indexOf("[") !== -1) { tags += "explicit "; }
            if (piece.parlett.indexOf("\\") !== -1) { tags += "rotate "; }

            // Piece name(s) itself
            tags += type + " ";
            if (piece.aka) { 
                if (dojo.isArray(piece.aka)) {
                    tags += piece.aka.join(" "); 
                } else {
                    tags += piece.aka;
                }
            }

            piece.tags = tags;
        }
    }
}

// Show the piece library, of readily usable pieces with defined movement
function toggle_piece_library()
{
    var table, lib, want_setup_mode, parent, i, search;

    parent = dojo.byId("piece-library-parent");
    want_setup_mode = parent.style.display === "none";
    toggle(dojo.byId(parent));

    // Set setup mode as opening/closing piece library, since that is what it is for
    set_setup_mode(want_setup_mode);

    // Lazily generate the table. 
    lib = dojo.byId("piece-library");
    if (dojo.byId("piece-library-table")) {
        return;
    } 

    tag_piece_library();

    enable_document_selection(false, lib);

    // TODO: sortable columns, searchable table, so can list by symbol, alphabetically,
    // royal pieces first, pieces that promote, and find what you want.
    var search = dojo.create("input", {id:"piece-q", name:"piece-q", type:"search", style:"width: 100%",
        onfocus:"GAME_STATE.update_piece_query=true;", onblur:"GAME_STATE.update_piece_query=false;"}, lib);  // TODO: add event handler

    // IE7 chokes due to the fix for http://dev.rubyonrails.org/ticket/2707
    // TODO: Find out why this table doesn't display in IE7
    table = dojo.create("table", {id:"piece-library-table"}, lib);
    tbody = dojo.create("tbody", {id:"piece-library-tbody"}, table);

    update_piece_library();
}

// Show information on a piece
function show_piece_inspector(piece)
{
    var symbols, type_info, misc, images, paths, diagram, alt_names, alt_names_string;
    var inspector = dojo.byId("piece-inspector");

    type_info = PIECE_TYPES[piece.type];

    // Also known as...
    alt_names = [];
    if (dojo.isArray(type_info.image)) {
        alt_names = dojo.clone(type_info.image);
    } 
    if (type_info.aka) {
        alt_names = alt_names.concat(type_info.aka);
    }
    // Remove dupes and canonical name
    alt_names = uniq(alt_names);
    alt_names = dojo.filter(alt_names, function(x) { return x !== piece.type; });

    if (alt_names.length) {
        alt_names_string = " (" + alt_names.join(", ") + ")";
    } else {
        alt_names_string = "";
    }

    dojo.byId("inspector-type").innerHTML = piece.type + alt_names_string;

    // Show all the images, in order of preference.
    var images = dojo.byId("inspector-image");
    images.innerHTML = "";
    var images_count = image_path_for(piece.type, piece.color, true).length;    // TODO: stop being ugly
    for (var i = 0; i < images_count; i += 1) {
        var piece_image = create_piece(piece.color, piece.type, true, true, i);
        piece_image.style.float = "left";
        images.appendChild(piece_image);
    }
    dojo.create("br", {clear:"all"}, images);
    


    dojo.byId("inspector-movement").innerHTML = escape_html(type_info.parlett);
    dojo.byId("inspector-tags").innerHTML = type_info.tags ? escape_html(type_info.tags.replace(piece.type, "")) : "";

    dojo.byId("inspector-diagram").innerHTML = movement_diagram(unfiltered_moves(type_info.parlett));

    // Symbols (letter, figurine, number) for notations
    symbols = [];
    if (type_info.letter) {
        symbols.push(type_info.letter);
    } else {
        symbols.push("X(" + piece.type + ")");
    }
    if (type_info.alg_letter) {
        symbols.push(" (algebraic: " + type_info.alg_letter + ")");
    }
    if (type_info.figurines) {
        symbols.push(", " + type_info.figurines.join(", "));
    }
    if (type_info.iccf_number) {
        symbols.push(", " + type_info.iccf_number);
    }
    dojo.byId("inspector-symbols").innerHTML = symbols.join("");

    // Other settings
    misc = [];
    if (type_info.promote) {
        // TODO: links to view other pieces?
        misc.push("Promotes to " + type_info.promote.join(", ") + 
                " on rank #" + (type_info.promotion_rank || GAME_STATE.ranks) + "<br>");
    }
    if (type_info.royal) {
        misc.push("Royal (can be checked/checkmated)<br>");
    }
    if (type_info.resets_50move) {
        misc.push("Resets 50-move counter<br>");
    }
    if (type_info.castles_with) {
        misc.push("Castles with " + type_info.castles_with + "<br>");
    }
    if (type_info.castle) {
        misc.push("Is a castle<br>");
    }
    if (type_info.invincible) {
        misc.push("Invincible (cannot be captured)<br>");
    }
    if (type_info.url) {
        misc.push("<em>Additional information is available by shift-clicking the piece</em>");
    }

    dojo.byId("inspector-info").innerHTML = misc.join("");

    inspector.style.display = "";
}

// Open an external website with more information on a piece, if any
function open_piece_url(piece)
{
    var type_info = PIECE_TYPES[piece.type];

    if (type_info.url) {
        var url = type_info.url;
        if (url === "akm") { 
            url = "http://www.mayhematics.com/v/gm.htm";
        } else if (url.substr(0, 3) === "pc:") {
            url = "http://www.chessvariants.org/piececlopedia.dir/" + url.substr(3) + ".html";
        }
        window.open(url);
    } else {
        //alert("No additional information is available for " + piece.type);
    }
}


// Hide information on the piece shown, if any
function hide_piece_inspector()
{
    var inspector = dojo.byId("piece-inspector");

    if (inspector) {
        inspector.style.display = "none";
    }
}

//// PIECE FUNCTIONS

// Name each piece, in standard chess1 locations, using English descriptive notation.
function name_pieces()
{
    var piece, descriptive_name;

    for (var file_number = 1; file_number <= GAME_STATE.files; file_number += 1) {
        // English descriptive notation (only really applicable to chess1)
        var file = x2descriptive(file_number);

        // White's pieces and pawns
        piece = pc(file_number, 1); if (piece) { piece.descriptive_name = file; }
        piece = pc(file_number, 2); if (piece) { descriptive_name = file + "P"; }

        // Black's pieces and pawns
        piece = pc(file_number, GAME_STATE.ranks); if (piece) { descriptive_name = file; }
        piece = pc(file_number, GAME_STATE.ranks - 1); if (piece) { descriptive_name = file + "P"; }


        // Algebraic descriptive notation
        var afile = x2file(file_number);
        for (var white_rank = 1; white_rank <= GAME_STATE.ranks; white_rank += 1) {
            var black_rank = (GAME_STATE.ranks + 1) - white_rank;
            piece = pc(file_number, white_rank);
            var rank, piece_letter;

            if (!piece) {
                continue;
            }

            if (piece.color === "white") {
                rank = white_rank;
            } else {
                rank = black_rank;
            }

            piece_letter = full_piece_prefix(piece);
            // aP, bP, etc.. TODO: use rank, if needed to disambiguate (two
            // pieces of same type on same file). Use file, rank, or filerank
            // like disambiguating moves.
            piece.adescriptive_name = afile + piece_letter;

            // Unique identifier of piece. TODO: Use adescriptive_name, make it disambiguated
            // so it will be always unique and descriptive.
            piece.unique_id = afile + "" + white_rank + piece_letter;
        }
    }
}

/// TODO: a "piece lab", where can dynamically create new pieces,
// browse existing pieces. Show piece on board by itself, highlighting 
// valid moves, update when change Parlett movement types, allow to operate
// the piece and see how it behaves. Then return to the main board.

// Return the letter, if any, used for representing the piece type (name)
// in algebraic notation.
function algebraic_letter(type)
{
    if (PIECE_TYPES[type].alg_letter !== undefined) {
        return PIECE_TYPES[type].alg_letter;
    } else {
        return PIECE_TYPES[type].letter;
    }
}

// Given a letter, find the name of the piece (R = rook, etc.). The letter
// can either be for FEN (P = pawn), or algebraic notation (blank = pawn);
// both are recognized.
var cache_letter2name;
function piece_letter2name(letter)
{
    // If given a name, return what we were given.
    if (PIECE_TYPES[letter]) {
        return letter;
    }

    letter = letter.toUpperCase();

    if (!cache_letter2name) {
        cache_letter2name = {};

        for (var name in PIECE_TYPES) {
            if (PIECE_TYPES.hasOwnProperty(name)) {
                var info = PIECE_TYPES[name];

                if (info.letter !== undefined) {
                    cache_letter2name[info.letter] = name;
                } else if (info.alg_letter !== undefined) {
                    cache_letter2name[info.alg_letter] = name;
                }
            }
        }
    }

    return cache_letter2name[letter.toUpperCase()];
}

// Return the full piece prefix, succiently indicating the piece type.
// Will not return an empty string but may return E-FEN piece codes. 
function full_piece_prefix(piece)
{
    assert(PIECE_TYPES[piece.type], "full_piece_prefix(" + piece + "): no such type " + piece.type);
    var letter = PIECE_TYPES[piece.type].letter;

    if (letter !== undefined) {
        return letter;
    } else {
        return "X(" + piece.type + ")";
    }
}

// Return the full piece prefix using lowercase for black, uppercase for white.
// The resulting code can be decoded with decode_piece_letter().
function color_piece_prefix(piece)
{
    var letter = full_piece_prefix(piece);
    var first = letter.substr(0, 1);
    var rest = letter.substr(1);

    if (piece.color === "white") {
        return first.toUpperCase() + rest;
    } else {
        return first.toLowerCase() + rest;
    }
}

// Return algebraic prefix for a piece. May return an empty 
// string (for pawns, for example): prefers alg_letter over letter.
// To always get a non-empty string, use full_piece_prefix() instead.
function algebraic_piece_prefix(piece)
{
    if (PIECE_TYPES[piece.type].alg_letter !== undefined) {
        return PIECE_TYPES[piece.type].alg_letter;
    } else {
        return full_piece_prefix(piece);
    }
}

// Get the Unicode figurine for a piece of a given color, or fall back on 
// algebraic_piece_prefix if there isn't one.
function figurine_piece_prefix(color, piece)
{
    if (PIECE_TYPES[piece.type].figurines) {
        return PIECE_TYPES[piece.type].figurines[color === "white" ? 0 : 1];
    } else {
        return algebraic_piece_prefix(piece);
    }
}

// Return a piece at (x,y), or "offboard" if the coordinates are out of range.
function pc_or_offboard(x, y)
{
    if (x < 1 || y < 1 || x > GAME_STATE.files || y > GAME_STATE.ranks) {
        return "offboard";
    }

    // Virtual board only
    return pc(x, y);
}

// Return an existing piece on the virtual board, or a false, given:
// - (x,y) coordinates, like (8,1)
// - location in filerank notation, like "a8"
// To get piece from a square, use .piece if virtual, or .firstChild if not
function pc(x, y, virtual)
{
    if (x.charAt) {
        var xy = filerank2xy(x);
        x = xy.x;
        y = xy.y;
    }

    //assert(x >= 1 && x <= GAME_STATE.files, "pc(" + x + ", " + y + "): bad x: " + x);
    //assert(y >= 1 && y <= GAME_STATE.ranks, "pc(" + x + ", " + y + "): bad y: " + y);

    return VBOARD[x][y].piece;
}

// Return the path to an image for the piece of that color.
// The path may optionally have # appended by the overlay text
// If all, then returns an array of all images including alternates,
// otherwise returns preferred.
function image_path_for(type, color, all)
{
    var bases, image_list, paths;

    assert(PIECE_TYPES[type], "image_path_for(" + type + ", " + color + "): no such piece type");

    // Override image name
    image_list = PIECE_TYPES[type].image;
    if (image_list) {
        // Choose first from array if is an array
        bases = dojo.isArray(image_list) ? image_list : [image_list];
    } else {
        bases = [type];
    }

    // TODO: Use .style.webkitTransform="rotate(45deg)" etc. to get rotated pieces,
    // instead of having rotated images saved! Would allow anything to be rotated.

    // Rejected TODOs, lack support:
    // - pngs
    // - use Unicode characters in a span!! How cool would that be? Infinite resolution.
    //   See for example http://en.wikipedia.org/wiki/Knight_(chess)
    //   Unfortunately, MSIE doesn't seem to support it, though it should..different font?
    // - Web fonts! Supported on Firefox 3.1+, Opera 10+, Safari 3.1+, IE4+
    //   See http://fonts.philip.html5.org/
    
    paths = [];
    for (var i = 0; i < bases.length; i += 1) {
        var basename, text;

        // Normally image is given with filename only, but may also have optional
        // text after hash, to overlay on the image
        var ary = bases[i].split("#", 2);
        basename = ary[0];
        text = ary[1];

        var path = [PREFS.image_root, PREFS.image_set, "/", PREFS.image_prefixes[color], basename, PREFS.image_extension].join("");
        if (text) {
            path += "#" + text;
        }

        paths.push(path);
    }

    return all ? paths : paths[0];
}

// Get the length of the first piece code (letter) in a string. The
// substring of the length returned can be decoded with decode_piece_letter.
//
// Examples: 
// piece_code_length("RNBQKBNR") === 1 (for "R")
// piece_code_length("XRPPXA") === 2 (for "XR")
// piece_code_length("X(bede)RRR") === 7 (for "X(bede)")
function piece_code_length(code)
{
    var i;

    if (code.charAt(0) === "X" || code.charAt(0) === "x") {
        i = 1;

        // Expanded FEN codes
        if (code.substr(0, 2) === "X(" || code.substr(0, 2) === "x(") {
            // x(fullname) or X(fullname)
            // Read until closing paren
            var ch;
            i += 1;
            while(i < code.length) {
                ch = code.charAt(i);
                if (ch === ")") { break; }
                i += 1;
            }
            i += 1;
        } else {
            // Two-letter codes beginning with X (XR, etc.) TODO: deprecate?
            i = 2; 
        }
    } else if (code.charAt(0) === "(") {
        i = 1;
        // (letters)
        // Multiple-letter code (but not fullname); for Taikyoku Shogi

        // Read until closing paren
        var ch;
        i += 1;
        while(i < code.length) {
            ch = code.charAt(i);
            if (ch === ")") { break; }
            i += 1;
        }
        i += 1;

    } else {
        i = 1;
    }

    return i;
}
// Decode Forsyth-Edwards Notation piece code, for example:
//  r = black rook, R = white rook, N = white knight
// Also allows extended names, X(elephant), x(elephant), etc.
// To encode, use color_piece_prefix().
function decode_piece_letter(name)
{
    var color, type;

    if (name.indexOf("(") === 0) {
        // Parenthesized (letters)
        name = name.substring(1).replace(")", "");
    }

    // In FEN, uppercase=white, lower=black
    if (/^[A-Z]/.test(name)) {
        color = "white";
    } else if (/^[a-z]/.test(name)) {
        color = "black";
    } else {
        assert(false, "create_piece_by_letter(" + name + "): not a letter");
    }
    name = name.toLowerCase();

    // x(name) or X(name) is explicit name, otherwise, is a letter
    if (/\(/.test(name)) {
        var ary = /^[xX]\(([^)]+)/.exec(name);
        type = ary[1];
    } else {
        type = piece_letter2name(name);
    }

    console.log(name,color,type);
    // XXX temporary hack to get pieces I don't have to load TODO: remove this, its just for show
    if (type === undefined) {
        type = "cannon"; 
    }

    return {color: color, type: type};
}

// Create a new piece or pawn, given the letter.
function create_piece_by_letter(name)
{
    var decoded = decode_piece_letter(name);

    return create_piece(decoded.color, decoded.type);
}

// Called when mouse is over a piece
function over_piece(piece, event) 
{
    event = event || window.event;
    
    var square = highlight_moves(piece, true);
    if (square) {
        push_highlight(square, DISPLAY["recent_move_" + square.color]);
    }
 
    if (event.shiftKey) {
        show_piece_inspector(piece);
    }
    GAME_STATE.piece_under = piece;
}

// Called when mouse is no longer over a piece
function out_piece(piece, event)
{
    event = event || window.event;

    var square = highlight_moves(piece, false);
    if (square) {
        pop_highlight(square);
    }
   
    if (!event.shiftKey) {
        hide_piece_inspector();
    }

    GAME_STATE.piece_under = null;
}


// Create a new piece by color and type (full name).
// If faux, then piece cannot be moved (its not on the game board, it might be in a promotion selector etc.)
// If no_inspector, you can't inspect this piece (only useful if this piece *is* inside the inspector)
// If image_override is given, it is taken as an index to an alternate image
// TODO: make this a constructor so you can do new Piece().
function create_piece(color, type,   faux, no_inspector, image_override)
{
    var filename, piece, classes;

    assert(type, "create_piece(" + type+ "): unrecognized piece type: " + type);

    filename = image_path_for(type, color, image_override !== undefined);

    if (image_override !== undefined) {
        filename = filename[image_override];
    }

    // CSS classes, can use with dojo.query and also shown in toString (useful 
    // for debugging), however, note that code should not use this, because
    // all the classes are in a space-separated string, .className, according to
    // the DOM, and Prototype's hasClassName uses a slow RegExp to parse it,
    // and dojo's hasClass uses indexOf so its faster, but it still involves
    // parsing, and it is ugly. Probably a design flaw, oh well.
    // Use .type and .piece (set below) instead of classes for speed.
    classes = ["piece", color, type];

    // Royal class is very important.
    if (PIECE_TYPES[type].royal) {
        classes.push("royal");
    }

    if (!faux) {
        // Make all new pieces draggable. I tried only making the active color's
        // pieces draggable, but then in Safari they can still be selected like text,
        // even with enable_document_selection(false), maybe I need to enable it on the
        // images too, but it wasn't appealing. In Firefox, the images can be dragged
        // as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
        // if they are the active colors move. The player can drag the opponent's pieces
        // around but not drop anywhere.
        classes.push("draggable");
    }


    // Create the node
    // TODO Use a div with background-image instead, then can have arbitrary
    // characters, instead of just images, more flexible, maybe transition too.
    //piece = dojo.create("img", {src:filename, "class":classes.join(" "), className:classes.join(" ")});
    piece = dojo.create("div", {"class":classes.join(" "), className:classes.join(" "), style:"background-image: url(" + filename + ")"});
    //dojo.create("img", {src:filename}, piece);

    // Property will tell name of piece. To tell what color, or if it is
    // a piece in the first place, check the class names.
    piece.type = type;
    piece.color = color;

    // Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
    // Yahoo Games does this too, but uses a yellow outline.
    if (!no_inspector) {
        piece.onmouseover = function(event) { over_piece(piece, event); };
        piece.onmouseout = function(event) { out_piece(piece, event); };
    }

    // If has text overlay, set it
    if (filename.indexOf("#") != -1) {
        var text = filename.split("#")[1];

        piece.textContent = text;
    }

    return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
// Return the from square, if anything was highlighted.
// If skip_legal, skip legal move highlighting, but continue to enable/disable blocked 
// move highlighting.
function highlight_moves(piece, enable, skip_legal)
{
    var from_square, moves, blocked_moves;

    // If player is dragging a piece over another piece, don't show
    // legal moves for the piece under it.
    if (!piece || DRAG.dragging) {
        return null;
    }

    from_square = piece.square;

    if (!from_square) {
        // Could not find a square for the piece, it no longer exists,
        // so no need to concern ourselves with highlighting its moves.
        return null;
    }
   
    if (piece.color === GAME_STATE.active_color || piece.color === "neutral") {
        // Active player's pieces, or neutral
        moves = VALID_MOVES[from_square.filerank];
        blocked_moves = BLOCKED_MOVES[from_square.filerank];
    } else {
        // Opponent's pieces -- allow seeing valid moves if it was
        // their turn, if holding down shift.
        if (GAME_STATE.shift) {
            moves = VALID_MOVES_OPP[from_square.filerank];
            blocked_moves = BLOCKED_MOVES_OPP[from_square.filerank];
            GAME_STATE.shift = 1;    // showing other player's moves
        } else {
            return null;
        }
    }

    if (!skip_legal) {
        dojo.forEach(moves, function(move) {
            var x, y, flags, to_square;

            x = move.x;
            y = move.y;
            flags = move;

            to_square = VBOARD[x][y];
            if (enable) {
                push_highlight(to_square, DISPLAY["legal_move_" + to_square.color]);
            } else {
                pop_highlight(to_square);
            }
        });
    }

    // If shifted, show blocked moves, too.
    dojo.forEach(blocked_moves, function(move) {
        var x, y, flags, to_square;
        
        x = move.x;
        y = move.y;
        flags = move;

        to_square = VBOARD[x][y];
        if (GAME_STATE.shift) {
            if (enable) {
                push_highlight(to_square, DISPLAY["blocked_move_" + to_square.color]);
            } else {
                pop_highlight(to_square);
            }
        }
    });

    return from_square;
}

//// SQUARE FUNCTIONS / FILE-RANK NOTATION

// Convert filerank f8 to the x,y coordinate {x:8,y:6}, etc. These coordinates
// are used internally, but filerank notation is useful for human consumption
// (though I actually think better in descriptive notation, but maybe I'm in the minority there)
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// one-based table cell with (8,1) at the top-left. In filerank notation, this
// square is labeled a8. The bottom-right square (8,1) is filerank's h1.
function filerank2xy(code)
{
    // TODO: allow files after z, aa, ab, ...
    var x = code.charCodeAt(0) - "a".charCodeAt(0) + 1; // corresponds to file (horizontal)
    // TODO: allow ranks >9; xy2filerank can encode but this function cannot decode :(
    var y = code.charCodeAt(1) - "1".charCodeAt(0) + 1; // corresponds to rank (vertical)

    //assert(x >= 1 && x <= GAME_STATE.files, "filerank2xy(" + code + "): bad x: " + x);
    //assert(y >= 1 && y <= GAME_STATE.ranks, "filerank2xy(" + code + "): bad y: " + y);

    return {x:x, y:y};
}

// Convert from x,y coordinates to filerank notation for human consumption. 
// xy2filerank({x:1, y:8}) === "a8"
// Note that this code often passes in an object with other properties, but only x and y are used
function xy2filerank(obj)
{
    return x2file(obj.x) + y2rank(obj.y);
}

// Convert an X coordinate to a human readable representation of a file
function x2file(x)
{
    assert(x >= 1 && x <= GAME_STATE.files, "x2file(" + x + "): bad x: " + x);

    return number2repr("Latin", x);
}

// Convert a numerical value to a representation string value in one of many formats
function number2repr(format, n)
{
    if (format === "Arabic") {      // Hindu-Arabic / European / West Arabic, http://en.wikipedia.org/wiki/Arabic_numerals
        // 0-9, what we're all familiar with
        return n.toString();
    } else if (format === "Latin") {
        if (n < 27) {   
            // a-z
            return String.fromCharCode(n + "a".charCodeAt(0) - 1);
        } else {
            // aa-zz, this is used in http://en.wikipedia.org/wiki/Taikyoku_shogi#Game_notation
            var letter = String.fromCharCode((n - 26) + "a".charCodeAt(0) - 1);
            return letter + letter;

            // aa-az
            //return String.fromCharCode((n / 26)  + "a".charCodeAt(0) - 1) + String.fromCharCode((n % 26) + "a".charCodeAt(0) - 1);
            // TODO: arbitrary? base 26
        }
    } else if (format === "Roman") {
        // TODO: algorithmic calculation?, as to convert up to 3,999,999
        // http://en.wikipedia.org/wiki/Roman_numerals#Modern_Roman_numerals
        //return {1:"i", 2:"ii", 3:"iii", 4:"iv", 5:"v", 6:"vi", 7:"vii", 8:"viii", 9:"ix", 10:"x"}[n]; 
        return {1:"ⅰ", 2:"ⅱ", 3:"ⅲ", 4:"ⅳ", 5:"ⅴ", 6:"ⅵ", 7:"ⅶ", 8:"ⅷ", 9:"ⅸ", 10:"ⅹ"}[n]; 
    } else if (format === "Chinese") {
        // http://en.wikipedia.org/wiki/Chinese_numerals
        return {0:"〇", 1:"一", 2:"二", 3:"三", 4:"四", 5:"五", 6:"六", 7:"七", 8:"八", 9:"九", 10:"十"}[n];
    } else if (format === "Gujarati") {
        return {0:"૦", 1:"૧", 2:"૨", 3:"૩", 4:"૪", 5:"૫", 6:"૬", 7:"૭", 8:"૮", 9:"૯"}[n];
    } else {
        // TODO: maybe support more? http://en.wikipedia.org/wiki/Number_names#Numeral_symbols
        assert(false, "number2repr(" + format + ", " + n + "): invalid format");
    }
}

// Convert an (one-based) Y coordinate to a Roman numeral file number from the player's perspective
// TODO: use this for labels!
function y2rank_wxf(color, y)
{
    return number2repr("Roman", (color === "white" ? y: (GAME_STATE.files) - y));
}

// Convert a (one-based) Y coordinate to a human readable representation of a rank
function y2rank(y) 
{
    if (y === "") {
        return "";  // TODO: remove grossness
    }

    assert(y >= 1 && y <= GAME_STATE.ranks, "y2rank(" + y + "): bad y: " + y);

    // TODO: Chinese, lowercase Roman numerals 
    return y.toString();
}




// Return name of square from color's perspective in English descriptive notation
// Only works for chess1, not any variants where the pieces are arranged differently.
function x2descriptive(x) 
{
    assert(x >= 1 && x <= GAME_STATE.files, "x2descriptive(" + x + "): bad x: " + x);
    return [null, "QR", "QN", "QB", "Q", "K", "KB", "KN", "KR"][x];
    
}

// Get the y coordinate from the player's perspective
function y_from_perspective(color, y)
{
    return color === "white" ? y : (GAME_STATE.ranks + 1) - y;
}

// Return the file given the x coordinate, from the player's perspective
// -- as a numerical string. Used for Xiangqi.
function file_from_perspective(color, x) 
{   
    return (color === "white" ? (GAME_STATE.files + 1) - x : x).toString();
}

// Shorten a file name, in descriptive notation, to a possibly-ambiguous name.
// QR for queen's rook file is shortened to R, and so is KR for king's rook. 
function short_descriptive(descriptive_file)
{
    return {
        QR:"R", QN:"N", QB:"B", KB:"B", KN:"N", KR:"R", K:"K", Q:"Q",
        QRP:"RP", QNP:"NP", QBP:"BP", KBP:"BP", KNP:"NP", KRP:"RP", KP:"KP", QP:"QP" 
    }[descriptive_file];
}

// Get a square cell, given location in either
// - filerank notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 1,8)
// To get the square of a piece, use .square
// Note: code should use VBOARD[x][y] or .square. This is 
// only for user convenience (console) and debugging.
function sq(code, extra)
{
    var x, y, xy;

    //assert(code !== undefined, "sq(" + code + ", " + extra + "): code is undefined");
    //assert(code !== null, "sq(" + code + ", " + extra + "): code is null");

    // Is it x,y passed as separate parameters?
    if (extra !== undefined) {
        x = code;
        y = extra;
    // Is it a string in algebraic notation that can be converted?
    } else if (code.charCodeAt) {
        xy = filerank2xy(code);

        // Note JavaScript 1.8 can do var [x,y] = ...
        x = xy.x;
        y = xy.y;
    } else {
        assert(false, "sq(" + code + ", " + extra + "): couldn't find out what I was given");
    }

    /*assert(x >= 1 && x <= GAME_STATE.files && y >= 1 && y <= GAME_STATE.ranks, "sq(" + code + ", " + extra + 
        "): out of range (" + x + ", " + y + ")");*/

    return VBOARD[x][y];
}

//// CHESS960(FRC)/256/RANDOMIZED CHESS SETUP FUNCTIONS

// Set the variant and variant generator, updating the code in the process.
function set_variant_code(code, generator)
{
    var vc = dojo.byId("variant_code");
    
    vc.value = code;
    vc.style.display = code === null ? "none" : "";

    assert(generator, "set_variant_code(" + code + ", " + generator + "): requires generator");

    PREFS.variant_generator = generator;
}

// Load a new game when a new variant code is entered.
function update_variant_code(code) 
{
    assert(PREFS.variant_generator, "update_variant_code(" + code + "): called before set_variant_code, missing variant_generator");

    if (code.indexOf && code.indexOf("0x") === 0) {
        code = parseInt(code, 16);
    } else {
        code = parseInt(code, 10);
    }

    if (isNaN(code)) {
        code = undefined;
    }

    load_fen(PREFS.variant_generator(code));
}

// Decode the Chess960 S# (Scharnagl) code to a piece array
// Algorithm from _Play Stronger Chess by Examining Chess960_ by Gene Milener, pg. 82
function decode_chess960_s(number)
{
    var array = new Array(8);
    var light_bishop, dark_bishop, queen, krn_code, krn_array, available, i, j;


    assert(number >= 0 && number <= 959, "decode_chess960_s(" + number + "): out of range 0-959");

    // Bishops are placed on light and dark squares directly
    
    light_bishop = number % 4;
    array[light_bishop * 2 + 1]  = "B";
    // To do integer divison, reduce by remainder before dividing
    number -= light_bishop;
    number /= 4;

    dark_bishop = number % 4;
    array[dark_bishop * 2] = "B"; 
    number -= dark_bishop;
    number /= 4;

    // Queen is placed on Nth available square
    queen = number % 6;
    available = 0;
    for (i = 0; i < array.length; i += 1) {
        if (array[i]) {
            continue;
        }

        if (available === queen) {
            array[i] = "Q";
            break;
        }
        available += 1;
    }
    number -= queen;
    number /= 6;

    // Encodes king, knight, and rook
    knr_code = number;
    knr_array = [
        "NNRKR",    // S#000-095
        "NRNKR",    // S#096-191
        "NRKNR",    // S#192-287

        "NRKRN",    // S#288-383
        "RNNKR",    // S#384-479
        "RNKNR",    // S#480-575
        "RNKRN",    // S#576-671
        
        "RKNNR",    // S#672-767
        "RKNRN",    // S#768-863
        "RKRNN"     // S#864-959
            ][knr_code];

    j = 0;
    for (i = 0; i < array.length; i += 1) {
        if (array[i]) {
            continue;
        }

        array[i] = knr_array.charAt(j);
        j += 1;
    }

    // Divide into two groups for readability
    // Removed, since this is more annoying when manipulating. Should use it for display, though.
    //array.splice(4, 0, "-");

    return array.join("");
}

// Encode a Chess960 opening setup to an S# code.
function encode_chess960_s(string)
{
    var bishop, light_bishop, dark_bishop, queen, krn_code, i, number;

    string = string.replace("-", "");

    // Find light and dark bishops first
    bishop = string.indexOf("B");
    string = string.replace("B", "x");  // to avoid finding again, but not change offset
    if (bishop % 2) {
        light_bishop = (bishop - 1) / 2;
        dark_bishop = string.indexOf("B") / 2;
    } else {
        dark_bishop = bishop / 2;
        light_bishop = (string.indexOf("B") - 1) / 2;
    }

    // Queen is encoded as Nth available space, so exclude the two bishops before finding it
    string = string.replace("x", "");
    string = string.replace("B", "");
    queen = string.indexOf("Q");

    // Reverse lookup KNR code
    string = string.replace("Q", "");
    knr_code = {
        "NNRKR":0,    // S#000-095
        "NRNKR":1,    // S#096-191
        "NRKNR":2,    // S#192-287

        "NRKRN":3,    // S#288-383
        "RNNKR":4,    // S#384-479
        "RNKNR":5,    // S#480-575
        "RNKRN":6,    // S#576-671
        
        "RKNNR":7,    // S#672-767
        "RKNRN":8,    // S#768-863
        "RKRNN":9     // S#864-959
            }[string];

    number = light_bishop + 4 * dark_bishop + 16 * queen + 96 * knr_code;

    return number;
}

// TODO: Add F# (Fritz9) and R# (Milener's reciprocal) Chess960 starting position codes, enc/dec

// Generate the castling string in Shredder-FEN, from a Chess960 setup 
function generate_castling_eligibility(setup_string)
{
    var rook1, rook2, file1, file2, castling;

    rook1 = setup_string.indexOf("R");
    setup_string = setup_string.replace("R", "-");
    rook2 = setup_string.indexOf("R");

    file1 = x2file(rook1 + 1);
    file2 = x2file(rook2 + 1);

    // AHha, for example
    castling = file1 + file2;
    castling = castling.toUpperCase() + castling;

    return castling;
}

// Return the FEN for a Chess960/Fischerrandom game, either of the given S# code, or random if undefined
function setup_chess960(code)
{
    var setup_string, castling;

    if (code === undefined) {
        code = Math.floor(Math.random() * 960);
    }

    setup_string = decode_chess960_s(code);
    castling = generate_castling_eligibility(setup_string);

    set_variant_code(code, setup_chess960);
    return setup_string.toLowerCase() + "/pppppppp/8/8/8/8/PPPPPPPP/" + setup_string + " w " + castling + " -";
}

// Decode a Chess256 setup position code
function decode_chess256(code)
{
    var ret, i, bit;

    assert(code >= 0 && code <= 255, "decode_chess256(" + code + "): out of range 0-255, inclusive");

    // Code is an 8-bit binary number, where 1=pawn on 3rd rank, 2=on 2nd rank
    // reading left-to-right, from white's perspective. (This is my invention.)
    var rank2 = [".", ".", ".", ".", ".", ".", ".", "."];
    var rank3 = [".", ".", ".", ".", ".", ".", ".", "."];

    for (var i = 7; i != -1; i -= 1) {
        bit = code % 2;

        if (bit) {
            rank3[i] = "p";
        } else {
            rank2[i] = "p";
        }

        code /= 2;
        code = Math.floor(code);
    }

    ret = {rank2: rank2.join(""), rank3: rank3.join("")};

    return ret;
}

// Return the FEN for a Chess256/Randompawns game, http://hem.passagen.se/melki9/randompawn.htm
function setup_chess256(code)
{
    var fen, setup;

    if (code === undefined) {
        code = Math.floor(Math.random() * 255);
    }

    setup = decode_chess256(code);

    set_variant_code(code, setup_chess256);

    return "rnbqkbnr/" + setup.rank2 + "/" + setup.rank3 + "/8/8/" + 
        setup.rank3.toUpperCase() + "/" + setup.rank2.toUpperCase() + "/RNBQKBNR w KQkq -";
}

// Decode a D-Chess setup position. This is another custom encoding.
function decode_dchess(code)
{
    var black_setup, white_setup, white_code, black_code;

    // Synder says there are 8,299,400 positions, which is (4*6!)^2, 
    // but I get 132,710,400 = (4*4*6!)^2. Dark bishop can be on 4 different
    // squares, dark bishop the 4 other squares, and 6 other squares to fill.
    assert(code >= 0 && code <= 132710400, "setup_dchess(" + code + "): out of range 0-132710400, inclusive");

    // Lower half is for white (11520 = sqrt(13710400) - 1)
    white_code = code % 11520;
    white_setup = decode_one_dchess(white_code);

    // Upper is black.
    black_code = (code - white_code) / 11520;
    black_setup = decode_one_dchess(black_code).toLowerCase();

    return {white:white_setup, black:black_setup};
}

// Decode the D-Chess setup position for one side only. Since it encodes both
// black and white, this should be called twice to get the full position.
function decode_one_dchess(code)
{
    var dark_bishop, light_bishop, piece, array, pieces, spaces;
    
    assert(code >= 0 && code <= 11519, "decode_one_dchess(" + code + "): out of range 0-11519, inclusive");

    array = ["-", "-", "-", "-", "-", "-", "-", "-"];

    // First dark and light bishop, on dark and light squares only.
    dark_bishop = code % 4;
    code -= dark_bishop;
    code /= 4;
    array[dark_bishop * 2] = "B";

    light_bishop = code % 4;
    code -= light_bishop;
    code /= 4;
    array[light_bishop * 2 + 1] = "B";

    // Place knight, knight, rook, rook, queen, and king on first
    // available Nth square as stored.
    pieces = ["N", "N", "R", "R", "Q", "K"];
    spaces = 6;

    do
    {
        piece = code % spaces;
        code -= piece;
        code /= spaces;

        array[nth_index_of(array, "-", piece)] = pieces[6 - spaces];

        //console.log("place",pieces[6-spaces]," at ",piece,"nth = ",array.join(""));

    } while (spaces -= 1);

    return array.join("");
}

// D-Chess http://www.d-chess.com/
function setup_dchess(code)
{
    var setup, fen;

    if (code === undefined) {
        code = Math.floor(Math.random() * 132710400);
    }

    setup = decode_dchess(code);

    set_variant_code(code, setup_dchess);

    fen = setup.black + "/pppppppp/8/8/8/8/PPPPPPPP/" + setup.white + " ? - -";

    return fen;
}

//// DRAG-AND-DROP FUNCTIONS

// Initiate drag-and-drop on mouse down, if over a draggable element
function mousedown(event)
{
    var target;

    event = event || window.event;

    target = event.target !== undefined ? event.target : event.srcElement;

    if (target.className.indexOf("draggable") === -1) {
        return;
    }

    if (event.shiftKey) {
        open_piece_url(target);
    }

    if (target.className.indexOf("tear-off") !== -1 || (event.altKey && PREFS.setup_mode)) {
        // This is from the piece library -- or being option-dragged from
        // the board to be cloned -- so allow a new copy
        // of the piece to be torn off.
        var tear = create_piece(target.color, target.type);

        tear.style.left = dojo._abs(target, true).x + "px";
        tear.style.top = dojo._abs(target, true).y + "px";

        dojo.body().appendChild(tear);

        target = tear;
    }

    DRAG.initial_x = event.clientX;
    DRAG.initial_y = event.clientY;

    DRAG.start_x = target.offsetLeft;
    DRAG.start_y = target.offsetTop;

    DRAG.initial_left = dojo._abs(target, true).x;
    DRAG.initial_top = dojo._abs(target, true).y;

    // Bring to front
    DRAG.old_zindex = target.style.zIndex;
    target.style.zIndex = 10000;

    // Capture mouse
    DRAG.element_m = target;
    document.onmousemove = mousemove;
    document.onmouseup = mouseup;

    // Prevent text selection
    document.body.focus();
    document.onselectstart = function() { return false; };
    target.ondragstart = function() { return false; };

    DRAG.dragging = true;

    return false;
}

// Initiate dragging if touching a draggable element
function touch(evt)
{
    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i]; 

        var color, border;
        var target = e.target;

        if (target && target.className &&
                target.className.indexOf("draggable") !== -1 && !DRAG.touching) {

            // Save the offset of the touch within the current note
            DRAG.initial_left = dojo._abs(target, true).x;
            DRAG.initial_top = dojo._abs(target, true).y;
            DRAG.touching = [e.pageX - DRAG.initial_left, e.pageY - DRAG.initial_top];

            over_piece(target, {});
        }
    }

    DRAG.dragging = true;
}

// Continue dragging with the mouse
function mousemove(event)
{
    var element, new_x, new_y;
        
    event = event || window.event;

    element = DRAG.element_m;

    // Must have draggable class
    if (!element || element.className.indexOf("draggable") === -1) {
        return;
    }

    new_x = event.clientX - DRAG.initial_x + DRAG.start_x;
    new_y = event.clientY - DRAG.initial_y + DRAG.start_y;

    // Drag
    element.style.webkitTransition = "";
    element.style.left = new_x + "px";
    element.style.top = new_y + "px";
    dragging_over(element, new_x, new_y);

    return false;
}

// Continue dragging with touch events
function touchmove(evt) 
{
    evt.preventDefault();
    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i];

        if (DRAG.touching && e.target.className.indexOf("draggable") !== -1) {
                // Move the node if we're in a state of dragging, but not resizing
                var new_x = e.pageX - DRAG.touching[0];
                var new_y = e.pageY - DRAG.touching[1];

                e.target.style.webkitTransition = "";
                e.target.style.left = new_x + "px";
                e.target.style.top = new_y + "px";

                dragging_over(e.target, new_x, new_y);
                DRAG.element_t = e.target;
        }
    }
}

// Detect if over droppable area and act as needed.
// element: the element that is /being dragged/
function dragging_over(element, left, top)
{
    // Position from center
    var x = left + (DISPLAY.square_width / 2);
    var y = top + (DISPLAY.square_height / 2);

    // Inside board?
    if (x > DROP.area.left && y > DROP.area.top &&
        x < DROP.area.right && y < DROP.area.bottom) {

        DROP.offboard = false;
        element.style.cursor = "move";

        // Find cell mathematically
        var cell_x = Math.ceil((x - DROP.area.left) / DISPLAY.square_width);
        var cell_y = Math.ceil((DROP.area.bottom - y) / DISPLAY.square_height);
        if (cell_y === 0) {
            cell_y = 1;
        }

        // Highlight droppable square
        var flipped = PREFS.flipped;
        if (!VBOARD[flipped ? (GAME_STATE.files + 1) - cell_x : cell_x]) {
            DROP.square = null;
            return;
        }
        var square = VBOARD[flipped ? (GAME_STATE.files + 1) - cell_x : cell_x][flipped ? (GAME_STATE.ranks + 1) - cell_y : cell_y];
        
        if (DROP.square) {
            pop_highlight(DROP.square);
        }

        if (accepts(element, square)) {
            DROP.square = square;

            push_highlight(square, DISPLAY["recent_move_" + square.color]);
        } else {
            DROP.square = null;
        }

    } else {
        // Outside droppable area
        DROP.offboard = true;
        // Change icon to show out of range
        element.style.cursor = "not-allowed";
        
        if (DROP.square) {
            dojo.removeClass(DROP.square, "dropping-square");
            DROP.square = null;
        }

    }
}


// Drop or revert on mouse up
function mouseup()
{
    if (DRAG.element_m === null) {
        return;
    }

    DRAG.element_m.style.zIndex = DRAG.old_zindex;
    document.onmousemove = null;
    document.onselectstart = null;
    DRAG.element_m.ondragstart = null;

    drop_or_revert();

    DRAG.element_m = null;
    DROP.square = null;
}


// Drop or revert on touch end
function touchend(evt)
{
    drop_or_revert();

    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i];

        // Check to see if we've gone from a gesture back down to a touch
        if (e.target && e.target.className && e.target.className.indexOf("draggable") !== -1) {

            out_piece(e.target, {});

            if (evt.targetTouches.length == 1) {
                // If there was rotation, this number needs to be reset
                DRAG.touching = [evt.targetTouches[0].pageX - dojo.style(e.target, "left"), evt.targetTouches[0].pageY - dojo.style(e.target, "top")];
            } else if(!evt.targetTouches.length) {
                // Great use of e.targeTouches, since releasing on finger that's part
                // of a gesture over this node would trigger a touchend even though
                // it could keep going
                DRAG.touching = false;
            }
        }
    }
}

// Return whether square should accept dropping a piece on it
function accepts(piece, square)
{
    // Can never move to source square (not even for null moves).
    if (piece.square && piece.square.x === square.x &&
        piece.square.y === square.y) {
        return false;
    }

    // Can drop anywhere
    if (PREFS.setup_mode) {
        return true;
    }

    if (!piece.square) {
        // If not in setup mode, needs a source square
        return false;
    }

    var outer = IS_VALID_MOVE[piece.square.filerank];
    return outer && outer[square.filerank];
}

// Drop the dragging object (wherever it is), or move it back if it is not over a droppable area
function drop_or_revert()
{
    var piece, square;

    DRAG.dragging = false;

    piece = (DRAG.touching && DRAG.element_t) || DRAG.element_m;
    if (!piece) {
        // Nothing was being dragged
        return;
    }

    square = DROP.square;

    // Dragging offboard: delete in setup mode
    if (DROP.offboard && PREFS.setup_mode) {
        var new_top = dojo.style(piece, "top") + dojo.style(piece, "height") / 2;
        var new_left = dojo.style(piece, "left") + dojo.style(piece, "width") / 2;
        // Shrink off into the distance
        dojo.anim(piece, {width:0, height:0, top:new_top, left:new_left}, PREFS.revert_time, undefined, function() {
                // It was on board, move piece over itself to kill it
                if (piece.square) {
                    do_virtual_move(piece, {x:piece.square.x, y:piece.square.y});
                }
                // Remove node, so leftover torn-off pieces from library
                // that were not dragged anywhere do not accumulate.
                if (piece.parentNode) {
                    piece.parentNode.removeChild(piece);
                }
               
            });
        return;
    }

    // Not valid drop square: revert
    if (!square || !accepts(piece, square)) {
        if (!piece.style.left && !piece.style.top) {
            // Dropped where picked it up - no movement.
            // Do not revert, since would then pop out to (0,0)
            // and revert it back.
            // TODO: tap-to-move, as an alternative to dragging
            return;
        }

        // Revert
        if (typeof WebKitCSSMatrix === "object") {
            // Use webkit transforms if available; faster
            // Feature detection from http://iui.googlecode.com/svn/trunk/test/features.html
            // (detects for css transforms, hopefully close enough)
            piece.style.webkitTransition = "left " + PREFS.revert_time + "ms linear, " + 
                "top " + PREFS.revert_time + "ms linear";
            piece.style.left = DRAG.initial_left + "px";
            piece.style.top  = DRAG.initial_top + "px";
        } else {
            dojo.anim(piece, { left: DRAG.initial_left, top: DRAG.initial_top }, PREFS.revert_time);
        }
        return;
    }

    move_dropped_piece(piece, square, null);
}

// Initialize drag and drop system
function init_dnd() 
{
    document.onmousedown = mousedown;
    document.ontouchmove = touchmove;//mousemove

    document.ontouchstart = touch;
    dojo.query(".draggable").forEach(function(e) {
            e.ontouchmove = touchmove;
        });
    document.ontouchend = touchend;

    DROP.area.left = DISPLAY.board_left;
    DROP.area.top = DISPLAY.board_top;
    DROP.area.width = GAME_STATE.files * DISPLAY.square_width;
    DROP.area.height = GAME_STATE.ranks * DISPLAY.square_height;


    DROP.area.right = DROP.area.left + DROP.area.width;
    DROP.area.bottom = DROP.area.top + DROP.area.height;
}

//// LOW-LEVEL FUNCTIONS

// Get the index of the nth needle in the array. Like Array.indexOf(),
// when nth = 0. If nth = 1, the index of the 2nd occurrence is returned,
// and so on.
function nth_index_of(array, needle, nth)
{
    var hits = 0;

    if (!nth) {
        nth = 0;
    }

    for (var i = 0; i < array.length; i += 1) {
        if (array[i] === needle) {
            if (hits === nth) {
                return i;
            }

            hits += 1;
        }
    }

    return -1;
}

// Return an array including integers between a and b, inclusive.
// inclusive_range(0, 5) and inclusive_range(5, 0) both return
// [0, 1, 2, 3, 4, 5], so you don't have to think about what argument
// goes first.
function inclusive_range(a, b) 
{
    var start = Math.min(a, b);
    var count = Math.abs(a - b);
    var a = []; 
   
    for (var i = start; i <= start + count; i += 1) {
        a.push(i);
    }

    return a;
}


// Escape a plaintext string for displaying in HTML
function escape_html(s)
{
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// Unique an array. Based on http://blog.archive.jpsykes.com/212/unique-array-filter-in-dojo/index.html
function uniq(arr)
{
    var test = {};
    var result = [];

    for (var i = 0, len = arr.length; i < len; i += 1) {
        if (!test[arr[i]]) {
            test[arr[i]] = true;
            result.push(arr[i]);
        }
    }
    return result;
}

// Modify the existing stylesheet, returning the value. If value is
// undefined, get the old value instead of changing it.
function change_css(ordinal, property, value)
{
    var rules = document.styleSheets[0].cssRules || document.styleSheets[0].rules;

    if (value === undefined) {
        return rules[ordinal].style[property];
    } else {
        return rules[ordinal].style[property] = value;
    }
}

// Toggle display of an element
function toggle(element)
{
    // Used to use Scriptaculous Effect.toggle here

    var old = element.style.display;

    element.style.display = old === "none" ? "" : "none";
}



// Return sign of number as {-1,0,1}
function signum(n)
{
    return n > 0 ? 1 : (n < 0 ? -1 : 0);
}

// Get the value of a form element
function form_value(e)
{
    e = dojo.byId(e);

    if (e.checked !== undefined) {
    return e.checked;
    }

    return dojo.byId(e).value;
}

// Get URL query string as an object
// Based on http://www.dojotoolkit.org/book/dojo-porting-guide-0-4-x-0-9/dojo-uri-changes
function query_string()
{
    var parts, dict = {};
    var query;

    if (location.search) {
        query = location.search;
    } else if (location.hash) {
        query = location.hash;
    }
    if (!query) {
        return {};
    }

    parts = query.split(/[&;]/);
    dojo.forEach(parts, function(pair) {
            var part = pair.match(/([a-zA-Z0-9]*)=(.*)/);
            if (part) { 
                dict[part[1]] = decodeURIComponent(part[2]); 
            }
         }, this);

    return dict;
}

// Random integer within range
function randint(minimum, maximum)
{
    return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}

// Uppercase first character, like in Perl
function ucfirst(s)
{
    assert(s.substring, "ucfirst(" + s + "): no substring method, not a string? callee=" + 
            arguments.callee);
    return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
    return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
    if (!expression) {
        if (GAME_STATE.alert_assert) {
            alert(message);
        }

        if (window.console && console.trace) {
            // Give a stack trace for Firebug
            console.trace();
        }

        throw new AssertException(message);
    }
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
var ORIGINAL_ONSELECTSTART;
function enable_document_selection(enable, element) 
{
    var element = element || document;

    if (enable) {
        element.onselectstart = ORIGINAL_ONSELECTSTART;
    } else {
        ORIGINAL_ONSELECTSTART = element.onselectstart;
        element.onselectstart = function() { return false; };
    }
}

dojo.addOnLoad(main);
</script>
</head>
<body class="tundra">

<table id="outer">
<tr>
<td style="vertical-align: top">

<canvas id="canvas-board">Sorry, you are using a browser that does not support HTML5. Time to upgrade. Or you can use the <a href="oldtableboard.html">old HTML-table-based</a> version, but it is no longer maintained.</canvas>

<p id="welcome" style="display: none">Welcome, <span id="welcome_name">unknown</span></p>
<p id="not_logged_in" style="display: none">You are not logged in.</p>
<p id="logout_link" style="display: none"><a href="#" onclick="logout()">Logout</a>
<p id="login_link" style="display: none"><a href="#" onclick="login()">Login</a>

<!-- TODO: remote game selection, if logged in. Maybe a CSS class to toggle only when logged in, too. -->

<!--
<p>
<iframe src="about:blank" id="login_iframe" style="display: none; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%"></iframe>
-->

</td><td style="vertical-align: top">
<noscript><p>JavaScript is disabled, nothing will work!</p></noscript>

<div id="game_ui">

<!-- Header elements, game metadata. Hidden/shown as needed. -->
<p id="header" style="display: none; text-align: center" 
onclick="edit_pgn()" class="show_White">
<span class="players">
<span id="PGN_White" class="player_name" style="display: none">White</span>
<span class="player_elo"><span style="display: none" class="show_WhiteElo">(</span><span id="PGN_WhiteElo" style="display: none">1500</span><span class="show_WhiteElo" style="display: none">)</span></span>
<span id="vs" style="display: none" class="show_White">vs.</span>
<span id="PGN_Black" class="player_name" style="display: none">Black</span>
<span class="player_elo"><span style="display: none" class="show_BlackElo">(</span><span id="PGN_BlackElo" style="display: none">1500</span><span class="show_BlackElo" style="display: none">)</span></span>
</span>
<br class="show_White" style="display: none">

<span id="PGN_Event" style="display: none">Event</span>
<span style="display: none" class="show_Round">(</span><span id="PGN_Round" style="display: none">Round</span><span style="display: none" class="show_Round">)</span>
<span id="PGN_Site" style="display: none">Site</span><br class="show_Event" style="display: none">

<span id="PGN_Date" style="display: none">Date</span>
<span id="PGN_Time" style="display: none">Time</span>
</p> 

<p onclick="edit_pgn()">
<span id="status"></span> 
<span id="dash" style="display: none">&mdash;</span>
<span id="check"></span>
</p>

<p>
<span id="promote_container"></span>
</p>

<p><a id="copyable_link">link</a> (<a href="#" onclick="email_board()">email</a>)
<p><span id="opening_name"></span>

<div id="piece-inspector" style="display: none; z-index: 2">
<p><span style="vertical-align: middle" id="inspector-image"></span> <span id="inspector-type" style="font-weight: bold">type</span>
<p>Movement: <span id="inspector-movement">movement</span>
<p>Tags: <span id="inspector-tags">tags</span>
<p>Symbols: <span id="inspector-symbols">symbols</span>
<p><span id="inspector-info">other info</span>
<p><div id="inspector-diagram"></div>
</div>

<!-- TODO: disclosure triangles -->
<p><a href="#" onclick="var _c=dojo.byId('controls');_c.style.display=_c.style.display==='none'?'':'none'" accesskey="c">controls</a> | 
<a href="#" onclick="toggle_piece_library();" accesskey="s">setup</a> |
<a href="#" onclick="toggle_game_browser()">saved</a>

<div id="controls" style="display: none; border-left: 2px solid blue">
<div>

<p><select accesskey="m" id="make_move_menu" onchange="make_move_by_menu(this)"></select>

<!-- TODO: hide all this, since the purpose of this app is
not to implement chess AI. But having automatic moves is useful for testing. -->
<p>Engine: <label for="white_computer"><input accesskey="w" type="checkbox" id="white_computer" name="white_computer" onclick="computer_move_if_applicable(this)">White</label> 
<label for="black_computer"><input accesskey="b" type="checkbox" id="black_computer" name="black_computer" onclick="computer_move_if_applicable(this)">Black</label>

<span id="score"></span><br>

<div id="show_skill" style="display: none"><p>Skill Level: 
<input type="text" size="3" maxlength="3" id="skill_level" onchange="update_skill(this)"></div>

<p><select accesskey="o" id="output_notation" name="output_notation" onchange="PREFS.output_notation = form_value(this); show_move_history()"></select>

<p><a href="#" onclick="edit_pgn()">import/edit PGN</a>

 <p>
 <label for="enable_flip"><input accesskey="f" name="enable_flip" id="enable_flip" type="checkbox" onclick="flip()">Flip</label>

 <label for="enable_setup_mode"><input accesskey="e" name="enable_setup_mode" id="enable_setup_mode" type="checkbox" onclick="set_setup_mode(this.checked)">Setup</label>

 <p><select id="saved_board_menu" onchange="change_loaded_board(this)"></select>
     <button onclick="change_loaded_board(dojo.byId('saved_board_menu'))" accesskey="n">New Game</button>
 <p><input name="variant_code" id="variant_code" size="10" style="display: none" onchange="update_variant_code(this.value)">
 
 </div>
 </div>
 <!-- end controls-->

 <div id="piece-library-parent" style="display: none">
 <div id="piece-library" style="width: 600px; height: 325px; overflow: auto; position: relative"> </div>
 </div>
 <!-- end piece library -->

  <div id="captured_piece_images" style="width: 250px;"></div><br>
  <div id="moves_container" style="width: 500px; text-align: justify">
  <!-- TODO: scrollbar, http://livepipe.net/control/scrollbar -->
  <!-- TODO: use contenteditable=true for in-place editing in Safari -->
  <p id="move_history"></p>
  </div>
</div>

 </td>
</tr>
</table>

<div id="game-browser" style="display: none; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; z-index: 2"></div>

</body>
</html>
