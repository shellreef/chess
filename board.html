<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="viewport" content="width = 320">
<!-- TODO <base href="http://xyzzy.freeshell.org/chess/"> -->
<title>Chess by Jeff</title>
<!-- Copyright (C) 2009 Jeff Connelly -->
<!-- Created:20090411 -->
<style type="text/css">
body {
    font: medium 'Gill Sans', sans-serif;
    line-height: 1.3;
    word-spacing: 0.1em;
    margin: 0;
    padding: 0;
    border: 0;
}

a { text-decoration: none; }
a:hover { border-bottom: 1px dotted; }

/* Header */
span.players { font-size: large; }
span.player_name { font-weight: bold; }
span.player_elo { font-size: small; }

span#status { font-weight: bold; }
span#opening_name { font-size: small; }

/* PGN */
span.fullmove_number { font-weight: bold; }
a.active_move { border-bottom: 1px dashed; }
/*a.repeated_move { text-decoration: underline; }*/     /* goes well with dots and dashes */
/*a.repeated_move { background-color: yellow; }*/   /* highlight */

/* TODO: switch to divs, for flexibility, and use background-image.. or maybe not */
img.piece
{ 
 border: none;
 margin: 0px;

 /* TODO: Transition when promote, would be nice to be
  * able to do with a CSS transition, but img src is not
  * a CSS property, but a tag attribute. And even if tried to animate
  * background-image, it wouldn't work until 6806248 is fixed.
  *
  * Or could have two images and change their opacity, see
  * http://www.the-art-of-web.com/css/timing-function/ section 4, but
  * that is even worse. */
 /*-webkit-transition: background 1s linear;*/
}

img.black {}
img.white {}

table.board
{
 /*border: 2px solid black;*/

/* This is like cellspacing=0 cellpadding=0 */
 border-collapse: collapse;

/* Firefox: disable text selection when dragging */
 -moz-user-select: none;
}

td.square
{
 border-style: none;
 /* border: 1px solid black; */
 padding: 0em;
 margin: 0em;
 width: 55px;
 height: 55px;
 text-align: center;
}

td.label { text-align: center; }
td.file { border-bottom: 2px solid black; }
td.rank { border-right: 2px solid black; padding-right: 5px; }
td.right-edge { border-right: 2px solid black; }
td.bottom-edge { border-bottom: 2px solid black; }

td.hover 
{ 
 /* border: 1px solid black; */
 background-color: blue !important;
}


/* Colors based on http://en.wikipedia.org/wiki/Chessboard
 * Useful site: http://www.cssdrive.com/imagepalette/index.php
 * Colors palette generator, get colors of an arbitrary image.
 *
 * Other colors to consider: http://chessos.com/, higher contrast
 *  http://chessteacher.110mb.com/, much lighter
 * But I like these, gives it a nice wooden feel. Could also
 * use green for a tournament-style board.
 */
td.white { background-color: #ffce9e; }
td.black { background-color: #d18b47; }

/* Highlights */

/* different shades of tan
td.legal-move-white { background-color: #cf9e6e; }
td.legal-move-black { background-color: #a15b17; }
*/
/* Green tint */
td.legal-move-white { background-color: seagreen; }
td.legal-move-black { background-color: green; }

td.recent-move-white { background-color: #0066ff; }
td.recent-move-black { background-color: #0099ff; }

/* TODO:
 * yellow - piece to promote
 * green - move just made
 * blue - move opponent just made
 * red - destination square if capture move
 */


/* Would be cool to use CSS3 expressions to make the pattern, but they're not in
 * Firefox 3.0.8, maybe in Firefox 3.1. Safari has them though! 
 * If do this, would need to remember to shift nth-child per ranks. 
 *td:nth-child(2n) { background-color: green } */

</style>
<!-- <script type='text/javascript' src='http://getfirebug.com/releases/lite/1.2/firebug-lite-compressed.js'></script> -->
<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js"></script>
<script src="http://www.google.com/jsapi"></script>
<script type="text/javascript">
/*jslint bitwise: true, browser: true, eqeqeq: true, immed: true, newcap: true, nomen: true, plusplus: true, regexp: true, undef: true*/
/*global window google $ $F $$ Hash $break Builder Event Droppables Draggable*/

if (!window.google) {
    alert("Google was not found. Nothing will work.");
}

/* TODO: why aren't these miniifed? http://code.google.com/apis/ajaxlibs/documentation/index.html#prototype has
 * direct paths but neither prototype nor scriptaculous are minified.. others are though. Maybe just use raw JS. */
/* TODO: http://compressorrater.thruhere.net/ */
google.load("prototype", "1.6.0.3");
google.load("scriptaculous", "1.8.2");

// Preferences, not game state.
var PREFS = {
    input_notation: "SAN",

    // What piece images to use  - TODO: option to change
    image_set: "alfaerieomega",   // See README in that directory
    //image_set: "ariel",    // based on Ariel Unicode MS
    //image_set: "chessos",
    
    engine: "http://jeff.tk:81/chess/crafty.cgi",
    skill: 100                // engine strength, 0-100
};

// Chess movement notations, in descending precedence. 
// For more info see http://en.wikipedia.org/wiki/Chess_notation
var AVAILABLE_NOTATIONS = {
    SAN:  "Standard Algebraic Notation",//              Bxc6        e5
    LAN:  "Long Algebraic Notation",//                  Bb5xc6      e7-e5
    MAN:  "Minimal Algebraic Notation",//               Bc6         e5
    RAN:  "Reversible Algebraic Notation",//            Bb5xNc6     e7-e5
    CRAN: "Concise Reversible Algebraic Notation",//    Bb5:Nc6     e75
    FAN:  "Figurine Algebraic Notation",//              ♗xc6        ♟e5
    ICCF: "ICCF Numeric Notation",//                    2536        5755
    coord:"Coordinate Notation",//                      B5-C6       E7-E5
    smith:"Smith Notation",//                           b5c6n       e7e5
    descr:"English Descriptive Notation",//             BxN         P-K4
    adesc:"Algebraic Descriptive Notation"//            BxN         P-e4
};


// Info about the game
var GAME_STATE = {
    // Whose turn it is
    active_color: '',
    
    // Castling privileges
    can_castle: {white: {cshort: true, clong: true}, black: {cshort: true, clong: true}},

    ep_target: null,

    halfmove_clock: 0,          // Ply since last pawn advance / capture
    fullmove_number: 0,         // Increment after black moves

    // Not game state, but other globals
    dragging: false,
    position_moves: {},         // Board position -> move IDs, for 3n move repetition
    position_after: {},         // Board positions at each move, for playback
    active_in_check: false,
    ended: false,               // Game is done (drawn, won)
    recent_piece: null,         // Recently moved piece
    recent_square: null         // Recently moved from square
};    

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;             // Keyed by filerank of source, array of moves, x, y and any flags
var VALID_MOVES_OPP = null;         // Moves opponent could make, if it was their turn (attacking)
var VALID_MOVE_NOTATIONS = null;    // Map SAN, LAN, MAN, RAN, CRAN, FAN, coord, desc, Smith etc. -> [piece, square]
var ALT_MOVE_NOTATIONS = null;      // Same as above, but non-canonical, longer forms (Nb1c3 when Nc3 would do, etc.)
var ALL_DROP_TARGETS = [];          // Droppables for UI

// Board 
var RANK_MAX = 8;
var FILE_MAX = 8;
var SQUARES = null;                 // Get table cell square node by rank and file
var VBOARD = null;                  // Virtual in-memory board

var AMP = String.fromCharCode(38);  // To avoid "not well-formed"

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
    // Keys:
    // parlett: movement of piece in extended Parlett notation
    // letter: uppercase character representing the piece in FEN
    // alg_letter: uppercase character for algebraic notation [defaults to FEN letter]
    // royal: if true, if checked, must make move that unthreatens, otherwise checkmate
    // castles_with: piece to move in conjunction with this piece if castling
    // castle: if true, this piece can be moved during castling
    // promote: array of piece names that this piece can promote to, in order of preference
    // figurines: [white, black] Unicode strings for Figurine Algebraic Notation

    // Standard international chess piece
    
    //king: {parlett: "1*, imR2=e", letter: "K", royal: true, castles_with: "rook", figurines: ["\u2654", "\u265a"]},    // or: ~1/1, ~1/0

    // TODO: @ for absolute, @3,0 and @4,0 short, then @7,0 for @6,0, in order to allow
    // Chess960 orthodox castling when rooks &amp; kings are not at known positions.
    //king: {parlett: "1*", /*[@3,0;move_a_castle_to=@4,0], [@7,0;move_h_castle_to=@6,0]",*/
    // TODO: actually pay attention to move_{a,h}_castle_to commands, instead of having the logic in piece moved,
    king: {parlett: "1*, [-2,0;if_can_castle_long;if_unblocked=-1,0;if_unblocked2=-2,0;if_unblocked3=-3,0;move_a_castle_to=3,0], " +
              "[2,0;if_can_castle_short;if_unblocked=1,0;if_unblocked2=2,0;move_h_castle_to=-2,0]",
          royal: true, letter: "K", figurines: ["\u2654", "\u265a"],
          castles_with: "rook"},
    queen: {parlett: "n*", letter: "Q", figurines: ["\u2655", "\u265b"], iccf_number: 1},
    rook: {parlett: "n+", letter: "R", castle: true, figurines: ["\u2656", "\u265c"], iccf_number: 2},
    bishop: {parlett: "nX", letter: "B", figurines: ["\u2657", "\u265d"], iccf_number: 3},
    knight: {parlett: "~1/2", letter: "N", figurines: ["\u2658", "\u265e"], iccf_number: 4},


    // Pawn in new notation
    pawn: {parlett: 
        "o1>, c1X>, " + 
        "oi[0,2;if_unblocked=0,1;mark_ep_target=0,1], " +
        "[-1,1;if_ep_target;capture_at=-1,0], [1,1;if_ep_target;capture_at=-1,0]",

        image: "pawn",
        promote: ["queen", "knight", "rook", "bishop"],
        figurines: ["\u2659", "\u265f"],
        letter: "P",
        alg_letter: "",
        resets_50move: true     // a pawn move resets the halfmove counter for the 50-move rule
    },

    // OLD NOTATION
    // P allows for moving to GAME_STATE.ep_target square (must be before other capture move)
    // oi2> is another way to write the one/two-forward move, but it is really two possible moves:
    // - oi2>eE: exactly two forward, store piece behind in ep_target (notated by "E")
    // - oi1>e: exactly one forward
    //pawn: {parlett: "o1>, P, c1X>, oi2>eE, oi1>e", letter: "P", alg_letter: "", promote: ["queen", "knight", "rook", "bishop"], figurines: ["\u2659", "\u265f"]},

    // Other hippogonals, good for testing
    zero: {parlett: "~0/0", letter: "O"},
    man: {parlett: "1*", letter: "M"},    // same as king, but not royale (also known as commoner), alternate image: guard
    warmachine: {parlett: "~2+", letter: "D"},  // or ~2/0
    alfil: {parlett: "~2X", letter: "Y"},       // TODO: image, pieceolpedia uses an elephant, but.. //  or ~2/2
    alibaba: {parlett: "~2/0, ~2X", letter: "L", image:"elephantwarmachine"},
    squirrel: {parlett: "~0/2, ~1/2, ~2/2", letter: "S"},
    threeleaper: {parlett: "~3/0", letter: "H"}, 
    tripper: {parlett: "~3/3", letter: "XT"},
    camel: {parlett: "~1/3", letter: "W"},
    zebra: {parlett:"~2/3", letter: "Z"},
    giraffe: {parlett: "~1/4", letter: "XG"},
    antelope: {parlett: "~3/4"}, 
    flamingo: {parlett: "~1/6"}, 

    // Amphibians (combined leapers)
    frog: {parlett: "~1/1, ~0/3", letter: "F"},     
    bison: {parlett: "~1/3, ~2/3"},                 
    gnu: {parlett: "~1/2, ~1/3"},                  
    root_fifty_leaper: {parlett: "~5/5, ~7/1"},     
    // TODO: root-65 leaper, bat, see http://members.shaw.ca/quadibloc/chess/ch03.htm
    buffalo: {parlett: "~1/2, ~1/3, ~2/3"},         

    maharajah: {parlett: "#amazon", letter: "XJ", royal: true, image:"paladin"},   // Q+N+K, Maharajah chess TODO: crown amazon?
    royal_knight: {parlett: "#knight", letter: "XR", royal: true, image:"knight"},  // Knightmate chess TODO: crown on knight
    royal_queen: {parlet: "#queen", royal: true}, 

    // Combined pieces
    // From piecelopedia or http://members.shaw.ca/quadibloc/chess/ch03.htm or 
    // http://www.chessvariants.com/graphics.dir/alfaerie/
    equesrex: {parlett: "#king, #knight", image:"equesrex", royal: true},
    centaur: {parlett: "#knight, #man"},         // not royal, so not an equesrex  TODO: remove cross, make bcentaur.gif?
    amazon: {parlett: "#queen, #knight", letter: "XV"},     // Q+N, aka superqueen
    chancellor: {parlett: "#rook, #knight", letter: "C"},   // R+N, aka empress, marshal (Capablanca, X-FEN standard)
    archbishop: {parlett: "#bishop, #knight", letter: "A", image: "cardinal"}, // B+N, aka cardinal, princess, janus (Capablanca, X-FEN standard)
    dragon: {parlett: "#pawn, #knight", image: "pawnknight"},   // alt image: dragon, but less descriptive
    dragonhorse: {parlett: "#bishop, #wazir", image: "promotedbishop"},
    berse: {parlett: "#rook, #ferz", image: "promtoedrook"},    // aka dragon king, but its not royal
    caliph: {parlett: "#camel, #bishop", image: "camelbishop"},
    pope: {parlett: "#king, #bishop", image:"kingbishop"},  // http://www.chessvariants.com/difftaking.dir/thunder.html 
    dragon_king: {parlett: "#king, #rook", royal: true},  

    knightcamel: {parlett: "#knight, #camel"},
    elephantwarmachine: {parlett: "#elephant, #warmachine"},
    bishoppawn: {parlett: "#bishop, #pawn"},
    rookpawn: {parlett: "#rook, #pawn"},
    knightfers: {parlett: "#knight, #ferz", image: "knightferz"},
    knightwazir: {parlett: "#knight, #wazir"},
    elephantwazir: {parlett: "#elephant, #wazir"},
    elephantferzwarmachine: {parlett: "#elephant, #ferz, #warmachine"},
    warmachinewazir: {parlett: "#warmachine, #wazir"},

    // David's pawn
    pawnattackrook: {parlett: "#pawn, c#rook", image:"pawn135cw", promote: ["dragon", "rookpawn"]},

    walker: {parlett: "o#wazir, c#ferz"},
    tiger: {parlett: "o#bishop, c#knight"},
    bd: {parlett: "#warmachine, #bishop", image:"bishopwarmachine"},
    canvasser: {parlett: "#camel, #rook", image:"camelrook"},
    carpenter: {parlett: "#knight, #warmachine", image:"knightwarmachine"},
    champion: {parlett: "#wazir, #alfil, #warmachine"},
    crowned_rook: {parlett: "#rook, #ferz"},      
    general: {parlett: "#ferz", royal: true}, 
    kangaroo: {parlett: "#knight, #alfil"},  
    wizard: {parlett: "#camel, #ferz"},
    waffle: {parlett: "#wazir, #alfil", image:"elephantwazir"},
    fad: {parlett: "#ferz, #alfil, #warmachine", image:"elephantferzwarmachine"},
    bede: {parlett: "#bishop, #warmachine", image:"bishopwarmachine"},

    // More complex fairy / non-intl chess pieces
    // See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
    // and even better, Piecelopedia 
    // http://chessvariants.wikidot.com/pcp:piececlopedia
  
    lance: {parlett: "n+>"},
    colonel: {parlett: "n>, n=, 2/1>, 1*", letter: "XC"}, 
    murray_lion: {parlett: "~0/2, ~2/2, c1*", letter: "XM"},
    lion: {parlett: "~n*", letter: "XL"},
    berolinapawn: {parlett: "o1X>, c1>, io2X>", letter: "XB", image:"berolinapawn", resets_50move: true},
    superpawn: {parlett: "on>, cnX>", letter: "XP", image:"pawninv"},
    elephant: {parlett: "2X", letter: "E"},         // Not a leaper, path can be blocked (unlike alfil, ~2X)
    khohn: {parlett: "1X, 1>", letter: "XK"},
    ferz: {parlett: "1X", letter: "XF"},
    wazir: {parlett: "1+", letter: "I"},
    // TODO: mushroom, try out Extended Parlett's [], explicitly giving relative moves. See:
    // http://www.chessvariants.org/graphics.dir/alfaeriemisc/spratt/ - would need to add (and all others)
    // http://www.chessvariants.org/piececlopedia.dir/mushroom.html
    // TODO: support ~0/0 for "null move" (---), but don't let drop to null, instead show a button
    kraken: {parlett: "~n/m ~0/0"},     // any square, not realistic since always checkmates!
    octopus: {parlett: "o~n/m ~0/0", letter: "XD"}, // any square (8x8, octo, get it?) but can't capture, much less powerful
    universal_leaper: {parlett: "~n/m"},// like kraken, but can't go to square it is on (like a zero)
    airplane: {parlett: "o~n/m", letter: "U", image:"plane"},

    // Pieces from chess-3
    // http://www.chessbase.com/newsdetail.asp?newsid=4553
    // TODO: instead of using composite pieces, which aren't totally accurate because the
    // extra moves are non-capturing (jous is not strictly knight + wazir, since the wazir moves can't capture!)
    // frookbbishop, knightwazir?
    
    // rook + can move (not capture) like bishop
    tower: {parlett: "#rook, o#bishop", castle: true, letter: "T", image: "rookinv"},  

    // knight + can move (not capture!) like wazir
    jous: {parlett: "#knight, o#wazir", letter: "J", image: "knightwazir"}, 

    // bishop + can move (not capture) 1 or 2 squares orthogonally
    vicar: {parlett: "#bishop, o2+", letter: "V", image: "bishopinv"}

    // Pieces that probably won't be supported without significant coding
    //leo: {parlett: "on*, c^" + AMP, letter:"XO"},        // no &amp; support, whatever that is
    //knightrider: {parlett: "n(1/2)", letter:"XN"},  // no grouping support, sadly
    //checker: {parlett: "cn(^2X>), o1X>", promote: "checker_kinged", letter:"XY"},  // no grouping
    //checker_kinged: {parlett: "cn(^2X), o1x", letter:"XZ"},
    //spy: {parlett: "2>, 2=, (1/1)>", letter:"XS"}  // no grouping
    // pieces with no notation. WinChloe supports 1400 pieces.
    //
    // TODO: pieces from http://members.shaw.ca/quadibloc/chess/ch04.htm
};

// Saved board setups in FEN
var SAVED_BOARDS = {
    "Chess & Variants": {
// Standard chess and variants. 
// Sources:
// http://www.pathguy.com/chess/ChessVar.htm
// http://www.chessclub.com/helpcenter/tips/wild.html
"International Western Chess": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
"Advance Chess":        "rnbqkbnr/8/pppppppp/8/8/PPPPPPPP/8/RNBQKBNR w KQkq - 0 1",
"Amazon Chess":         "rnbxvkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBXVKBNR w KQkq - 0 1",
"Atheist Chess": "rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RN1QK1NR w KQkq - 0 1",
"Berolina Chess": "rnbqkbnr/xbxbxbxbxbxbxbxb/8/8/8/8/XBXBXBXBXBXBXBXB/RNBQKBNR w KQkq - 0 1",
// TODO: win if promote (kraken?), allow diagonal even if not capture
// http://en.wikipedia.org/wiki/Breakthrough_(board_game)
//"Breakthrough": "pppppppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPPPPP w - - 0 1",
// TODO: Support Chaturanga pawns. No double move/en passant, and promotes to where started.
//"Chaturanga": "rnekxfenr/pppppppp/8/8/8/8/PPPPPPPP/RNEKXFENR w - 0 1",
"Church Chess":         "bbbbkbbb/pppppppp/8/8/8/8/PPPPPPPP/BBBBKBBB w - - 0 1",
"Corner Chess":         "4rbqk/4rb1q/4r1bb/5rrr/RRR5/BB1R4/Q1BR4/KQBR4 w - - 0 1",
"Corner Chess II":      "kbp2pbq/nrp2prn/pp4pp/8/8/PP4PP/NRP2PRN/QBP2PBK w - - 0 1",
"Corridor Chess":       "1nrqkrn1/2b2b2/1pppppp1/8/8/1PPPPPP1/2B2B2/1NRQKRN1 w - - 0 1",
"Commoner Chess":     "rnbqmbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQMBNR w KQkq - 0 1",
"Desegregated Chess": "RNbqKBnr/ppPpPPPp/8/8/8/8/PPpppPpP/rnBQkBnr w KQkq - 0 1",
"Dunsany's Chess": "rnbqkbnr/pppppppp/8/8/PPPPPPPP/PPPPPPPP/PPPPPPPP/PPPPPPPP w kq - 0 1",
"Eight Kings Chess":    "kkkkkkkk/pppppppp/8/8/8/8/PPPPPPPP/KKKKKKKK w - - 0 1",
"Fianchetto Chess":     "bnrqkrnb/pppppppp/8/8/8/8/PPPPPPPP/BNRQKRNB w KQkq - 0 1",
"Fortress Chess":       "rnbqkbnr/pppppppp/ppp4/8/8/5PPP/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
// TODO: White wins if captures all black's pieces
"Horde Chess":          "ppp2ppp/pppppppp/pppppppp/pppppppp/3pp3/8/PPPPPPPP/RNBQKBNR w KQ - 0 1",
"Knight Odds Chess":   "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/R1BQKBNR w KQkq - 0 1",
"Knightmate Chess":    "rmbqxrbmr/pppppppp/8/8/8/8/PPPPPPPP/RMBQXRBMR w KQkq - 0 1",
// TODO: No black pawn promotion
"Maharajah and the Sepoys":     "rnbqkbnr/pppppppp/8/8/8/8/8/4XJ3 w kq - 0 1",
"Marxist Chess (DLS-CSB)":       "8/pppppppp/8/8/8/8/PPPPPPPP/8 w - - 0 1",
"Marxist Chess (2x)":       "pppppppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPPPPP w - - 0 1",
"Missionary Chess": "pppppppp/ppppqppp/8/8/4K3 w - - 0 1",
"Mind Chess": "8/8/8/8/8/8/8/8 w - - 0 1",
"Mongredian Chess":    "rbbqknnr/pppppppp/8/8/8/8/PPPPPPPP/RBBQKNNR w - - 0 1",
"Obama Chess": "rnbqKbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQkBNR b KQkq - 0 1",
"Pawn's Game Chess": "rnbqkbnr/pppppppp/8/8/2PPPP2/1PP2PP1/PPPPPPPP/RNB1KBNR w KQkq - 0 1",
"Pawn Massacre Chess": "RNBQKBNR/pppppppp/8/8/8/8/PPPPPPPP/rnbqkbnr w KQkq - 0 1",
"Pawn Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPP1PP/RNBQKBNR w KQkq - 0 1",
"Pawnless Chess":      "rnbqkbnr/8/8/8/8/8/8/RNBQKBNR w KQkq - 0 1",
"Peasant's Revolt Chess I":"1nn1knn1/4p3/8/8/8/8/PPPPPPPP/4K3 w - - 0 1",
"Peasant's Revolt Chess II":"1nn1k1n1/4p3/8/8/8/8/PPPPPPPP/4K3 w - - 0 1",
"Peasant's Revolt Chess III":"1n2k1n1/2p1p3/8/8/8/8/PPPPPPPP/4K3 w - - 0 1",
"Power Chess / Wild 18":"qqqqkqqq/pppppppp/8/8/8/8/PPPPPPPP/QQQQKQQQ w - - 0 1",
"Power Chess II":       "rrbqkbrr/bbnnnnbb/pppppppp/8/8/PPPPPPPP/BBNNNNBB/RRBQKBRR w - - 0 1",
"Queen Odds Chess":    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB1KBNR w KQkq - 0 1",
"Reverso Chess":        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBKQBNR w KQkq - 0 1",
"Revolt Chess": "pppppppp/rnbqkbnr/8/8/8/8/RNBQKBNR/PPPPPPPP w KQkq - 0 1",
"Republican Chess": "rnb2bnr/pppppppp/8/8/8/8/PPPPPPPP/RNB2BNR w - - 0 1",
"Rook Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/1NBQKBNR w KQkq - 0 1",
"Royal Stables Chess":  "nnnnknnn/pppppppp/8/8/8/8/PPPPPPPP/NNNNKNNN w - - 0 1",
// Shatranj, except the following rules are NOT implemented:
// 1. Pawns can't make double moves
// 2. Pawn only promotes to ferz
// 3. Stalemating your opponent wins
// 4. Taking the last piece of your opponent wins, unless your opponent
//    can take your last non-king piece too, in which case the game is drawn
//"Shatranj (Not Quite)":     "rnykxfynr/pppppppp/8/8/8/8/PPPPPPPP/RNYKXFYNR w - - 0 1",
"Survival Chess": "nnnpnpnn/pppnnnpn/nppppppp/np4pn/np2P1pn/pp4pn/nppppppp/nnpnnnpn w - - 0 1",
"Twin Chess":           "rbqkkqbr/pppppppp/n6n/8/8/N6N/PPPPPPPP/RBQKKQBR w - - 0 1",
"Twin Chess B":         "nkbqqbkn/r2pp2r/pppppppp/8/8/PPPPPPPP/R2PP2R/NKBQQBKN w - - 0 1",
"Upside-Down Chess / Wild 5":    "RNBQKBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbqkbnr w KQkq - 0 1",
"Vegetarian Chess": "r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BQKB1R w KQkq - 0 1",
"Weak! / Seven Knights Chess":  "nnnnknnn/pppppppp/2p2p2/1pppppp1/8/8/PPPPPPPP/RNBQKBNR w - - 0 1",
"Wild Chess 7 ":        "4k3/5ppp/8/8/8/8/PPP5/3K4 w - - 0 1",
"Wild Chess 8":         "rnbqkbnr/8/8/pppppppp/PPPPPPPP/8/8/RNBQKBNR w KQkq - 0 1",
"Wild Chess 19":        "8/6k1/4p3/4N3/8/6K1/7N/8 w - - 0 1"
    },

    "Chess Openings": {
    },

    "Test Pieces": {
"Test Pawns": "8/x(rookpawn)x(dragon)x(bishoppawn)x(superpawn)1x(berolinapawn)x(pawnattackrook)x(pawn)/8/8/8/8/X(rookpawn)X(dragon)X(bishoppawn)X(superpawn)1X(berolinapawn)X(pawnattackrook)X(pawn) w - - 0 1",
    },

    "Test Rules": {
"Test Checkmate": "r1bknbrN/pppppppp/8/8/8/8/PPPPPPPP/nRBNKB1R b - - 0 1",
"Test Stalemate":     "k7/8/8/8/8/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5",
"Test Remove Check by Capture":     "4k3/1p6/2Q5/8/8/8/8/7K b - - 0 5",
"Test Promotion":     "K/PPPPPPPP/8/8/8/8/pppppppp/7k b - - 0 5",
"Test Promotion to Rook": "8/k1P5/p7/P3K3/8/8/8/8 w - - 0 53", // from http://chessteacher.110mb.com/2008/10/22/minor-promotion/
"Test Promotion to Bishop": "8/5P1k/5K1p/7P/8/8/8/8 w - - 0 51",
"Test En Passant (alone)":     "8/8/8/3pP3/8/8/8/8 w - d6 0 5",
"Test En Passant":     "rnbqkbnr/ppp2ppp/8/3pP3/3Qn/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5",
"Test En Passant into Check": "qk6/8/8/3pP3/8/8/8/7K w - d6 0 5",
"Test Lone King": "K w KQkq - 0 1",
"Test K + K":     "k7/8/K7/8/8/8/8/8 b - - 0 30",
"Test K + KQ":     "k7/8/8/8/8/8/8/5KQ1 w - d6 0 50",
"Test K + KR":     "k7/8/8/8/8/8/8/5KR1 w - d6 0 50",
"Test K + KB":     "k7/8/K7/8/8/8/8/B b - - 0 30",
"Test K + KN":     "k7/8/K7/8/8/8/8/N b - - 0 30",
"Test KB + KB opposite colors":     "k7/8/K7/8/8/8/b/B b - - 0 30",
"Test KB + KB same colors":     "k7/8/K7/8/8/8/3b/B b - - 0 30",
"Test KBB + KBB same colors":     "k7/8/K7/8/8/8/3b1b/B3B b - - 0 30",
"Test KBB + KBB opposite colors":     "k7/8/K7/8/8/8/3b1b/B2B b - - 0 30",
"Test Castling out of Check":     "4r3/8/8/8/8/8/8/R3K2R w KQkq - 0 1",
"Test Castling through Check":     "1k3r2/8/8/8/8/7Q/8/R3K2R w KQkq - 0 1",
"Test Castling through Check (pawn)": "rnbqkbnr/pppp2pp/8/6N1/4p3/3B4/PPPP2pP/RNBQK2R w KQkq - 0 7",
"Test Castling w/ Intervening Pieces":     "1k/8/8/8/8/8/8/R3KQ1R w KQ - 0 1",
"Test Only Move ":     "rnbqkbnr/ppp2ppp/8/8/8/8/PPP2PPP/RNBQKBNR w KQkq - 0 1",
"Test Disambiguation by File":     "k7/8/8/8/8/8/3N4/6N1 w - - 0 1",
"Test Disambiguation by Rank":     "k7/8/8/6N1/8/8/8/6N1 w - - 0 1",
"Test Disambiguation by File+Rank":     "k7/8/8/4N1N1/3N3N/8/3N3N/4N1N1 w - - 0 1",
"Test Disambiguation w/ 8 Queens": "3Q4/6q1/2Q5/7q/1Q6/4q3/7Q/5q2 w - - 0 1",
"Test vboard Check-Checking": "8/8/R2k2p1/3n1bp1/1p6/1P3P1P/5KP1/8 b - - 0 36",
"Test Getting out of Check": "rnbqkbnr/ppp1p1pp/4P3/3p3Q/5p2/8/PPPP1PPP/RNB1KBNR b KQkq - 0 4",
"Test Check Checking": "rnbQ1bnr/ppp1kppp/8/4p3/7q/8/PPPP1PPP/RNBQKBNR b KQ - 0 5",
"Test Parlett Move Interference": "r/8/8/1N3b2/3PP3/1P1BBN/8/8 w - - 0 17",
"Test Fairy Pieces": "X(airplane)x(airplane)/3x(pawnattackrook)x(caliph)x(pope)X(elephantwarmachine)/8/8/8/4S/X(lance)fwZ1X(pawnattackrook)/AcDeIFvT w - - 0 1"
    }
};

// Opening positions along with extended ECO codes and common names
// Extended ECO codes are from scid.eco, see http://scid.sourceforge.net/help/ECO.html
//  and http://scid.sourceforge.net/help/EPD.html
// These are listed keyed by FEN without move information, so they can be recognized
// directly from the board position, rather than the move history, allowing for easier
// transposition.
var OPENINGS = {
    // 0th level
    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -": "A00a Standard Start Position",

    // 1st level
    "rnbqkbnr/pppppppp/8/8/8/P7/1PPPPPPP/RNBQKBNR b KQkq -": "A00f Anderssen Opening",
    "rnbqkbnr/pppppppp/8/8/P7/8/1PPPPPPP/RNBQKBNR b KQkq a3": "A00e Ware Opening / Meadow Hay",
    "rnbqkbnr/pppppppp/8/8/8/N7/PPPPPPPP/R1BQKBNR b KQkq -": "A00h Durkin Opening / Sodium Attack",
    "rnbqkbnr/pppppppp/8/8/8/2N5/PPPPPPPP/R1BQKBNR b KQkq -": "A00l Van Geet (Dunst) Opening",
    "rnbqkbnr/pppppppp/8/8/8/1P6/P1PPPPPP/RNBQKBNR b KQkq -": "A01 Nimzowitsch-Larsen Attack",
    "rnbqkbnr/pppppppp/8/8/1P6/8/P1PPPPPP/RNBQKBNR b KQkq b3": "A00p Polish Opening / Orangutan",
    "rnbqkbnr/pppppppp/8/8/8/2P5/PP1PPPPP/RNBQKBNR b KQkq -": "A00i Saragossa Opening / Hempel's",
    "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq c3": "A10 English Opening",
    "rnbqkbnr/pppppppp/8/8/8/3P4/PPP1PPPP/RNBQKBNR b KQkq -": "A00j Mieses Opening",
    "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3": "A40a Queen's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/4P3/PPPP1PPP/RNBQKBNR b KQkq -": "A00k Van 't Kruijis Opening",
    "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3": "B00a King's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/5P2/PPPPP1PP/RNBQKBNR b KQkq -": "A00b Barnes Opening / Gedult's",
    "rnbqkbnr/pppppppp/8/8/5P2/8/PPPPP1PP/RNBQKBNR b KQkq f3": "A02 Bird's Opening / Dutch Attack",
    "rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -": "A04 R\u00e9ti Opening",
    "rnbqkbnr/pppppppp/8/8/8/7N/PPPPPPPP/RNBQKB1R b KQkq -": "A00g Amar Opening / Drunken Knights / Ammonia",
    "rnbqkbnr/pppppppp/8/8/8/6P1/PPPPPP1P/RNBQKBNR b KQkq -": "A00t Benko's Opening / Hungarian",
    "rnbqkbnr/pppppppp/8/8/6P1/8/PPPPPP1P/RNBQKBNR b KQkq g3": "A00n Grob's Attack",
    "rnbqkbnr/pppppppp/8/8/8/7P/PPPPPPP1/RNBQKBNR b KQkq -": "A00d Clemenz Opening",
    "rnbqkbnr/pppppppp/8/8/7P/8/PPPPPPP1/RNBQKBNR b KQkq h3": "A00c Desprez Opening / Reagen's Attack",

    // A few common 2nd level responses - not comprehensive! Keep this short.
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6": "B20 Sicilian Defense",
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq -": "B27a Sicilian Defense Main Line",
    "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6": "C20 Open Game / Mutual King's Pawn",
    "rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq d6": "B01a Scandinavian Centre Counter Game",
    "r1bqkbnr/pppppppp/2n5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B00l Nimzowitsch Defense",
    "rnbqkb1r/pppppppp/5n2/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B02a Alekhine Defense",
    "rnbqkbnr/pp1ppppp/2p5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B10a Caro-Kann Defense"

    // TODO: Ajax to load scid.eco from a server optionally, to get deeper into the
    // openings. scid.eco has 20K+ lines, not practical to load into this file.
};


// TODO: library of interesting games, in PGN format. See
// http://www.xs4all.nl/~timkr/records/records.htm and http://www.xs4all.nl/~timkr/ChessTutor/pgnview.htm


/* Global functions for jslint to recognize. TODO: move to objects? */

/*global edit_pgn restore_edit save_pgn reload_pgn load_pgn parse_pgn output_pgn_dict load_ply set_next_back_accesskeys move_link decode_ply encode_ply mv should_promote promote in_check calculate_notations disambiguate_notations calculate_moves computer_move_if_applicable would_check piece_moved unfiltered_moves filtered_moves relative_decode_direction parse_flags nested_flags decode_relative_raw_move decode_one_parlett without_dupes opposite_color set_turn set_check_message check_repetition load_notations capture_piece notation_from_piece_square forwards_vector move_piece_to_square mark_repeated_moves move_dropped_piece save_fen load_fen clear_board load_starting_position init_board name_pieces algebraic_letter piece_letter2name full_piece_prefix algebraic_piece_prefix figurine_piece_prefix pc_or_offboard pc image_path_for create_piece create_piece_by_letter highlight_moves unhighlight_all filerank2xy xy2filerank xy2descriptive xy2adescriptive short_descriptive sq randint ucfirst AssertException assert enable_document_selection make_move_by_menu populate_make_a_move_list make_vboard realize_vboard*/
 
google.setOnLoadCallback(function() {
// http://o.aolcdn.com/dojo/1.0.0/dojo/cookie.xd.js
// This file is small enough to just include here (without the module provisions)
dojo.cookie=function(_2,_3,_4){var c=document.cookie;if(arguments.length==1){var _6=c.lastIndexOf(_2+"=");if(_6==-1){return null;}var _7=_6+_2.length+1;var _8=c.indexOf(";",_6+_2.length+1);if(_8==-1){_8=c.length;}return decodeURIComponent(c.substring(_7,_8));}else{_4=_4||{};_3=encodeURIComponent(_3);if(typeof (_4.expires)=="number"){var d=new Date();d.setTime(d.getTime()+(_4.expires*24*60*60*1000));_4.expires=d;}document.cookie=_2+"="+_3+(_4.expires?"; expires="+_4.expires.toUTCString():"")+(_4.path?"; path="+_4.path:"")+(_4.domain?"; domain="+_4.domain:"")+(_4.secure?"; secure":"");return null;}}


    /* Safari and IE7: Disable text selection to stop interfering with dragging */
    enable_document_selection(false);    
    init_board();
    load_notations();

    var fen = dojo.cookie("board");
    if (!fen) {
        fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; // standard
    }

    load_fen(fen);

    // test 50 move rule (game from http://www.chessville.com/misc/History/Mad_Aussie_Trivia_Archive_12.htm)
    //load_pgn('[White "Filipowicz,A"]\n[Black "Smederevac,P"]\n[Site "Rubinstein mem 04th Polanica Zdroj (14)"]\n[Date "1966"]\n\n1. e4 e6 2. d3 Ne7 3. g3 c5 4. Bg2 Nbc6 5. Be3 b6 6. Ne2 d5 7. 0-0 d4 8. Bc1 g6 9. Nd2 Bg7 10. f4 f5 11. a3 0-0 12. e5 a5 13. a4 Ba6 14. b3 Rb8 15. Nc4 Qc7 16. Kh1 Nd5 17. Bd2 Rfd8 18. Ng1 Bf8 19. Nf3 Be7 20. h4 h5 21. Qe2 Ncb4 22. Rfc1 Bb7 23. Kh2 Bc6 24. Na3 Ra8 25. Qe1 Rdb8 26. Qg1 Qb7 27. Qf1 Kg7 28. Qh1 Qd7 29. Ne1 Ra7 30. Nf3 Rba8 31. Ne1 Bd8 32. Nf3 Rb8 33. Ne1 Bc7 34. Nf3 Rh8 35. Ng5 Bd8 36. Nf3 Be7 37. Qg1 Bb7 38. Nb5 Raa8 39. Na3 Ba6 40. Qf1 Rab8 41. Nc4 Bd8 42. Qd1 Ne7 43. Nd6 Bc7 44. Qe2 Ng8 45. Ng5 Nh6 46. Bf3 Bd8 47. Nh3 Ng4+ 48. Kg1 Be7 49. Nc4 Nd5 50. Nf2 Bb7 51. Nh3 Bc6 52. Qg2 Rhc8 53. Re1 Rc7 54. Re2 Ra7 55. Ree1 Ra6 56. Re2 Rba8 57. Ree1 R8a7 58. Na3 Ra8 59. Nc4 Nh6 60. Na3 Nf7 61. Nf2 Rd8');

    // test PGN embedded notes
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 {This opening is called the Ruy Lopez.} 3... a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    

     /* Note: chessos generates PGNs with minimal algebraic notation, sometimes, 
      * not always standard algebraic. 4. ... Bb4 should be Bxb4. Need synonym 
      * support in order to read this, or MAN support. 
      *
pgn = load_pgn(
"[Event \"ChesSOS Game\"]\n" + 
"[Site \"http://www.chessos.com\"]\n" + 
"[Date \"2009.03.18\"]\n" + 
"[Round \"-\"]\n" + 
"[White \"Dema9o9ue\"]\n" + 
"[Black \"shellreef\"]\n" + 
"[WhiteElo \"1500\"]\n" + 
"[BlackElo \"1500\"]\n" + 
"[Result \"0-1\"]\n" + 
"[URL \"http://www.chessos.com/p/?m=board" + AMP + "g=15722\"]\n" + 
"\n" + 
"1. b4 e5 2. Nc3 Bb4 3. a3 Bc3 4. dxc3 Nf6 5. h3 O-O 6. f3 d5 \n" + 
"7. e3 Nc6 8. a4 Qd6 9. Ba3 Qd8 10. g4 g5 11. h4 gxh4 12. Rh4 \n" + 
"Ne4 13. fxe4 Qh4 14. Ke2 Bg4 15. Nf3 Qh2 16. Kd3 dxe4 17. Ke4 \n" + 
"f5 18. Kd5 Rad8 19. Ke6 Qh6 \n" + 
"0-1");*/

     /* TODO: support 1.move in addition to 1. move  */
     /* TODO: support [White "Foo"][Black "Bar"], without newlines. Ignore whitespace. */
     /*
     pgn = load_pgn("[Event \"Berlin\"]\n" + 
"[Site \"?\"]\n" + 
"[Date \"1842\"]\n" + 
"[Round \"?\"]\n" + 
"[White \"Hanstein\"]\n" + 
"[Black \"Von der Lasa\"]\n" + 
"[Result \"1-0\"]\n" + 
"\n" + 
"1.e4 e5 2.f4 exf4 3.Nf3 g5 4.Bc4 Bg7 5.d4 d6 6.O-O h6 7.c3 Ne7 8.h4 Ng6\n" + 
"9.h5 Ne7 10.g3 fxg3 11.Nxg5 hxg5 12.Bxf7+ Kd7 13.Bxg5 c6 14.e5 d5\n" + 
"15.e6+ Kc7 16.Bf4+ Kb6 17.Qb3+ Ka6 18.Qa3+ Kb6 19.b4 a5 20.Bxb8 Nf5\n" + 
"21.Rxf5 Qh4 22.Qb2 Rxb8 23.b5 Qe4 24.Na3 Qxf5 25.bxc6+ Kc7 26.Nb5+\n" + 
"Kxc6 27.Na7+ Kc7 28.Nb5+ Kd8 29.Rf1 Qh3 30.e7+ Kxe7 31.Qa3+ Kd8\n" + 
"32.Qd6+ Qd7 33.Qb6+ Ke7 34.Re1+ Kxf7 35.Qg6+ Kg8 36.Re8+ Qxe8\n" + 
"37.Qxe8+ Kh7 38.Qg6+ Kg8 39.Qd6 Ra8 40.Qxd5+ Kh7 41.Qe4+ Kg8\n" + 
"42.Qe8+ Kh7 43.Qg6+ Kg8 44.Nc7 Ra6 45.Nxa6 bxa6 46.h6 Rxh6 47.Qe8+\n" + 
"Bf8 48.Qxc8 Kf7 49.Kg2 Bd6 50.Qb7+ Ke8 51.Qc6+ Kf8 52.c4 Rf6 53.c5\n" + 
"Rf2+ 54.Kg1 Bf4 55.Qf6+ Ke8 56.d5 Kd7 57.Qf7+ Kc8 58.Qe8+ Kc7\n" + 
"59.Qe7+ Kb8 60.c6 1-0");*/


});

// PGN (PORTABLE GAME NOTATION) FUNCTIONS

// Load the chess notations into the input/output notation select boxes
function load_notations()
{
    var menu = $("output_notation");

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var name = AVAILABLE_NOTATIONS[notation];

            menu.appendChild(Builder.node("option", {value: notation}, name));
        }
    }

    menu.selectedIndex = 0;
}

// Make the PGN content editable (not to be confused with edible).
var ORIGINAL_UI_HTML;
function edit_pgn()
{
    ORIGINAL_UI_HTML = $("game_ui").innerHTML;

    // TODO: build dynamically using Builder.node, but it gives me a 
    // builder.js this.NODEMAP undefined error.
    $("game_ui").innerHTML = "<textarea id='edited_pgn' name='edited_pgn' cols='80' rows='35'>" + save_pgn().escapeHTML() + 
        "<\/textarea>" + 
        "<button type='button' name='ok' accesskey='o' " + 
        "onclick='javascript:reload_pgn()'>OK<\/button>" +
        "<button type='button' name='cancel' onclick='restore_edit()' accesskey='x'>Cancel<\/button>";

    $("edited_pgn").focus();
}

// Restore the game interface, removing the edit area.
function restore_edit()
{
    $("game_ui").innerHTML = ORIGINAL_UI_HTML;
}

// Export game as PGN.
function save_pgn()
{
    var pgn = "", dict;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
   
    dict = {};
    for (var i = 0; i < tags.length; i += 1) {
        // jslint thinks this is unused, wonder why
        var tag = tags[i];

        dict[tag] = $("PGN_" + tag).innerHTML;
    }

    // Non-standard. The standard tags are FEN and SetUp, for starting position only.
    dict.CurrentFEN = active_fen();

    pgn = output_pgn_dict(dict);

    // TODO: save moves!
    pgn += "\n";
    
    return pgn;
}

// Reload PGN after editing it.
function reload_pgn()
{
    var pgn = $F("edited_pgn");

    restore_edit();

    load_pgn(pgn);
}

// TODO: support any base 10 number, and asterisks for filling remainder of rank with empty
// spaces, and {} for labels, see http://play.chessvariants.org/pbm/devguide.html
function load_pgn(pgn)
{
    var game = parse_pgn(pgn);
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
    var time_started = new Date().getTime();

    // Header
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var node = $("PGN_" + tag);

        assert(node, "load_pgn(" + pgn + "): no element for tag " + tag);

        if (game[tag] && game[tag].substr(0, 1) !== "?") {
            var value = game[tag];

            node.show();

            node.innerHTML = value;

            $$(".show_" + tag).invoke("show");
        } else {
            node.hide();
            $$(".show_" + tag).invoke("hide");
        }
    }

    // Starting position
    load_fen(game.FEN);
    GAME_STATE.position_after[0] = game.FEN;

    for (var ply = 1; ply < game.moves.length; ply += 1) {
        var move = game.moves[ply];

        //console.log(ply, move);
        mv(move, true);
    }
    realize_vboard();

    var time_took = new Date().getTime() - time_started;
    if (window.console) {
        alert("load_pgn took " + time_took + " ms");
    }
}

// Parse PGN into a dictionary
function parse_pgn(pgn)
{
    var lines = pgn.split("\n");
    var dict = {};
    var move_text = "";

    // Parse header into dictionary
    for (var i = 0; i < lines.length; i += 1) {
        var line = lines[i];

        if (line.substr(0, 1) === "[") {
            for (var j = 0; j < line.length; j += 1) {
                var between, ary, tag, key, value;
                    
                between = line.substring(1, line.length - 1);
                // Would have liked to use the 2nd parameter to split here, but it
                // doesn't behave the same as in Perl. It just truncates the array,
                // instead of stopping splitting after the deliminator.
                // "foo,bar,baz".split(",", 2) === ["foo", "bar"]
                // instead of ["foo", "bar,baz"].
                ary = between.split(" ");
                key = ary.shift();
                value = ary.join(" ");

                if (value.substr(0, 1) === '"') {
                    value = value.substring(1, value.length - 1);
                }

                dict[key] = value;
            }
        } else if (line.substr(0, 1) === ";" || line.length === 0) {
            // Comment
        } else {
            move_text += line + " ";
        }
    }

    // Standard FEN
    if (!dict.FEN) {
        dict.FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        dict.SetUp = 1;
    }

    // Parse move text
    var tokens = move_text.split(" ");
    var fullmove_number, outcome, moves = [], color = "white";
    var in_comment = false;

    for (i = 0; i < tokens.length; i += 1) {
        var token = tokens[i];

        if (token === "") {
            // Skip
        } else if (in_comment) {
            if (token.substr(token.length - 1) === "}") {
                in_comment = false;
            }
            // TODO: support annotations
        } else if (token.substring(token.length - 1) === ".") {
            fullmove_number = parseInt(token, 10);

            // 3... means black moves
            if (token.substring(token.length - 3) === "...") {
                color = "black";
            } else {
                color = "white";
            }

        } else if (token === "1-0") {
            outcome = "White wins";
        } else if (token === "0-1") {
            outcome = "Black wins";
        } else if (token === "1/2-1/2") {
            outcome = "Draw";
        } else if (token === "*") { 
            outcome = "(In progress)";
        } else if (token.substr(0, 1) === "{") {
            in_comment = true;
        } else {
            // Move 
            
            var ply = encode_ply(color, fullmove_number);
            // TODO: handle #, + for checkmate and check, part of move
            moves[ply] = token;

            // white, then black
            if (color === "white") {
                color = opposite_color(color);
            } 
        }
    }

    dict.outcome = outcome;
    dict.moves = moves;

    // TODO: parse more than one game per file, return in array, 
    // then show drop-down list to select game from library.

    //console.log(dict);
    return dict;
}

// Export a PGN tag dictionary to PGN format, opposite of parse_pgn.
function output_pgn_dict(dict)
{
    var pgn, quoted_value;

    pgn = "";
    // TODO: Use a hash table, avoid for..in
    for (var key in dict) {
        if (dict.hasOwnProperty(key)) {
            var value = dict[key];

            // TODO: unparenthetize, uncommaify, etc. .. or just set attributes
            // to exactly what we want in load_pgn(), then fetch it.
            // TODO: rules for quoting values?
            quoted_value = '"' + value + '"';
            pgn += "[" + key + " " + quoted_value + "]\n";
        }
    }

    return pgn;
}


// Load a move by ply. Used to navigate to past moves.
function load_ply(ply)
{
    // TODO: would be tool to be able to also decode
    // color + fullmove number, for ease of human use.
    // Make "1." be ply 1, and "1..." or "1. ..." be ply 2.
    // Maybe make it a user function, go()
    
    $$("a.active_move").invoke("removeClassName", "active_move");

    load_fen(GAME_STATE.position_after[ply], true);

    $("ply_" + ply).addClassName("active_move");

    set_next_back_accesskeys(ply);
}

// Setup accesskeys for next and back given the current ply.
function set_next_back_accesskeys(ply)
{
    dojo.query("a.accessible_move").forEach(function(x) {
            dojo.removeClass(x, "accessible_move");
            x.removeAttribute("accesskey");
        });

    dojo.query("a#ply_" + (ply + 1)).forEach(function(x) {
            x.setAttribute("accesskey", ".");       // ctrl+option+.
            dojo.addClass(x, "accessible_move");
        });
    
    dojo.query("a#ply_" + (ply - 1)).forEach(function(x) {
            x.setAttribute("accesskey", ",");       // ctrl+option+,
            dojo.addClass(x, "accessible_move");
        });
}

// Make a link to a move, click it and it loads the board after it.
function move_link(ply, text)
{
    var extra;

    // ctrl+option+/ (at least on Safari 4) to go to initial position
    if (ply === 0) {
        extra = ' accesskey="/"';
    } else {
        extra = "";
    }

    return '<a' + extra + ' id="ply_' + ply + '" class="active_move" ' +
        'href="javascript:load_ply(' + 
            ply +
        ')">' + text + "<\/a>";
}

// Decode ply number to color and fullmove number.
function decode_ply(ply)
{
    var color, fullmove_number;

    color = (ply % 2 === 1) ? "white" : "black";
    fullmove_number = Math.ceil(ply / 2);

    return {color: color, fullmove_number: fullmove_number};
}

// Encode color and fullmove number back to ply. Ply is useful for 
// arrays of moves, since it is one integer, instead of integer+color.
function encode_ply(color, fullmove_number)
{
    var ply;

    ply = fullmove_number * 2;
    ply -= (color === "white" ? 1 : 0);

    return ply;
}

//// USER FUNCTIONS

// Convenience function to move given algebraic notation, for use within
// JavaScript console (Develop -> Show Error Console in Safari) if you want
// a command-line instead of a GUI. Computer move also uses this function, but it is
// not used for drag-and-drop.
function mv(alg_move, virtual)
{
    var piece_square, piece, square;

    if (!alg_move) {
        assert(VALID_MOVE_NOTATIONS, "mv(" + alg_move + "): called with VALID_MOVE_NOTATINS false");
        return own_properties(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    }

    // Accept digits, but prefer the letter oh.
    alg_move = alg_move.replace("0-0-0", "O-O-O").replace("0-0", "O-O");

    // Check/mate indicators not part of move.
    alg_move = alg_move.replace("+", "").replace("#", "");

    // Promotions, e1=Q, not needed, e1Q is fine
    alg_move = alg_move.replace("=", "")

    // Prefer these move notations, in this order.
    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            if (notation === "descr" || notation === "adesc") {
                alg_move = alg_move.replace(/Kt/g, "N");
            }

            piece_square = VALID_MOVE_NOTATIONS[notation][alg_move];

            if (piece_square) {
                // Found one.
                break;
            }
        }
    }

    // Allow alternate, non-canonical forms. These are overly-descriptive
    // notations for ambiguous move notation formats. For example, in SAN
    // the canonical form of a particularly bad opening move is Nh3, but 
    // it can also be written as N1h3 or Ngh3 or Ng1h3, even though this longer
    // form is only supposed to be used when Nh3 is ambiguous, and it is not
    // standard. But you might see it, so allow it.
    if (!piece_square) {
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                if (notation === "descr" || notation === "adesc") {
                    alg_move = alg_move.replace(/Kt/g, "N");
                }

                piece_square = ALT_MOVE_NOTATIONS[notation][alg_move];

                if (piece_square) {
                    //console.log("Warning: non-canonical move notation: ", notation);
                    break;
                }
            }
        }
    }

    // TODO: Non-ambiguous notations can be parsed directly, without needing to
    // calculate the valid moves. Maybe useful for loading in-progress games? And
    // would have to convert from SAN to non-ambiguous formats. Or just make 
    // calculate_moves() faster.

    assert(piece_square, "mv(" + alg_move + "): illegal move");

    piece = piece_square.piece;
    square = piece_square.square;

    // TODO: do some Effect.Move animation, optionally (make two functions)
    //new Effect.Move(piece, { x: 10, y: 20, mode: 'relative' });
    
    move_piece_to_square(piece, square, false, true, alg_move);
}

//// SPECIAL MOVE FUNCTIONS

// Return whether a piece should be promoted
function should_promote(piece)
{
    var square;

    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    square = piece.square;

    // Is it on the last rank?
    if (GAME_STATE.active_color === "white") {
        return square.y === 8;    // 8th rank
    } else if (GAME_STATE.active_color === "black") {
        return square.y === 1;    // 1st rank
    } else {
        assert(false, "should_promote(" + piece + "): unknown active color");
    }
}

// Return whether the move would cause the piece to promote
function would_promote(piece, move)
{
    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    // Will it be on the last rank?
    if (GAME_STATE.active_color === "white") {
        return move.y === 8;    // 8th rank
    } else if (GAME_STATE.active_color === "black") {
        return move.y === 1;    // 1st rank
    } else {
        assert(false, "would_promote(" + piece + "): unknown active color");
    }
}


// Finish up a promotion move.
function promote(piece, type, notation, is_immediate)
{
    // TODO: Puff out, or fade in from new to old piece. Is there an
    // effect that can fade from one image to another? LikE IE page transitions.
    // http://sachiniscool.blogspot.com/2006/01/implementing-page-transitions-in.html
    // ... except when changing images. Safari has CSS animations.
    // new Effect.Puff(piece);
    // or try CSS transitions, see CSS at the top of this document.
    //piece.style.background = image_path_for(promotes_to, piece.color);
    // or TODO: create another img, same place same time, change opacity to reveal it
    // but this leaves the old image behind..
    piece.src = image_path_for(type, piece.color);
    piece.type = type;

    $("promote_container").hide();

    finish_up_move(notation, is_immediate);
}

// Change a piece to whatever it promotes to.
function ask_to_promote(piece, tieback, is_immediate)
{
    var element, container, choice;

    realize_vboard();

    // Clear previous container
    var container = $("promote_container");

    while(container.firstChild) {
        container.removeChild(container.firstChild);
    }

    // Create clickable promotion pieces
    for (var choice in tieback.choices) {
        if (tieback.choices.hasOwnProperty(choice)) {
            // The move the user selected that will be made
            var real_move = tieback.choices[choice];

            var type = real_move.move.promote_to;
            var notation = real_move.notation;

            //element = create_piece(GAME_STATE.active_color, type);
            element = Builder.node("img", {src:image_path_for(type, piece.color), piece_type:type, notation:notation});
            element.onclick = function() {
                // Finishes up the move
                promote(piece, dojo.attr(this, "piece_type"), dojo.attr(this, "notation"), is_immediate);
            };
            container.appendChild(element);
        }
    }

    container.show();

}

//// VALID MOVE FUNCTIONS
//
// TODO: step through moves, like on http://www.pgnview.com/ (jspgnviewer) as used on http://www.zenpawn.com/chessblog/

// Check if any royal pieces of victim_color are being attacked; that is:
// victim_color's royal pieces could be captured after any of all_moves.
function in_check(victim_color, all_moves)
{
    var royals;
    var attacked = false;
    var virtual = true;

    // Pieces that can't be captured and need to move if attacked
    if (virtual) { 
        royals = [];
        for (var x = 1; x <= FILE_MAX; x += 1) {
            for (var y = 1; y <= RANK_MAX; y += 1) {
                var piece;

                piece = VBOARD[x][y].piece;

                if (piece && PIECE_TYPES[piece.type].royal) {
                    royals.push(piece);
                }
            }
        }
    } else {
        royals = $$("img.royal." + victim_color);
    }

    // Attack the royal pieces?
    for (var filerank in all_moves) {
        if (all_moves.hasOwnProperty(filerank)) {
            var moves = all_moves[filerank];

            moves.each(function(move) {
                royals.each(function(royal) {
                    var square = royal.square;

                    if (move.x === square.x && move.y === square.y) { 
                        // Being attacked!
                        //console.log("CHECKED BY",piece,filerank,xy2filerank(move.x, move.y));
                        attacked = true;
                    }
                });
            });
        }
    }

    return attacked;
}

// Calculate and save the move notations for a move.
// Note: only do this if not hypothetical.
function calculate_notations(color, piece, moves, starting_filerank, ps, square_from)
{
    moves.each(function(move) {
        var square = VBOARD[move.x][move.y];

        // Building blocks
        var dest_filerank = xy2filerank(move.x, move.y);        // e4
        var dest_file = dest_filerank.substr(0, 1);             // e
        var dest_rank = dest_filerank.substr(1, 1);             // 4
        // starting_filerank (passed in as parameter)           // e2
        var starting_file = starting_filerank.substr(0, 1);     // e
        var starting_rank = starting_filerank.substr(1, 1);     // 2
        var descriptive_origin = xy2descriptive(color, filerank2xy(starting_filerank));             // K2
        var adescriptive_origin = xy2adescriptive(color, filerank2xy(starting_filerank));           // e2
        var descriptive_dest = xy2descriptive(color, move);                                         // K4
        var adescriptive_dest = xy2adescriptive(color, move);                                       // e4
        var descriptive_dest_file = descriptive_dest.substr(0, descriptive_dest.length - 1);        // K
        var descriptive_dest_rank = descriptive_dest.substr(descriptive_dest.length - 1);           //  4
        var descriptive_origin_file = descriptive_origin.substr(0, descriptive_origin.length - 1);  // K
        var descriptive_origin_rank = descriptive_dest.substr(descriptive_dest.length - 1);         //  4
        //var adescriptive_dest_file = adescriptive_dest.substr(0, 1);                              // e
        //var adescriptive_dest_rank = adescriptive_dest.substr(1, 1);                              //  4
        var adescriptive_origin_file = adescriptive_origin.substr(0, 1);                            // e
        var adescriptive_origin_rank = adescriptive_dest.substr(1, 1);                              //  4

        var capture_x;                  // x/blank
        var capture_slash;              // slash/blank
        var capture_or_dash;            // x/-
        var captured_letter = "";       // capital letter of piece, P for pawn, etc. or blank
        var captured_colon_letter = ""; // colon if captured, then piece letter if not pawn
        var captured_piece = move.capture; 

        var promote_or_blank = "";      // Q/blank
        var promote_figurine = "";      // ♕/blank
        var promote_iccf = "";          // 1/blank
        var promote_paren = "";         // (Q)/blank

        if (move.promote_to) {
            var promote_piece = {type:move.promote_to};

            promote_or_blank = full_piece_prefix(promote_piece);
            promote_figurine = figurine_piece_prefix(GAME_STATE.active_color, promote_piece);
            promote_iccf = PIECE_TYPES[move.promote_to].iccf_number;
            promote_paren = "(" + promote_or_blank + ")";
        }

        if (captured_piece) {
            capture_x = "x";
            capture_slash = "/";
            capture_or_dash = "x";
            captured_letter = full_piece_prefix(captured_piece);
            captured_colon_letter = ":" + (captured_letter === "P" ? "": captured_letter);
        } else {
            capture_or_dash = "-";
            capture_x = "";
            capture_slash = "";
            captured_letter = "";
            captured_colon_letter = "";
        }


        // Compute notations: SAN, FAN, MAN, LAN, RAN, CRAN and also descriptive.
        // But first check if the move text was overridden in decode_one_parlett(), for the
        // notations where it can be overridden. Not all have special notation for castling.
        if (move.notation_override) {
            // Override notation; used for special moves (castling)
            // Note: not all notations have special notation for castling.
            ps.SAN.push([piece, square, [move.notation_override], move]);
            ps.LAN.push([piece, square, [move.notation_override], move]);
            ps.MAN.push([piece, square, [move.notation_override], move]);
            ps.RAN.push([piece, square, [move.notation_override], move]);
            ps.CRAN.push([piece, square, [move.notation_override], move]);
            ps.descr.push([piece, square, [move.notation_override], move]);
            ps.adesc.push([piece, square, [move.notation_override], move]);
        } else {
            var algs, figurine_prefix, algebraic_prefix, piece_letter, minimal_algs;

            if (capture_x === "x" && piece.type === "pawn") {
                // Pawn captures begin with file of pawn.
                algs = [starting_file + capture_x + dest_filerank]; // ?xd5
            } else {
                algs = [
                    capture_x + dest_filerank,                      // ?f3
                    starting_file + capture_x + dest_filerank,      // ?gf3
                    starting_rank + capture_x + dest_filerank,      // ?1f3
                    starting_filerank + capture_x + dest_filerank   // ?g1f3
                ];
            }

            piece_letter = full_piece_prefix(piece);               // P, N, etc.
            algebraic_prefix = algebraic_piece_prefix(piece);      // blank, N, etc.
            figurine_prefix = figurine_piece_prefix(color, piece); // ♟, ♞, ♙, ♘, etc.

            ps.SAN.push([piece, square, algs.map(function(a) { return algebraic_prefix + a + promote_or_blank; }), move]);  // N??
            ps.FAN.push([piece, square, algs.map(function(a) { return figurine_prefix + a + promote_figurine; }), move]);   // ♘??

            // Minimal notation, supposedly used in Informant
            minimal_algs = [
                algebraic_prefix + dest_filerank + promote_or_blank,                      // ?f3
                algebraic_prefix + starting_file + dest_filerank + promote_or_blank,      // ?gf3
                algebraic_prefix + starting_rank + dest_filerank + promote_or_blank,      // ?1f3
                algebraic_prefix + starting_filerank + dest_filerank + promote_or_blank]; // ?g1f3
            ps.MAN.push([piece, square, minimal_algs, move]);

            ps.LAN.push([piece, square, [algebraic_prefix + starting_filerank + 
                    capture_or_dash + dest_filerank + promote_or_blank], move]);

            // TODO: Find out for sure how promotions are shown in RAN
            ps.RAN.push([piece, square, [algebraic_prefix + starting_filerank + capture_or_dash + 
                captured_letter + dest_filerank + promote_or_blank], move]);

            // Best online documentation I could find on CRAN: 
            //  http://main.uschess.org/forums/viewtopic.php?f=2&t=1428&start=30
            // Always gives origin square filerank, then only non-redundant file/rank of dest square
            // Uses ':' for capture instead of 'x', and piece letter isn't given if pawn
            // Full description will have to wait until I receive the book
            //  http://www.amazon.com/Play-Stronger-Chess-Examining-Chess960/dp/0977452107
            ps.CRAN.push([piece, square, [
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_filerank + promote_or_blank,  // Rd3:d7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_file + promote_or_blank,      // Rd3:7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_rank + promote_or_blank       // Rd3:e
                ], move]);

            // English descriptive notation
            // TODO: 
            // - alt_letter (Kt for knight instead of N) and
            //   alt_descriptive_dest (QKt1 for b1 instead of QN1) - currently, Kt is preprocessed to N in mv()
            //   would be nice to have an option to prefer Kt over N, for using old books (though N/Kt would be synonyms)
            // - allow slashes in addition to parenthesises, or maybe not, since would be shorter and therefore preferred
 
            // Descriptive vs algebraic is like imperial vs. metric units, in some ways. Descriptive
            // is from each player's perspective, so 1. P-K4 P-K4 is easily recognizable as the same
            // move from both players, more readily than 1. e4 e5. And 2. PxP PxP more clearly shows
            // a pawn trade than 10. exd5 cxd5. Smith notation shows the latter, too, but the coordinates
            // are still not symmetric from each player's perspective. I like descriptive. Problem is
            // just that it needs to be disambiguated often, algebraic less so.
            // This paper mentions how a book on openings for black showed all of the diagrams from
            // white's perspective: http://www.castlelong.com/essay/Essay_HSym_fd47b_Doc_Prn.PDF
            // -- it discusses symmetric figurines, interesting. Although it says algebraic is superior.
          
            var piece_name = piece.descriptive_name;
            var short_piece_name = short_descriptive(piece_name);
            var short_descriptive_dest = short_descriptive(descriptive_dest_file) + descriptive_dest_rank;

            var piece_aname = piece.adescriptive_name;

            if (capture_or_dash === "-") { 
                // non-capturing move
                ps.descr.push([piece, square, [
                    piece_letter + capture_or_dash + short_descriptive_dest + promote_paren,        // P-B4
                    piece_name + capture_or_dash + short_descriptive_dest + promote_paren,          // QBP-B4
                    short_piece_name + capture_or_dash + short_descriptive_dest + promote_paren,    // BP-B4
                    piece_letter + capture_or_dash + descriptive_dest + promote_paren,              // P-QB4
                    short_piece_name + capture_or_dash + descriptive_dest + promote_paren,          // BP-QB4
                    piece_name + capture_or_dash + descriptive_dest + promote_paren,                // QBP-QB4

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + descriptive_dest + promote_paren,      // P(K2)-K4
                    piece_letter + "(" + descriptive_origin_rank + ")" + capture_or_dash + descriptive_dest + promote_paren, // P(2)-K4
                    piece_letter + "(" + descriptive_origin_file + ")" + capture_or_dash + descriptive_dest + promote_paren  // P(K)-K4

                // Must uniq() the array, since some of the notations actually appear twice
                // in the list above, and disambiguate_moves() will delete both since it'll think they
                // are ambiguous. This would have occurred when piece_name === short_piece_name, that is,
                // for KP, QP, K, and Q. 
                ].uniq(), move]);


                ps.adesc.push([piece, square, [
                    piece_letter + capture_or_dash + adescriptive_dest + promote_paren,             // P-c4
                    piece_aname + capture_or_dash + adescriptive_dest + promote_paren,              // cP-c4
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + adescriptive_dest + promote_paren,       // P(c2)-c4
                    piece_letter + "(" + adescriptive_origin_rank + ")" + capture_or_dash + adescriptive_dest + promote_paren,  // P(2)-c4
                    piece_letter + "(" + adescriptive_origin_file + ")" + capture_or_dash + adescriptive_dest + promote_paren   // P(c)-c4
                ].uniq(), move]);
            } else if (capture_or_dash === "x") {
                var captured_name = captured_piece.descriptive_name;
                var short_captured_name = short_descriptive(captured_name);
                
                var captured_aname = captured_piece.adescriptive_name;

                // capture
                ps.descr.push([piece, square, [
                    // Note: a permutation function would be handy here
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + short_captured_name + promote_paren,       // PxBP
                    piece_letter + capture_or_dash + captured_name + promote_paren,             // PxQBP
                    short_piece_name + capture_or_dash + captured_letter + promote_paren,       // NPxP
                    short_piece_name + capture_or_dash + short_captured_name + promote_paren,   // NPxBP
                    short_piece_name + capture_or_dash + captured_name + promote_paren,         // NPxQBP
                    piece_name + capture_or_dash + captured_letter + promote_paren,             // QNPxP
                    piece_name + capture_or_dash + short_captured_name + promote_paren,         // QNPxBP
                    piece_name + capture_or_dash + captured_name + promote_paren,               // QNPxQBP

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_name + promote_paren,    // P(K4)xQP
                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren,  // P(K4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren,    // PxP(Q4)
                    piece_name + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren       // KPxP(Q4)
                ].uniq(), move]);

                ps.adesc.push([piece, square, [
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + captured_aname + promote_paren,            // PxcP
                    piece_aname + capture_or_dash + captured_letter + promote_paren,            // bPxP
                    piece_aname + capture_or_dash + captured_aname + promote_paren,             // bPxcP

                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_aname + promote_paren,  // P(b4)xcP
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren, // P(b4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren,   // PxP(c5)
                    piece_aname + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren     // bPxP(c5)
                ].uniq(), move]);
            } else {
                assert(false, "calculate_notations: " + capture_or_dash + " is not - or x");
            }
        }

        // Coordinate notation - least descriptive notation possible, but must include promotion to be non-ambiguous
        ps.coord.push([piece, square, [starting_filerank.toUpperCase() + "-" + dest_filerank.toUpperCase() + promote_paren], move]);

        // ICCF numeric notation
        var starting_xy = filerank2xy(starting_filerank);
        var starting_x = starting_xy[0], starting_y = starting_xy[1];
        ps.ICCF.push([piece, square, [starting_x + "" + starting_y + "" + move.x + "" + move.y + promote_iccf], move]);

        // Smith notation, reversible, non-ambiguous: https://www.chessclub.com/chessviewer/smith.html
        var smith_capture_letter;
        if (move.smith_castle) {
            // c = short castle, C = long castle
            smith_capture_letter = move.smith_castle;
        } else if (move.en_passant_capture) { 
            // E = en passant capture
            smith_capture_letter = "E";
        } else if (move.capture) {
            // pnbrqk = captured respective piece. This is what makes it reversible.
            smith_capture_letter = captured_letter.toLowerCase();
        } else {
            smith_capture_letter = "";
        }
        ps.smith.push([piece, square, [starting_filerank + dest_filerank + smith_capture_letter + promote_or_blank], move]);
        
        // TODO: support promotation in all notations, make separate moves (a8=Q, a8=N, etc.)


    });

    // TODO: check for cross-notation ambiguities. Inputs are tested in the order of
    // AVAILABLE_NOTATIONS, but a notation that matches two different moves in
    // two different notations, if it exists, is sure to cause trouble!
}

// Used for sorting a function by length
function by_length(x, y) 
{ 
    return x.length - y.length; 
}

// Given a list of all valid move notations, remove the ambiguous 
// (Nf3 and Nf3, remove both) overly-disambiguated (Ng1f3 if Ngf3
// or N1f3 is not ambiguous).
function disambiguate_notations(notations)
{
    var freq_count = {};
    var canonical_notations = {};
    var synonymous_notations = {};
    var piece, square, same_moves, abs_move;

    // Count occurrences of each notation text, so know if is ambiguous.
    for (var i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];

        for (var j = 0; j < same_moves.length; j += 1) {
            var move = same_moves[j];

            if (!freq_count[move]) {
                // Store index so can delete if is a dupe
                freq_count[move] = [[i, j]];
            } else {
                freq_count[move].push([i, j]);
            }
        }
    }

    // Delete ambiguous moves (or actually, replace with 'undefined')
    for (notation in freq_count) {
        if (freq_count.hasOwnProperty(notation)) {
            var locations = freq_count[notation];

            if (locations.length > 1) {
                for (var k = 0; k < locations.length; k += 1) { 
                    var i = locations[k][0], j = locations[k][1];
                    delete notations[i][2][j];
                }
            }
        }
    }

    // Find shortest notation text
    for (i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];
        var shortest, synonyms;

        // Remove undefined elements
        same_moves = same_moves.compact();
       
        // Choose shortest (now unambiguous) notation
        // Could also do: min_length = same_moves.pluck("length").min();, then partition
        // Rather, sort by length, ascending.
        same_moves.sort(by_length);

        // The shortest, non-ambiguous move is canonical. But also keep the
        // synonymous moves around.
        shortest = same_moves.shift();
        synonyms = same_moves;

        canonical_notations[shortest] = {piece:piece, square:square, move:abs_move};

        for (j = 0; j < synonyms.length; j += 1) {
            synonymous_notations[synonyms[j]] = {piece:piece, square:square, move:abs_move};
        }
    }

    // TODO: also return synonymous_notations, so overly-disambiguated move
    // notations can be used, too, but return them separately so they won't be
    // listed as unique, canonical moves.
    return [canonical_notations, synonymous_notations];
}

// Make the drop targets for all valid moves.
function make_droppables()
{
    for (var starting_filerank in VALID_MOVES) {
        if (VALID_MOVES.hasOwnProperty(starting_filerank)) {
            var moves = VALID_MOVES[starting_filerank];

            var real_piece = pc(starting_filerank);

            // Create drop targets for the valid destinations, linking
            // the draggables to droppables using piece- + source square.
            real_piece.addClassName("piece-" + starting_filerank);
            real_piece.prior_position = starting_filerank;    // for removal

            // TODO: droppable on original square, if dropped there, then retain
            // move highlighting, but allow clicking/tapping to move to destination.
            /*
            Droppables.add(square_from, {
                accept: "piece-" + starting_filerank,
                onDrop: function() { alert(1); },
                // No hoverclass
                });
            ALL_DROP_TARGETS.push(square_from);
            */
           
            moves.each(function(move) {
                    var square = SQUARES[move.x][move.y];

                    // For removal
                    ALL_DROP_TARGETS.push(square);

                    // You can drop here
                    Droppables.add(square, {
                        accept: "piece-" + starting_filerank,
                        onDrop: move_dropped_piece,
                        hoverclass: 'hover'});
                });
        }
    }
}


// After the board changes and it is the next person's turn, calculate 
// what the next possible allowable moves are, and update the globals with this information.
//
// If is_hypothetical, do not update globals, and allow "moves" that put in
// check (useful for attacks, see is_hypothetical elsewhere).
//
// This operates on VBOARD only, for speed. Use make_vboard() before if needed.
// Call make_droppables() after if UI drag-and-drop is desirable.
function calculate_moves(color, is_hypothetical)
{
    var valid_moves = {};
    var possible_notations, notation;

    if (!is_hypothetical) { 
        // Values are [ [ [piece, square ], [possible move names] ], ... ]
        // Instead of a hash or assocative array, because I couldn't use
        // [piece, square] as a key, even with Prototype's Hash. Could use
        // http://www.tutorials4html.com/2009/02/06/true-javascript-hash-table/
        // but instead, using an array with linear lookup.
        possible_notations = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                possible_notations[notation] = [];
            }
        }
    }

    // Look at all the active pieces
    for (var x = 1; x <= FILE_MAX; x += 1) {
        for (var y = 1; y <= RANK_MAX; y += 1) {
            var starting_filerank, square_from, moves, piece;

            square_from = VBOARD[x][y];
            piece = square_from.piece;
 
            // Skip blank squares and inactive pieces
            if (!piece || piece.color !== color) {
                continue;
            }

            // Convert xy to filerank notation (a string), so it can be easily used
            // as a hash key, class name for droppables, and also for notations.
            starting_filerank = square_from.filerank;

            moves = filtered_moves(piece, color, is_hypothetical);
            if (!is_hypothetical) {
                // Fills in possible_notations with possibly-ambiguous move notations in each system
                calculate_notations(color, piece, moves, starting_filerank, possible_notations, square_from);
            }

            // Store valid moves for mouseovers etc.
            if (moves.length !== 0) {
                valid_moves[starting_filerank] = moves;
            }

            //console.log(starting_filerank, moves);
        }
    }


    // Gather all the notations, disambiguate and apply
    if (!is_hypothetical) {
        var notations = possible_notations;
        VALID_MOVE_NOTATIONS = {};
        ALT_MOVE_NOTATIONS = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                var canonical_and_synonyms;

                canonical_and_synonyms = disambiguate_notations(notations[notation]);
                VALID_MOVE_NOTATIONS[notation] = canonical_and_synonyms[0];
                ALT_MOVE_NOTATIONS[notation] = canonical_and_synonyms[1];
            }
        }

        // For reals.
        VALID_MOVES = valid_moves;
    }
    
    return valid_moves;
}

// Get the number of properties an object has on its own.
// Conceptually, the "size" of an "associative array"
function own_property_count(obj)
{
    var count = 0;

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            count += 1;
        }
    }

    return count;
}

// Get the properties of an object as an array
function own_properties(obj)
{
    var props = [];

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            props.push(prop);
        }
    }

    return props;
}



// Populate the menu of valid moves, where you can make a move
// by selection instead of moving a piece with your mouse.
function populate_make_a_move_list()
{
    var active_name = AVAILABLE_NOTATIONS[PREFS.input_notation];
    var move_group, change_group, count, menu;

    menu = $("make_move_menu");
    menu.innerHTML = "";

    count = own_property_count(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    if (count === 0) {
        menu.appendChild(Builder.node("option", {value:""}, "No legal moves"));
        return;
    }

    menu.appendChild(Builder.node("option", {value:""}, "Make a move... (" + count + ")"));
   
    // Moves in active input notation.
    move_group = Builder.node("optgroup", {label:active_name});
    menu.appendChild(move_group);

    for (var notation in VALID_MOVE_NOTATIONS[PREFS.input_notation]) {
        if (VALID_MOVE_NOTATIONS[PREFS.input_notation].hasOwnProperty(notation)) {
            move_group.appendChild(Builder.node("option", {value: notation}, notation));
        }
    }

    // Change the input notation.
    change_group = Builder.node("optgroup", {label:"Other notation..."});
    menu.appendChild(change_group);

    for (var n in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(n) && n !== PREFS.input_notation) {
            var name = AVAILABLE_NOTATIONS[n];
            change_group.appendChild(Builder.node("option", {value: "change_" + n}, name));
        }
    }

    menu.selectedIndex = 0;
}

// Called when the make a move menu is changed, either to change the
// input notation or actually make a move by the menu.
function make_move_by_menu(menu)
{
    var choice = $F("make_move_menu");

    // Notation change
    if (choice.indexOf("change_") === 0) {
        var new_notation = choice.substring("change_".length);
   
        PREFS.input_notation = new_notation;
        populate_make_a_move_list();
        return;
    }

    mv(choice);
}

// AI - artificial intelligence 
// Do this after a delay, so that when playing computer vs. computer, you can
// see the move, since they are not animated (Effect.Move) yet.
function computer_move_if_applicable(clicked)
{
    if (clicked) {
        if ($F("black_computer") || $F("white_computer")) {
            $("skill_level").value = PREFS.skill;
            $("show_skill").show();
        } else {
            $("show_skill").hide();
        }
    }

    if (!$F(GAME_STATE.active_color + "_computer")) {
        return;
    }

    // TODO: better variables
    if ($("check").innerHTML.indexOf("Checkmate") !== -1 ||
        $("check").innerHTML.indexOf("Draw") !== -1) {
        // Game is completed, don't bug the computer
        return;
    }

    if (PREFS.skill === 0) {
        setTimeout(random_move, 1);
    } else {
        schedule_engine_move(PREFS.skill);
    }
}

// Update the skill level when the user changes the form field.
function update_skill(element)
{
    var skill = parseInt(element.value, 10);

    if (skill < 0) {
        skill = 0;
    }  else if (skill > 100) {
        skill = 100;
    }

    element.value = skill;

    PREFS.skill = skill;
}

// Make a random move with equal probability. No intelligence.
function random_move()
{
    // simply choose a random move
    var keys = own_properties(VALID_MOVE_NOTATIONS.SAN);
    var alg_move = keys[randint(0, keys.length - 1)];
    //var alg_move = keys[0];

    //var piece_square = VALID_MOVE_NOTATIONS.SAN[alg_move];

    // TODO: do some animation when moving, Effect.Move, to slow it down so we can see it.
    mv(alg_move);
}

// Ask a chess engine, via Ajax, for its move and the board score.
// TODO: also allow remote human moves, for realtime games?
function schedule_engine_move(skill)
{
    var query;

    // TODO: pass skill, too.
    
    query = "?skill=" + skill + ";fen=" + encodeURIComponent(active_fen());

    dojo.xhrGet({
        url: PREFS.engine + query,
        handleAs: "json",
        load: got_engine_move,
        error: got_engine_error
        });

    set_check_message("Analyzing...");
}

// Callback for when the chess engine Ajax request move is received.
function got_engine_move(response)
{
    if (!response.error) {
        set_check_message("");
        mv(response.next_move);
        // TODO: show a meter for the board position
        $("score").innerHTML = "Score: " + response.score;
    } else {
        // How to explain this? Occurs frequently:
        //
        // Crafty v23.0 (2 cpus)
        //
        // White(1): setboard rn1qkbnr/pp2pppp/2p5/3pPb2/3P4/8/PPP2PPP/RNBQKBNR w KQkq f6 1 4
        // enpassant status is bad (must be on 3rd/6th rank only.
        // bad string = "rn1qkbnr/pp2pppp/2p5/3pPb2/3P4/8/PPP2PPP/RNBQKBNR"
        // Illegal position, using normal initial chess position
        disable_engine("Engine error: " + response.error);
    }
}

// Called when the Ajax request fails
function got_engine_error(response)
{
    disable_engine("Engine unavailable: " + response);
}

// Disable the external chess engine usage and make a random move in its place.
function disable_engine(why)
{
    $("engine_status").innerHTML = why;
    PREFS.skill = 0;
    $("skill_level").value = PREFS.skill;
    $("skill_level").title = "Reset because of: " + why;

    // It'll have to do
    random_move();
}

// Make a move in the VBOARD, which can be undone. Only makes the move.
function do_virtual_move(piece, move)
{
    var captured, from_square, to_square, capture_square, piece_moved_over;
 
    from_square = piece.square;
    to_square = VBOARD[move.x][move.y];
  
    // Special case: en passant captures to an empty square
    if (GAME_STATE.ep_target &&
        to_square.x === GAME_STATE.ep_target[0] && 
        to_square.y === GAME_STATE.ep_target[1]) {

        // TODO: use move instead of comparing location to find if ep

        var forward = forwards_vector(GAME_STATE.active_color);

        capture_square = VBOARD[to_square.x][to_square.y - forward];
    } else {
        capture_square = to_square;
    }

    // The piece that was captured, not always where the piece moved to.
    captured = capture_square.piece;

    // Piece that was on destination square, if any. For restoring old piece.
    piece_moved_over = to_square.piece;

    if (captured) { 
        VBOARD[capture_square.x][capture_square.y].piece = null;
        captured.square = null;
    }

    piece.square = VBOARD[move.x][move.y];
    VBOARD[move.x][move.y].piece = piece;
    VBOARD[from_square.x][from_square.y].piece = null;

    return {captured: captured, capture_square: capture_square, 
        from_square: from_square, piece: piece, move: move, to_square: to_square,
        piece_moved_over: piece_moved_over};
}

// Undo a move given the result of do_virtual_move().
function undo_virtual_move(did)
{
    // Restore captured piece
    if (did.captured) {
        did.captured.square = VBOARD[did.capture_square.x][did.capture_square.y];
        did.captured.square.piece = did.captured;
    }

    // Piece that was clobbered by the move
    VBOARD[did.move.x][did.move.y].piece = did.piece_moved_over;

    // Move piece back
    did.piece.square = VBOARD[did.from_square.x][did.from_square.y];
    VBOARD[did.from_square.x][did.from_square.y].piece = did.piece;
}


// Return whether moving piece to move would mean that
// color is in check. Note, that doesn't mean that the move
// *caused* the check, they could have already been in check and
// this move didn't take them out. Either way, its illegal.
function would_check(piece, move, color)
{
    var from_square = piece.square;
    var to_square = VBOARD[move.x][move.y];
    var checked, all_moves, did;


    // Hypothetical move, with possible capture
    did = do_virtual_move(piece, move);

    // TODO: This is a lot of calculation to do, see if can speed it up
    all_moves = calculate_moves(opposite_color(color), true);
    checked = in_check(color, all_moves);

    // Restore move
    undo_virtual_move(did); 

    return checked;
}

// Return whether a pawn has moved from its initial position. Unfortunately,
// the starting ranks of black and white pawns are hardcoded, so that games
// in-progress can be loaded and pawns that have moved, but we haven't seen move,
// are recognized as in fact having moved. Other games with pawns in ranks other
// than 2nd and 7th (Chinese Chess, etc.) will need to have this modified.
// TODO: store initial rank in piece information
function piece_moved(piece)
{
    // Bit of a hack, but castling privileges take care of this.
    if (piece.type === "king") {
        return false;
    }

    // TODO: don't hardcode! Give rank in piece type, mirror black/white.
    //assert(piece.type === "pawn" || piece.type === "berolina_pawn" || piece.type === "pawnattackrook", "piece_moved(" + piece + "): can only tell if pawns moved, not " + piece.type);

    var square = piece.square;

    if (piece.color === "white") {
        return square.y !== 2;    // 2nd rank
    } else if (piece.color === "black") {
        return square.y !== 7;    // 7th rank
    } else {
        assert("piece_moved(" + piece + "): neither white nor black");
    }
}

//// PARLETT NOTATION FUNCTIONS

// Get the unfiltered, relative moves for a Parlett string.
// Warning: do not modify the moves! Otherwise other moves will get confused.
var PARLETT_CACHE = {};
function unfiltered_moves(parlett)
{
    var choice_groups, rel_moves;

    // Cache for a performance improvement, since Parlett is constant per move.
    if (PARLETT_CACHE[parlett]) {
        //return deep_copy(PARLETT_CACHE[parlett]);
        //return PARLETT_CACHE[parlett].evalJSON();
        return PARLETT_CACHE[parlett];
    }

    // Get all the unfiltered moves for the mutually exclusive choices
    choice_groups = parlett.split(", ");

    rel_moves = [];
    for (var i = 0; i < choice_groups.length; i += 1) {
        // For each group, gather the move options. 
        // (Would be nice if JavaScript arrays had a Python-like .extend)
        rel_moves.push.apply(rel_moves, decode_one_parlett(choice_groups[i]));
    }   
    rel_moves = without_dupes(rel_moves);

    PARLETT_CACHE[parlett] = rel_moves;
    //PARLETT_CACHE[parlett] = Object.toJSON(rel_moves);

    return rel_moves;
}

// Get the legal moves for a piece.
function filtered_moves(piece, color, is_hypothetical)
{
    var parlett, rel_moves, moves, start, blocked;
    var start_x, start_y, piece_info;

    start = piece.square;
    if (!start) {
        return [];
    }

    start_x = start.x;
    start_y = start.y;

    piece_info = PIECE_TYPES[piece.type];
    parlett = piece_info.parlett;

    rel_moves = unfiltered_moves(parlett);

    // Absolutize and find what is allowed
    moves = [];
    blocked = {};
    for (var i = 0; i < rel_moves.length; i += 1) {
        var rel_x, rel_y, flags, abs_move, x, y;
       
        rel_x = rel_moves[i][0];
        rel_y = rel_moves[i][1]; 
        flags = rel_moves[i][2];

        // Local copies of relative coords, so don't modify original.
        var if_unblocked_dx = flags.if_unblocked_dx, if_unblocked_dy = flags.if_unblocked_dy;
        var if_unblocked2_dx = flags.if_unblocked2_dx, if_unblocked2_dy = flags.if_unblocked2_dy;
        var if_unblocked3_dx = flags.if_unblocked3_dx, if_unblocked3_dy = flags.if_unblocked3_dy;
        //var capture_at_dx = flags.capture_at_dx, capture_at_dy = flags.capture_at_dy;
        var mark_ep_target_dx = flags.mark_ep_target_dx, mark_ep_target_dy = flags.mark_ep_target_dy;

        // Positive is forwards, so mirror for black.
        if (color === "black") {
            rel_y = -rel_y;
            // Reverse any embedded relative coordinates.
            if (if_unblocked_dy) { if_unblocked_dy = -if_unblocked_dy; }
            if (if_unblocked2_dy) { if_unblocked2_dy = -if_unblocked2_dy; }
            if (if_unblocked3_dy) { if_unblocked3_dy = -if_unblocked3_dy; }
            //if (capture_at_dy) { capture_at_dy = -capture_at_dy; }
            if (mark_ep_target_dy) { mark_ep_target_dy = -mark_ep_target_dy; }
        }

        x = rel_x + start_x;
        y = rel_y + start_y;

        abs_move = {x: x, y: y};

        if (x < 1 || y < 1 || x > FILE_MAX || y > RANK_MAX) {
            // Out of bounds
            continue;
        }

        var dest_square = VBOARD[x][y];
        var capture_piece = dest_square.piece;

        // If there is any piece there, it may block other moves
        if (capture_piece) {
            blocked[rel_x + "," + rel_y] = true;

            if (flags.if_blocked_skip) {
                i += flags.if_blocked_skip;
            }

            // Can't move to self-occupied square
            if (capture_piece.color === color) {
                continue;
            }

            // For move notations
            abs_move.capture = capture_piece;
        } 

        // Must be a capture
        if (flags.capture_only && !capture_piece) {
            continue;
        }

        // Must not be capture
        if (flags.no_capture && capture_piece) {
            continue;
        }

        // TODO: Does piece_moved() need to be virtualized?
        if (flags.initial_only && piece_moved(piece)) {
            continue;
        }

        // Blocked by an obstruction. Can check for up to three spaces. To check
        // more, chain the moves. 
        var key;
        if (if_unblocked_dy !== undefined) {
            key = if_unblocked_dx + "," + if_unblocked_dy;

            // If was either blocked by a previous move (faster), or there is a
            // piece there but it wasn't a valid move. For example, elephant (2X)
            // can be blocked, since it is not a leaper (sticking the elephant's eye),
            // non-hippogonal rider.
            if (blocked[key] || pc_or_offboard(if_unblocked_dx + start_x, if_unblocked_dy + start_y, true)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }
        if (if_unblocked2_dy !== undefined) {
            key = if_unblocked2_dx + "," + if_unblocked2_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked2_dx + start_x, if_unblocked2_dy + start_y, true)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }
        if (if_unblocked3_dy !== undefined) {
            key = if_unblocked3_dx + "," + if_unblocked3_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked3_dx + start_x, if_unblocked3_dy + start_y, true)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }


        // Map pawn moves to what the en passant target will be if
        // the pawn moves there.

        if (!is_hypothetical) {
           if (mark_ep_target_dx !== undefined) {
                abs_move.create_ep_target = [
                    mark_ep_target_dx + start_x, 
                    mark_ep_target_dy + start_y];
            }

        }

        // Only valid if this move is to an ep target.
        if (flags.if_ep_target) {
            if (!GAME_STATE.ep_target || GAME_STATE.ep_target[0] !== x ||
                GAME_STATE.ep_target[1] !== y)  {
                continue;
            }

            // For move notations, informational purposes, only.
            abs_move.en_passant_capture = true;
        }

        // Castling moves
        if (flags.if_can_castle_short) {
            // Moved and lost castling privileges
            if (!GAME_STATE.can_castle[color].cshort) {
                continue;
            }

            // Can't castle if in check
            if (GAME_STATE.active_in_check) {
                continue;
            }

            // Can't castle through check. Ugly hardcoded, check if
            // if a valid regular move (which must have been listed before
            // the castling move in Parlett).
            var found = false;
            for (var j = 0; j < moves.length; j += 1) {
                if (moves[j].x === 6 && moves[j].y === (color === "white" ? 1 : 8)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                continue;
            }

            // TODO: check if unimpeded here? instead of if_unblockedX in Parlett

            abs_move.notation_override = "O-O";
        }

        if (flags.if_can_castle_long) {
            if (!GAME_STATE.can_castle[color].clong) {
                continue;
            }
            if (GAME_STATE.active_in_check) {
                continue;
            }

            // Another ugly hardcoded "can't castle through check"
            found = false;
            for (j = 0; j < moves.length; j += 1) {
                if (moves[j].x === 4) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                continue;
            }


            abs_move.notation_override = "O-O-O";
        }

        // Capture at relative location, instead of at destination square.
        // Not actually implemented. En passant capture location is hardcoded.
        /*
        if (capture_at_dx !== undefined) {
           var cx = capture_at_dx + start_x, cy = capture_at_dy + start_y;

           if (cx < 1 || cy < 1 || cx > RANK_MAX || cy > FILE_MAX) {
               continue;
           }

           var capture = VBOARD[cx][cy].piece;
           console.log("C",xy2filerank([cx,cy]));
           if (capture) {
               abs_move.capture = capture;
           } else {
               // Nothing there to capture.
               continue;
           }
        }*/

        if (piece_info.castles_with) {
            // If this piece castles with another piece, moving it clears that ability.
            abs_move.clear_castle_short = true;
            abs_move.clear_castle_long = true;
        }

        // TODO: faster check checking? maybe split into:
        // 1. if not in check, can't move into
        //   a. can't move a pinned piece that would cause check, unblocks attack
        //   b. can't move royal piece into attacked square
        // 2. if in check, must move out of
        //   a. move royal piece (if double check, only can move)
        //   b. capture with another piece
        //   c. block with another piece
        if (!is_hypothetical && would_check(piece, abs_move, color)) { 
            continue; 
        }

        if (would_promote(piece, abs_move)) {
            // Expand promotions; make a move for each piece you can promote to
            for (var j = 0; j < piece_info.promote.length; j += 1) {
                var prom_move = {promote_to: piece_info.promote[j]};

                Object.extend(prom_move, abs_move);
               
                moves.push(prom_move);
            }
        } else {
            // Just one move
            moves.push(abs_move);
        }
    }

    return moves;
}

// Return an array of [direction vectors, ch2 consumed]. The vectors
// are positive for forward, negative for backwards.
function relative_decode_direction(ch, ch2)
{
    if (ch === "+") { 
        // orthogonally four possible directions
        return [[[1, 0], [0, 1], [-1, 0], [0, -1]], false];
    } else if (ch === "=") {
        // orthogonally sideways
        return [[[1, 0], [-1, 0]], false];
    } else if (ch === ">") {
        if (ch2 === "=") {
            // >= orthogonally forwards or sideways
            return [relative_decode_direction(">", undefined)[0].concat(relative_decode_direction("=", undefined)[0]), true];
        } else if (ch2 === ">") {
            // >> right (Extended Parlett)
            return [[[1, 0]], true];
        } else {
            // = orthogonally forward
            return [[[0, 1]], false];
        }
    } else if (ch === "<") {
        if (ch2 === ">") {
            // <> orthogonally forwards and backwards
            return [[[0, 1], [0, -1]], true];
        } else if (ch2 === "=") {
            // <= orthogonally backwards or sideways
            return [relative_decode_direction("<", undefined)[0].concat(relative_decode_direction("=", undefined)[0]), true];
        } else if (ch2 === "<") {
            // << left (Extended Parlett)
            return [[[-1, 0]], true];
        } else {
            // < orthogonally backwards
            return [[[0, -1]], false];
        }
    } else if (ch === "X") { 
        if (ch2 === ">") {
            // X> diagonally forwards
            return [[[1, 1], [-1, 1]], true];
        } else if (ch2 === "<") {
            // X< diagonally backwards
            return [[[1, -1], [-1, -1]], true];
        } else {
            // X diagonally four possible directions
            return [[[1, 1], [1, -1], [-1, 1], [-1, -1]], false];
        }
    } else if (ch === "*") {    
        // orthogonally or diagonally (eight possible directions)
        return [relative_decode_direction("+", undefined)[0].concat(relative_decode_direction("X", undefined)[0]), false];
    } else {
        assert(false, "relative_decode_direction('" + ch + "', '" + ch2 + "'): invalid direction");
    }
}

function parseInt10(x) 
{ 
    return parseInt(x, 10); 
}

// Parse semicolon separated flags, possibly key/value pairs
// foo;bar sets foo:true and bar:true, can also set relative coordinates:
// if_unblocked=1,2.
function parse_flags(text, flags)
{
    var flags_text;

    if (flags === undefined) {
        flags = {};
    }

    if (Object.isArray(text)) {
        flags_text = text;
    } else {
        flags_text = text.split(";");
    }

    // Semicolon-separated flags
    for (var i = 0; i < flags_text.length; i += 1) {
        var flag_text = flags_text[i];
        var value;
       
        // Allow if_unblocked=0,1, etc.
        if (flag_text.indexOf("=") !== -1) { 
            // Unfortunately, need JavaScript 1.8 to do [x,y] = ...
            var ary = flag_text.split("=");
            var left = ary[0], right = ary[1];
            value = right.split(",");
            value = value.map(parseInt10);
            if (value.length === 1) {
                flags[left] = value[0];
            } else if (value.length === 2) {
                flags[left + "_dx"] = value[0];
                flags[left + "_dy"] = value[1];
            } else {
                assert(false, "parse_flags(" + text + ", " + flags + "): not 1 or 2 elements: " + value);
            }
        } else {
            flags[flag_text] = true;
        }
    }

    return flags;
}

// Decode the Extended Parlett {} construct, which adds flags
// to arbitrary move text. {parlett, flags}
function nested_flags(parlett)
{
    var rel_moves, flags_text, flags;
    
    flags_text = parlett.split(";");
    rel_moves = unfiltered_moves(flags_text.shift());

    flags = parse_flags(flags_text);

    for (var flag in flags) {
        if (flags.hasOwnProperty(flag)) {
            for (var j = 0; j < rel_moves.length; j += 1) {
                rel_moves[j][2][flag] = flags[flag];
            }
        }
    }

    return rel_moves;
}

// Decodes an explicit relative move that was in square brackets: [0,2;initial_only]
function decode_relative_raw_move(text_move, existing_flags)
{
    var xy_text_flags, xy_text, xy, x, y, flags;
    
    xy_text_flags = text_move.split(";");
    xy_text = xy_text_flags.shift();

    if (xy_text.indexOf(",") !== 0) {
        // Relative x,y
        xy = xy_text.split(",");
        x = parseInt(xy[0], 10);
        y = parseInt(xy[1], 10);
    } else {
        // TODO: call decode_one_parlett, to allow
        // [oi2>;flags] or oi[2>;flags], etc.
        assert(false, "decode_relative_raw_move(" + text_move + ", " + existing_flags + "): not [x,y;flags], missing comma");
    }

    flags = parse_flags(xy_text_flags, existing_flags);

    return [x, y, flags];
}

// Decode a Parlett notation into a list of [x,y,flags], where
// x and y are destinations relative to the piece origin, and flags describes
// under what conditions the move can be made. + is forward, - is backwards,
// from the perspective of the active color. Has no knowledge of board state.
// The moves must be filtered to determine their validity.
function decode_one_parlett(parlett)
{
    var distances, directions, flags, movement, rel_moves;
    var hippogonal = false;

    flags = {};
    distances = [];
    rel_moves = [];

    movement = "rider";
    for (var i = 0; i < parlett.length; i += 1) {
        var ch = parlett.substr(i, 1);

        if (ch === "~") {
            movement = "leaper";

        // Flags, documented on http://en.wikipedia.org/wiki/Fairy_chess_piece#Additions_to_Parlett.27s
        } else if (ch === "i") { 
            // Initial move: Can only if the piece is in its original position
            // (pawn's 2 move forward)
            flags.initial_only = true;
        } else if (ch === "c") {
            // Capture only: may only be used if destination is occupied by enemy piece
            // (pawn's diagnal capture)
            flags.capture_only = true;
        } else if (ch === "o") {
            // Can not capture: destination square must be unoccupied; since by default, piece
            // can move to enemy square in order to capture it
            // (pawn's forward move)
            flags.no_capture = true;

        // Extended Parlett
      
        // Include an existing piece movement, possibly with flags
        } else if (ch === "#") {
            var type = parlett.substr(i + 1);
            assert(PIECE_TYPES[type], "in Parlett #include, piece name not found: " + type);
            var included = dojo.clone(unfiltered_moves(PIECE_TYPES[type].parlett));

            for (i = 0; i < included.length; i += 1) {
                Object.extend(included[i][2], flags);
            }

            return included;

        // Direct move text: [rel_x,rel_y;flag1;flag2;...] 
        } else if (ch === "[") {
            var text_move = "";
            var nest_level = 1;
            while(i < parlett.length)
            {
                i += 1;
                var chi = parlett.substr(i, 1);
                if (chi === "]") { nest_level -= 1; }
                if (chi === "[") { nest_level += 1; }
                if (nest_level === 0) { break; } 

                text_move += chi;
            }
            rel_moves.push(decode_relative_raw_move(text_move, flags));

        // Nested flags: {oi2>, asdf.. ;flag1;flag2;flag3...}
        } else if (ch === "{") {
            var inner, nest;
            
            inner = "";
            nest = 1;
            while(i < parlett.length)
            {
                i += 1;
                var cho = parlett.substr(i, 1);
                if (cho === "}") { nest -= 1; }
                if (cho === "{") { nest += 1; }
                if (nest === 0) { break; } 

                inner += cho;
            }

            return nested_flags(inner);

        // Standard Parlett
        } else if (/[0-9]/.test(ch)) {
            distances.push(parseInt(ch, 10));
        } else if (ch === "n" || ch === "m") {
            distances.push(Infinity);
        } else if (ch === "/") {
            hippogonal = true;
        } else if (ch === " ") {
            assert(false, "relative_parlett(" + parlett + "): whitespace encountered, did you forget a comma?");
        } else {
            var maybe_directions = relative_decode_direction(ch, parlett.substr(i + 1, 1));

            if (maybe_directions) {
                directions = maybe_directions[0];
                if (maybe_directions[1]) {
                    i += 1; // two-character direction
                }
            } else {
                assert(false, "relative_parlett(" + parlett + "): unsupported: '" + ch + "'");
            }
        }
    }

    if (hippogonal) {
        assert(distances.length === 2, "relative_parlett(" + parlett + "): for hippogonal, expected exactly two distances");
        var a = distances[0], b = distances[1];

        if (a !== Infinity && b !== Infinity) {
            // Hippogonals in all directions
            // TODO: support direction modifiers, vector
            rel_moves.push.apply(rel_moves, without_dupes([
                [-a, -b, flags],
                [-a, +b, flags],
                [+a, -b, flags],
                [+a, +b, flags],

                [-b, -a, flags],
                [-b, +a, flags],
                [+b, -a, flags],
                [+b, +a, flags]
                ]));
        } else {
            // ~n/m, any square on board. Remember, these are relative moves.
            for (var x = -FILE_MAX; x <= +FILE_MAX; x += 1) {
                for (var y = -RANK_MAX; y <= +RANK_MAX; y += 1) {
                    rel_moves.push([x, y, flags]);
                }
            }
        }
    } else if (directions) {
        for (i = 0; i < directions.length; i += 1) {
            var dir = directions[i];
            var rel_x, rel_y, prev_rel_x, prev_rel_y, distance;

            // Optional limit on number of steps to take of direction vector
            if (distances.length !== 0) {
                distance = distances[0];

                assert(distances.length === 1, "relative_parlett(" + parlett + "): multiple distances given for rider, expected one or none");
            } else {
                distance = Infinity;
            }

            rel_x = rel_y = 0;
            prev_rel_x = null;
            prev_rel_y = null;

            var max = Math.max(RANK_MAX, FILE_MAX);

            var count = 0;

            for (var j = 1; j < max; j += 1) {
                var these_flags = {};

                // Riders get blocked. Note that you can have a non-hippogonal leaper.
                // ~n* (lion) for example, is like a queen, but not blocked by intervening pieces.

                // Blocked on a square which you CANNOT move to - riders w/ distance limits
                if (prev_rel_x !== null && prev_rel_y !== null && 
                        movement === "rider" && distance !== Infinity) { 
                    // TODO: Support multiple squares. This only works for one square, for
                    // pawn's double-moves. 2> means two forward, unblocked, and it works,
                    // but 3> for three forward, unblocked, won't work yet.
                    these_flags.if_unblocked_dx = prev_rel_x;
                    these_flags.if_unblocked_dy = prev_rel_y;

                } 

                rel_x += dir[0];
                rel_y += dir[1];

                Object.extend(these_flags, flags);

                // Blocked by a square which you CAN move to - riders w/ no limits except board dimensions
                if (distance === Infinity && movement === "rider") {
                    these_flags.if_blocked_skip = max - count - 2;
                }

                if (distance === Infinity || j === distance) {
                    rel_moves.push([rel_x, rel_y, these_flags]);
                    count += 1;

                    if (j === distance) { 
                        break;
                    }
                }

                prev_rel_x = rel_x;
                prev_rel_y = rel_y;
            }
        }
    }

    return rel_moves;
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//    [1,2] in [[1,2], [3,4]]
// is false, since 
//    [1,2] === [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
// Note: flags also differentiate a move.
function without_dupes(a)
{
    var hash = {};
    var result = [];

    for (var i = 0; i < a.length; i += 1) {
        // Add if not a dupe
        if (!hash[Object.toJSON(a[i])]) {
            result.push(a[i]);
        }

        // Record that this element was added. Converts to a string,
        // unfortunately, so can't just use own_properties() after filling 
        // in the hash.
        hash[Object.toJSON(a[i])] = true;
    }

    return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
    return {white: "black", black: "white"}[color];
}

// Set the active color to white or black, or go to the next color (toggling).
// Returns a character for algebraic notation, + = check, etc., if applicable
// If historical, do not check for threefold repetition.
function set_turn(color, historical)
{
    var new_color, checked, no_moves, text_move, text_end, old_color, old_fullmove, repeats;

    old_color = GAME_STATE.active_color;

    if (color === "next") {
        new_color = opposite_color(GAME_STATE.active_color);
    } else if (color === "black" || color === "white") {
        new_color = color;
    } else {
        assert(false, "set_turn(" + color + "): invalid color");
    }

    $("status").innerHTML = ucfirst(new_color) + "'s Turn";

    // Move number is incremented after black moves, according to rules.
    old_fullmove = GAME_STATE.fullmove_number;
    if (color === "next" && GAME_STATE.active_color === "black") {
        GAME_STATE.fullmove_number += 1;
    }

    GAME_STATE.active_color = new_color;
   
    // Active player in check?
    checked = GAME_STATE.active_in_check = in_check(GAME_STATE.active_color, calculate_moves(opposite_color(new_color), true));

    // Note: this takes some time... is there any way to run it right AFTER the piece has
    // gone through the endeffect? This is called in onDrop.
    // TODO: find out how to run something *after* the endeffect, for smoother UI.
    calculate_moves(GAME_STATE.active_color);

    // Zero mobility? For detecting stalemate, checkmate.
    no_moves = own_property_count(VALID_MOVES) === 0;

    // Results. 
    if (checked && !no_moves) {
        set_check_message("Check!");
        text_move = "+";
        // TODO: detect double-check, allow ++ for descriptive/algebraic descriptive, but not algebraic
    } else if (!checked && no_moves) {
        set_check_message("Draw (stalemate)");
        text_end = "&frac12;-&frac12;";
    } else if (checked && no_moves) {
        set_check_message("Checkmate.");
        if (new_color === "white") { 
            text_move = "#";
            text_end = "0-1";  // white lost
        } else {
            text_move = "#";
            text_end = "1-0";
        }
    } else if (check_insufficient_material()) {
        set_check_message("Draw (material)");
        text_end = "&frac12;-&frac12;";
    } else if (GAME_STATE.halfmove_clock >= 50) {
        set_check_message("Draw (fifty move) claimable");
    } else {
        set_check_message("");
    }

    if (text_end) {
        // So can programmatically tell the game is finished.
        GAME_STATE.ended = text_end;
    }

    var new_state = save_fen();
    dojo.cookie("board", new_state);

    var ply = encode_ply(old_color, old_fullmove);

    if (!old_color) {
        // If no one has moved yet, ply is 0 for initial board position.
        ply = 0;
    }

    if (!historical) {
        repeats = check_repetition(ply);
    }
    
    if (color === "next") { 
        GAME_STATE.position_after[ply] = new_state;
    }

    return {text_move: text_move, text_end: text_end, repeats: repeats};
}

// Set the game check status (or draw, checkmate) message.
function set_check_message(msg)
{
    $("check").innerHTML = msg;
    if (msg) {
        $("dash").show();
    } else {
        $("dash").hide();
    }
}

// Return whether there is insufficient material to mate
function check_insufficient_material()
{
    var counts = {}, total = 0, total_bishops = 0;
    var bishops = {white:{white:0, black:0}, black:{white:0, black:0}};
   
    // Count how many of each piece type are on the board
    // TODO: piece lists?
    for (var x = 1; x <= RANK_MAX; x += 1) {
        for (var y = 1; y <= FILE_MAX; y += 1) {
            var square = VBOARD[x][y];

            if (square.piece) {
                // Count all pieces
                if (counts[square.piece.type] === undefined) {
                    counts[square.piece.type] = 1;
                } else {
                    counts[square.piece.type] += 1;
                }
                total += 1;

                // Count color of bishops and squares they are bound to
                if (square.piece.type === "bishop") {
                    bishops[square.color][square.piece.color] += 1;
                    total_bishops += 1;
                }
            }
        }
    }

    // FIDE rules 
    if (total === 2 && counts.king === 2) {
        // king v. king
        return true;
    } else if (total === 3 && counts.king === 2) {
        // king v. king + bishop
        // king v. king + knight
        return counts.bishop === 1 || counts.knight === 1;
    } else if (total === total_bishops + 2 && counts.king === 2 && 
            (bishops.black.black === bishops.black.white ||
             bishops.white.black === bishops.white.white)) {
        // king and bishop(s) versus king and bishop(s) all on same color
        return true;
    }

    return false;
}

// Check for three-move repetition, which allows a draw to be claimed (not compulsory)
function check_repetition(ply)
{
    var new_state = active_fen(true);
    var reps;

    // Save new board state for three-move repetition
    if (GAME_STATE.position_moves[new_state] === undefined) {
        GAME_STATE.position_moves[new_state] = [ply];
    } else {

        reps = GAME_STATE.position_moves[new_state].slice();

        // This occurred here, too.
        GAME_STATE.position_moves[new_state].push(ply);

        if (GAME_STATE.position_moves[new_state].length >= 3) {
            // Player can claim a draw, but its not required (you might have a better position)
            // See http://en.wikipedia.org/wiki/Threefold_repetition
            set_check_message("Draw (repetition) claimable");

            // Return moves for highlighting, except this move (it is too early
            // for mark_repeated_moves to highlight, so move_piece_to_square will
            // add the current move, if we return something).
            return reps;
        }
    }

    return null;
}

//// BOARD FUNCTIONS

// TODO: a "board lab", where can drag pieces onto board in arbitrary
// positions, or drag off (with an Effect.Puff), to load arbitrary fen.
// Have a different mode where pieces can be dragged anywhere, including
// to offboard, and from a piece library.

// Load the virtual board into the displayed board. Any number of operations
// can be conducted on the virtual in-memory board, then when it is finished,
// only then does the board need to be rendered in HTML. 
function realize_vboard()
{
    for (var x = 1; x <= FILE_MAX; x += 1) {
        for (var y = 1; y <= RANK_MAX; y += 1) {
            var v = VBOARD[x][y];
            var square = SQUARES[x][y];
            var piece;

            while (square.firstChild) {
                square.removeChild(square.firstChild);
            }

            if (v.piece) {
                piece = create_piece(v.piece.color, v.piece.type);
                piece.square = SQUARES[x][y];
                // TODO: what about descriptive_name, adescriptive_name?? Its important.
                piece.unique_id = v.piece.unique_id;

                square.appendChild(piece);
            }
        }
    }

    // TODO: Find a better way to do this. Highlight when start dragging?
    //dojo.addClass(SQUARES[GAME_STATE.recent_square.x][GAME_STATE.recent_square.y], "recent-move-" + GAME_STATE.recent_square.color);
}

// Save the current displayed board state to VBOARD.
function make_vboard()
{
    for (var x = 1; x <= FILE_MAX; x += 1) {
        for (var y = 1; y <= RANK_MAX; y += 1) {
            var square = SQUARES[x][y];
            var piece = square.firstChild;

            if (piece) {
                // TODO: Store arbitrary parameters?
                VBOARD[x][y].piece = {virtual:true, color:piece.color, type:piece.type, square:VBOARD[x][y], unique_id:piece.unique_id};
            } else {
                VBOARD[x][y].piece = null;
            }
        }
    }
}

// Internally name the square cells with their (x,y) coordinates
// and filerank notation, once when the page loads. This is only code so I
// don't have to manually type <td x=0 y=0 filerank=a8> etc. in all the cells.
// Also populates SQUARES for fast lookup, and VBOARD virtual board.
var KEYS_PRESSED;
function init_board()
{
    SQUARES = [];
    VBOARD = [];
    for (var x = 1; x <= FILE_MAX; x += 1) {
        SQUARES[x] = [];
        VBOARD[x] = [];
        for (var y = 1; y <= RANK_MAX; y += 1) {
            // Lookup the table cell from the DOM. This is extraordinarly expensive,
            // so it is only done once here then stored in a global, SQUARES.
            var square  = $('board-body').childNodes[9 - y].childNodes[x];

            square.x = x;
            square.y = y;
            square.filerank = xy2filerank(x, y);
            // Store the square color here once, so can always lookup .color, 
            // never have to check the white/black class name again.
            square.color = dojo.hasClass(square, "white") ? "white" : "black";

            square.descriptive = {};
            square.descriptive.white = xy2descriptive("white", [x, y]);
            square.descriptive.black = xy2descriptive("black", [x, y]);

            // http://www.sitepen.com/labs/code/iphone/events.html - fast
            // TODO: get this working on desktop and phone
            // http://www.manifestinteractive.com/iphone/touch/
            // jQuery Touch is slow. Prototype + Scriptaculous is expected to be as well,
            // maybe look into switching to a more lightweight JavaScript library.
            /*
            Event.observe(square, "click", function() {
                        // TODO: tap-to-move, as an alternative to dragging
                        if (GAME_STATE.dragging) {
                            alert(1);
                            //function move_dropped_piece(piece, square, event)
                        }
                    });
            */

            SQUARES[x][y] = square;

            // Virtual, in-memory board
            VBOARD[x][y] = {
                virtual: true,
                x: x, 
                y: y, 
                filerank: square.filerank, 
                color: square.color,
                descriptive: {white: square.descriptive.white, black: square.descriptive.black}
            };
        }
    }


    // Konami code
    // TODO: type to move, match anything
    /*
    KEYS_PRESSED = [];
    document.onkeydown = function(event) {
            if (!event.keyCode) { 
                return;
            }
            KEYS_PRESSED.push(event.keyCode);
            if (KEYS_PRESSED.length > 11) {
                KEYS_PRESSED.shift();
            }
            if (KEYS_PRESSED.join('') === '3838404037393739666513') {
                alert("TODO: easter egg");
            }
        };
    */

    var board_menu = $("saved_board_menu");

    board_menu.appendChild(Builder.node("option", {value: "", selected: "selected"}, "Load board..."));


    // Create saved boards for openings, since they are stored by
    // board position rather than name.
    SAVED_BOARDS["Chess Openings"] = {};
    for (var opening_board in OPENINGS) {
        if (OPENINGS.hasOwnProperty(opening_board)) {
            var opening_name = OPENINGS[opening_board];

            SAVED_BOARDS["Chess Openings"][opening_name] = opening_board;
        }
    }

    // Saved boards by group
    for (var group_name in SAVED_BOARDS) {
        if (SAVED_BOARDS.hasOwnProperty(group_name)) {
            var members = SAVED_BOARDS[group_name];

            var group = Builder.node("optgroup", {label:group_name});
            board_menu.appendChild(group);

            for (var board_name in members) {
                if (members.hasOwnProperty(board_name)) {
                    var fen = members[board_name];
                    group.appendChild(Builder.node("option", {value: fen}, board_name));
                }
            }
        }
    }

    board_menu.selectedIndex = 0;

}

// Load a board from the drop down menu of SAVED_BOARDS.
function change_loaded_board(menu)
{
    if (!menu.value) {
        return;
    }

    load_fen(menu.value);

    menu[0].innerText = "Loaded: " + menu[menu.selectedIndex].innerText;
    // Reset index to zero so can reload same board by selecting same drop down
    menu.selectedIndex = 0;
}

// Acknowledge that a piece was captured. Called by move_piece_to_square(), which
// does all the board manipulation. 
function piece_was_captured(piece, square)
{
    // If rook captured, remove castling privileges
    if (piece.type === "rook") {
        // Note that this is the first rank of the *other* player
        var opponent = opposite_color(GAME_STATE.active_color);
        var first_rank = opponent === "white" ? 1 : 8;
        
        // TODO: really would like to not have to hardcode this
        if (square.y === first_rank) {
            if (square.x === 1) {
                GAME_STATE.can_castle[opponent].clong = false;
                //console.log("no more long");
            } else if (square.x === 8) {
                GAME_STATE.can_castle[opponent].cshort = false;
                //console.log("no more short");
            }
        }
    }

    // TODO: show as captured, somewhere with icons
}

// Find precomputed algebraic notation for this move. Called when
// user drags a piece to a square and we don't know what move it is.
function notation_from_piece_square(piece, square, text_input)
{
    var notations = VALID_MOVE_NOTATIONS[$F("output_notation")];
    var finds = {}, find_count = 0, one;

    // TODO: better data structure, inverted hash table lookup
    for (var notation in notations) {
        if (notations.hasOwnProperty(notation)) {
            var this_piece = notations[notation].piece;
            var this_square = notations[notation].square;
            var this_move = notations[notation].move;

            if (this_square.x === square.x && this_square.y === square.y && 
                this_piece.unique_id === piece.unique_id &&
                // TODO: if given text_input, lookup more directly
                (!text_input || text_input === notation)) {

                notation.move = this_move;

                one = {notation:notation, move:this_move};
                finds[notation] = one;
                find_count += 1;

                if (!this_move.promote_to) {
                    // Speed hack: no-promotion moves are unique by pc+sq
                    return one;
                }
            }
        }
    }

    if (find_count === 0) {
        return null;
    } else if (find_count === 1) {
        return one;
    } else {
        // When player drags a pawn to the last rank to be promoted,
        // four moves will be found, and they'll have to choose. Make this appear
        // to be the last found promotion option, since they all have the same
        // location, and the piece will be able to move into place before the 
        // user piece selection is made.
        return Object.extend(one, {multiple:true, choices:finds});
    }
}

// Get the direction vector (y component only) that is "forward" for the given color
function forwards_vector(color)
{
    if (color === "white") {
        return 1;
    } else { 
        return -1;
    } 
}



// Make a move on the virtual board.
// If is_hypothetical is true, this is an internal move part of another move
// (castling) so it shouldn't be logged.
function move_piece_to_square(piece, square, is_hypothetical, is_immediate, text_input)
{
    var from_square, move_text, filerank, only_move, move, tieback, did;

    from_square = piece.square;

    // Find out what move this was.
    tieback = notation_from_piece_square(piece, square, text_input);
    tieback.text_input = text_input;
    move = tieback.move;

    if (!is_hypothetical) {
        // For highlighting recent move on board
        GAME_STATE.recent_square = from_square;
        GAME_STATE.recent_piece = piece;

        move_text = tieback.notation;

        // Moving king makes it ineligible for castling
        if (move.clear_castle_short) {
            GAME_STATE.can_castle[GAME_STATE.active_color].cshort = false;
        }

        if (move.clear_castle_long) {
            GAME_STATE.can_castle[GAME_STATE.active_color].clong = false;
        }

        // If moved either rook, can't castle on that side.
        if (PIECE_TYPES[piece.type].castle) {
            // TODO: More generic, so will work with chess960 or 480
            if (from_square.x === 8) {
                GAME_STATE.can_castle[GAME_STATE.active_color].cshort = false;
            } else if (from_square.x === 1) {
                GAME_STATE.can_castle[GAME_STATE.active_color].clong = false;
            }
        }

        // If moved pawn, or was a capture, reset fifty move rule counter
        if (move.capture || PIECE_TYPES[piece.type].resets_50move) {
            GAME_STATE.halfmove_clock = 0;
        } else {
            GAME_STATE.halfmove_clock += 1;
        }
    }

    // If castling, move the rook in place. Ugly hardcoded.
    if (piece.type === "king") {
        var first_rank = (GAME_STATE.active_color === "white" ? 1 : 8);
        if (from_square.x === 5) {
            if (square.x === 7) {
                // TODO: actually calculate square moved over, then move rook there
                // (instead of hardcoding). Short.
                // TODO: test virtual
                move_piece_to_square(pc(8, first_rank, piece.virtual), VBOARD[6][first_rank], true, true);
            } else if (square.x === 3) {
                // Castle long.
                move_piece_to_square(pc(1, first_rank, piece.virtual), VBOARD[4][first_rank], true, true);
            }
        }
    }

    did = do_virtual_move(piece, move);
    if (did.captured) {
        piece_was_captured(did.captured, did.capture_square);
    }

    if (!is_hypothetical) {
        // If double pawn move, this creates an en passant target square
        filerank = xy2filerank([square.x, square.y]);
        if (move.create_ep_target) {
            GAME_STATE.ep_target = move.create_ep_target;
        } else {
            // En passant possibility disappears immediately after any other move
            GAME_STATE.ep_target = null;
        }
    }

    if (should_promote(piece)) {
        if (tieback.multiple) {
            // Piece+square move, need input from user: what piece 
            ask_to_promote(piece, tieback, is_immediate);
        } else {
            // Piece+square+piece to promote have been given (probably from mv())
            promote(piece, tieback.move.promote_to, tieback.notation, is_immediate);
        }
    } else {
        // If not a multi-move (moving rook in castling), log and go to next turn
        if (!is_hypothetical) {
            finish_up_move(tieback.notation, is_immediate);
        }
    }

    // TODO: return from finish_up_move, deferred? promotions..
    // To allow undo_virtual_move
    //return did;
}

// Perform bookkeeping on the move after it has been actually made, 
// in move_piece_to_square().
function finish_up_move(move_text, is_immediate)
{
    var alg_move, ply, turn_info, move_text;

    // TODO: ellipsis if black is first recorded move, or intervening commentary
    if (GAME_STATE.active_color === "white") {
        alg_move = '<span class="fullmove_number">' + GAME_STATE.fullmove_number + '<\/span>';
        if (GAME_STATE.fullmove_number === 1) {
            // Period goes to initial position, kind of strange, but its uninstrusive
            alg_move += move_link(0, ".");
        } else {
            alg_move += ".";
        }
        alg_move += " ";
    } else {
        alg_move = " ";
    }

    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fullmove_number);

    only_move = own_property_count(VALID_MOVE_NOTATIONS.SAN) === 1;

    turn_info = set_turn("next", false);

    if (turn_info.text_move) {
        move_text += turn_info.text_move;
    }

    alg_move += move_link(ply, move_text) + " ";

    if (only_move) {
        // NAG for "only move", see http://www.markalowery.net/Chess/Notation/NAG.html
        alg_move += "$7 ";
    }

    $$("a.active_move").each(function(m) {
            m.removeClassName("active_move");
        });

    set_next_back_accesskeys(ply);

    // PERFORMANCE: This takes 4% of load_pgn, 576 ms on a 14.456 s load. 
    // TODO: Instead of concatenating incrementally, gather it up, load all at once.
    $("move_history").innerHTML += alg_move;

    // End-text, not a move. Terminates the game.
    if (turn_info.text_end) {
        $("move_history").innerHTML += "\n" + turn_info.text_end;
    }

    // If there was a repetition, it occurred on this move. Indicate the moves.
    if (turn_info.repeats) { 
        turn_info.repeats.push(ply);
        mark_repeated_moves(turn_info.repeats);
    }

    var opening = OPENINGS[active_fen(true)];
    if (opening) {
        $("opening_name").innerHTML = opening;
    }
    // If not recognized, do not clear it -- keep up opening during the game



    if (is_immediate) {
        realize_vboard();

        make_droppables();
        populate_make_a_move_list();
        computer_move_if_applicable();
    }
}

// Visually indicate the moves which after threefold repetition
// Unfortunately, we highlight the move *after* the board state was repeated. This is
// because the first clickable link, say 1. Nf3, loads the move after
// Nf3 was made, not before (the initial board position). But you can
// repeat the initial board position:
// 1. Nf3 Nf6 2. Ng1 Ng8 3. Nf3 Nf6 4. Ng1 Ng8
var HIGHLIGHT_COLORS = ["yellow", "aquamarine", "lime", "khaki", "aqua"];
var REPEAT_COLOR_COUNT = 0;
function mark_repeated_moves(reps)
{
    var color = HIGHLIGHT_COLORS[REPEAT_COLOR_COUNT];

    REPEAT_COLOR_COUNT += 1;
   
    var setcolor = function(m) {
                //m.addClassName("repeated_move");
                m.setStyle({backgroundColor: color});
            };

    for (var i = 0; i < reps.length; i += 1) {
        var ply = reps[i];

        $$("a#ply_" + ply).each(setcolor);
    }
}

// Handle graphically moving of a piece, dropping it to its new location
function move_dropped_piece(piece, square, event)
{
    //console.log(piece);
    //console.log(square);
   
    // Scriptaculous sets position:relative when creating a draggable,
    // but this will cause the relative position when it was in the container it
    // moved from, to apply to the new container it moved to, so either it will be
    // positioned at the wrong place (if revert:false) or will jump by an amount
    // proportionate to the amount it first moved, then be moved back. This fixes it.
    piece.style.position = "static";

    // TODO: do some cool effects when a piece is captured, but not too cool
    // Any way to finish running the code AFTER the effect finishes? New effect?
    //if (square.firstChild) {
    //   new Effect.Squish(square.virtual ? square.piece : square.firstChild);
    //}

    // Can't drop this piece anywhere anymore.
    piece.removeClassName("piece-" + piece.prior_position);
    ALL_DROP_TARGETS.each(function(square) {
        Droppables.remove(square);
    });
    ALL_DROP_TARGETS = [];

    unhighlight_all();

    var virtual_square = VBOARD[square.x][square.y];
    var virtual_piece = VBOARD[piece.square.x][piece.square.y].piece;
 
    move_piece_to_square(virtual_piece, virtual_square, false, true);

    // Scriptaculous requires position:relative; with static, you can drag it
    // but it won't move with the cursor, so set it and crucially, reset the
    // relative position so that it won' be misaligned.
    piece.style.position = "relative";
    piece.style.left = piece.style.right = piece.style.top = piece.style.bottom = 0;
}

// Get the representation of the active board state in FEN.
// If strip_moves, return time-independent representation.
function active_fen(strip_moves)
{
    var fen = GAME_STATE.position_after.slice(-1)[0];

    if (strip_moves) {
        // Remove last two fields, move counts.
        fen = fen.split(" ").slice(0, -2).join(" ");
    } 

    return fen;
}

// Generate FEN from board state. Use active_fen() to get
// this if it already been calculated.
function save_fen()
{
    var fen = "", castles;

    // Board position
    for (var y = RANK_MAX; y > 0; y -= 1) {
        var blanks = 0;
        for (var x = 1; x <= FILE_MAX; x += 1) {
            var piece = VBOARD[x][y].piece;
            var letter;

            if (piece) {
                if (blanks) {
                    fen += blanks.toString();
                    blanks = 0;
                }
                letter = full_piece_prefix(piece);

                // Uppercase = white, lowercase = black
                if (piece.color === "black") {
                    letter = letter.toLowerCase();
                }

                fen += letter;
            } else {
                blanks += 1;
            }
        }
        if (blanks) {
            fen += blanks.toString();
        }
        if (y !== 1) {
            fen += "/";
        }
    }

    // Active color
    fen += " ";
    if (GAME_STATE.active_color === "white") {
        fen += "w";
    } else {
        fen += "b";
    }

    // Castling availability
    fen += " ";
    castles = false;
    if (GAME_STATE.can_castle.white.cshort) { fen += "K"; castles = true; }
    if (GAME_STATE.can_castle.white.clong)  { fen += "Q"; castles = true; }
    if (GAME_STATE.can_castle.black.cshort) { fen += "k"; castles = true; }
    if (GAME_STATE.can_castle.black.clong)  { fen += "q"; castles = true; }
    if (!castles) { fen += "-"; }

    // En passant target square
    fen += " ";
    if (GAME_STATE.ep_target) {
        fen += xy2filerank(GAME_STATE.ep_target);
    } else {
        fen += "-";
    }

    fen += " " + GAME_STATE.halfmove_clock;
    fen += " " + GAME_STATE.fullmove_number;

    return fen;
}

// Load board state in Forsyth-Edwards Notation. If replay is true, this is reloading an 
// existing position, not loading a new game.
// TODO: support EPD, and special rules
function load_fen(fen, replay)
{
    var parts, castling;

    parts = fen.split(" ");
    load_starting_position(parts[0], replay);

    assert(/^[wb]$/.test(parts[1]), "load_fen(" + fen + "): bad active color: " + parts[1]);

    castling = parts[2];
    GAME_STATE.can_castle.white.cshort = /K/.test(castling);
    GAME_STATE.can_castle.white.clong  = /Q/.test(castling);
    GAME_STATE.can_castle.black.cshort = /k/.test(castling);
    GAME_STATE.can_castle.black.clong  = /q/.test(castling);

    if (parts[3] === "-") {
        GAME_STATE.ep_target = null;
    } else {
        GAME_STATE.ep_target = filerank2xy(parts[3]);
    }

    GAME_STATE.halfmove_clock = parseInt(parts[4], 10);
    GAME_STATE.fullmove_number = parseInt(parts[5], 10);

    if (!replay) { 
        GAME_STATE.position_moves = {}; 
        GAME_STATE.position_after = [fen];  // 0th ply = initial state
        GAME_STATE.ended = null; 
    }
   
    // Now that everything is loaded, set the turn.
    make_vboard();
    set_turn({w:"white", b:"black"}[parts[1]], replay);
    make_droppables();
    populate_make_a_move_list();
}

// Remove all pieces from the board.
function clear_board()
{
    for (var x = 1; x <= RANK_MAX; x += 1) {
        for (var y = 1; y <= FILE_MAX; y += 1) {
            var square = SQUARES[x][y];
            while(square.firstChild) {
                square.removeChild(square.firstChild);
            }
        }
    }
}

// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR.
// If !replay, name pieces.
function load_starting_position(fen, replay)
{
    var i, x, y, code;

    clear_board();

    // Note that ranks and files internally are represented here by
    // x,y coordinates, so a8 = 1,8. That is where FEN starts.
    x = 1;
    y = 8;
    for (i = 0; i < fen.length; i += 1) {
        code = fen.charAt(i);
        if (code === "X" || code === "x") {
            i += 1;
            code += fen.charAt(i);

            // Expanded FEN codes
            if (code === "X(" || code === "x(") {
                // Read until closing paren
                var ch;
                i += 1;
                while(i < fen.length) {
                    ch = fen.charAt(i);
                    code += ch;
                    if (ch === ")") { break; }
                    i += 1;
                }
            }

            SQUARES[x][y].appendChild(create_piece_by_letter(code));
            SQUARES[x][y].firstChild.square = SQUARES[x][y];
            //VBOARD[x][y].piece = decode_piece_letter(code);
            //VBOARD[x][y].piece.square = VBOARD[x][y];
            x += 1;
        } else if (/[a-zA-Z]/.test(code)) {
            SQUARES[x][y].appendChild(create_piece_by_letter(code));
            SQUARES[x][y].firstChild.square = SQUARES[x][y];
            //VBOARD[x][y].piece = decode_piece_letter(code);
            //VBOARD[x][y].piece.square = VBOARD[x][y];
            x += 1;
        } else if (code === "/") {
            x = 1;
            y -= 1;
        } else if (/[0-9]/.test(code)) {
            x += code.charCodeAt(0) - "0".charCodeAt(0);
        } else if (code === " ") {
            break;
        } else {
            assert(false, "load_starting_position(" + fen + "): unknown code: " + code);
        }
    }

    if (!replay) {
        name_pieces();
        // Clear move history. TODO: Better way.
        $("move_history").innerHTML = "";
    }
}

//// PIECE FUNCTIONS

// Name each piece, in standard chess1 locations, using English descriptive notation.
function name_pieces()
{
    var piece, descriptive_name;

    for (var file_number = 1; file_number <= FILE_MAX; file_number += 1) {
        // English descriptive notation (only really applicable to chess1)
        var file = xy2descriptive("white", file_number);

        // White's pieces and pawns
        piece = pc(file_number, 1); if (piece) { piece.descriptive_name = file; }
        piece = pc(file_number, 2); if (piece) { descriptive_name = file + "P"; }

        // Black's pieces and pawns
        piece = pc(file_number, 8); if (piece) { descriptive_name = file; }
        piece = pc(file_number, 7); if (piece) { descriptive_name = file + "P"; }


        // Algebraic descriptive notation
        var afile = xy2filerank(file_number, "");
        for (var white_rank = 1; white_rank <= RANK_MAX; white_rank += 1) {
            var black_rank = 9 - white_rank;
            piece = pc(file_number, white_rank);
            var rank, piece_letter;

            if (!piece) {
                continue;
            }

            if (piece.color === "white") {
                rank = white_rank;
            } else {
                rank = black_rank;
            }

            piece_letter = full_piece_prefix(piece);
            // aP, bP, etc.. TODO: use rank, if needed to disambiguate (two
            // pieces of same type on same file). Use file, rank, or filerank
            // like disambiguating moves.
            piece.adescriptive_name = afile + piece_letter;

            // Unique identifier of piece. TODO: Use adescriptive_name, make it disambiguated
            // so it will be always unique and descriptive.
            piece.unique_id = afile + "" + white_rank + piece_letter;
        }
    }
}

/// TODO: a "piece lab", where can dynamically create new pieces,
// browse existing pieces. Show piece on board by itself, highlighting 
// valid moves, update when change Parlett movement types, allow to operate
// the piece and see how it behaves. Then return to the main board.

// Return the letter, if any, used for representing the piece type (name)
// in algebraic notation.
function algebraic_letter(type)
{
    if (PIECE_TYPES[type].alg_letter !== undefined) {
        return PIECE_TYPES[type].alg_letter;
    } else {
        return PIECE_TYPES[type].letter;
    }
}

// Given a letter, find the name of the piece (R = rook, etc.). The letter
// can either be for FEN (P = pawn), or algebraic notation (blank = pawn);
// both are recognized.
var cache_letter2name;
function piece_letter2name(letter)
{
    // If given a name, return what we were given.
    if (PIECE_TYPES[letter]) {
        return letter;
    }

    letter = letter.toUpperCase();

    if (!cache_letter2name) {
        cache_letter2name = {};

        for (var name in PIECE_TYPES) {
            if (PIECE_TYPES.hasOwnProperty(name)) {
                var info = PIECE_TYPES[name];

                if (info.letter !== undefined) {
                    cache_letter2name[info.letter] = name;
                } else if (info.alg_letter !== undefined) {
                    cache_letter2name[info.alg_letter] = name;
                }
            }
        }
    }

    return cache_letter2name[letter.toUpperCase()];
}

// Return the full piece prefix, succiently indicating the piece type.
// Will not return an empty string but may return E-FEN piece codes. 
function full_piece_prefix(piece)
{
    var letter = PIECE_TYPES[piece.type].letter;

    if (letter !== undefined) {
        return letter;
    } else {
        return (piece.color === "white" ? "X" : "x") + "(" + piece.type + ")";
    }
}

// Return algebraic prefix for a piece. May return an empty 
// string (for pawns, for example): prefers alg_letter over letter.
// To always get a non-empty string, use full_piece_prefix() instead.
function algebraic_piece_prefix(piece)
{
    if (PIECE_TYPES[piece.type].alg_letter !== undefined) {
        return PIECE_TYPES[piece.type].alg_letter;
    } else {
        return full_piece_prefix(piece);
    }
}

// Get the Unicode figurine for a piece of a given color, or fall back on 
// algebraic_piece_prefix if there isn't one.
function figurine_piece_prefix(color, piece)
{
    if (PIECE_TYPES[piece.type].figurines) {
        return PIECE_TYPES[piece.type].figurines[color === "white" ? 0 : 1];
    } else {
        return algebraic_piece_prefix(piece);
    }
}

// Return a piece at (x,y), or "offboard" if the coordinates are out of range.
// If virtual, operates on VBOARD, otherwise on SQUARES.
// TODO TODO: Make it only operate on virtual?
function pc_or_offboard(x, y, virtual)
{
    if (x < 1 || y < 1 || x > FILE_MAX || y > RANK_MAX) {
        return "offboard";
    }

    return pc(x, y, virtual);
}

// Return an existing piece somewhere (or a false value), given:
// - (x,y) coordinates, like (8,1)
// - location in filerank notation, like "a8"
// To get piece from a square, use .piece if virtual, or .firstChild if not
function pc(x, y, virtual)
{
    if (x.charAt) {
        var xy = filerank2xy(x);
        x = xy[0];
        y = xy[1];
    }

    //assert(x >= 1 && x <= FILE_MAX, "pc(" + x + ", " + y + "): bad x: " + x);
    //assert(y >= 1 && y <= RANK_MAX, "pc(" + x + ", " + y + "): bad y: " + y);

    return virtual ? VBOARD[x][y].piece : SQUARES[x][y].firstChild;
}

// Return the path to an image for the piece of that color
function image_path_for(type, color)
{
    var base;

    assert(PIECE_TYPES[type], "image_path_for(" + type + ", " + color + "): no such piece type");

    // Override image name
    if (PIECE_TYPES[type].image) {
        base = PIECE_TYPES[type].image;
    } else {
        base = type;
    }

    // Rejected TODOs, lack support:
    // - pngs
    // - use Unicode characters in a span!! How cool would that be? Infinite resolution.
    //   See for example http://en.wikipedia.org/wiki/Knight_(chess)
    //   Unfortunately, MSIE doesn't seem to support it, though it should..different font?
    // - Web fonts! Supported on Firefox 3.1+, Opera 10+, Safari 3.1+, IE4+
    //   See http://fonts.philip.html5.org/
    
    return "images/" + PREFS.image_set + "/" + {white:"w", black:"b"}[color] + base + ".gif";
}

// Decode Forsyth-Edwards Notation piece code, for example:
//  r = black rook, R = white rook, N = white knight
// Also allows extended names, X(elephant), x(elephant), etc.
function decode_piece_letter(name)
{
    var color, type;

    // In FEN, uppercase=white, lower=black
    if (/^[A-Z]/.test(name)) {
        color = "white";
    } else if (/^[a-z]/.test(name)) {
        color = "black";
    } else {
        assert(false, "create_piece_by_letter(" + name + "): not a letter");
    }
    name = name.toLowerCase();

    // x(name) or X(name) is explicit name, otherwise, is a letter
    if (/\(/.test(name)) {
        var ary = /^[xX]\(([^)]+)/.exec(name);
        type = ary[1];
    } else {
        type = piece_letter2name(name);
    }

    return {color: color, type: type};
}

// Create a new piece or pawn, given the letter.
function create_piece_by_letter(name)
{
    var decoded = decode_piece_letter(name);

    return create_piece(decoded.color, decoded.type);
}

// Create a new piece by color and type (full name).
// TODO: make this a constructor so you can do new Piece().
function create_piece(color, type)
{
    var filename, piece, classes;

    assert(type, "create_piece(" + type+ "): unrecognized piece type: " + type);

    filename = image_path_for(type, color);


    // CSS classes, can use with $$ and also shown in toString (useful 
    // for debugging), however, note that code should not use this, because
    // all the classes are in a space-separated string, .className, according to
    // the DOM, and Prototype's hasClassName uses a slow RegExp to parse it,
    // and dojo's hasClass uses indexOf so its faster, but it still involves
    // parsing, and it is ugly. Probably a design flaw, oh well.
    // Use .type and .piece (set below) instead of classes for speed.
    classes = ["piece", color, type].join(" ");

    // Royal class is very important.
    if (PIECE_TYPES[type].royal) {
        classes += " royal";
    }

    // TODO Use a div with background-image instead, then can have arbitrary
    // characters, instead of just images, more flexible, maybe transition too.
    piece = Builder.node('img', {'src': filename, 'class': classes});

    // Property will tell name of piece. To tell what color, or if it is
    // a piece in the first place, check the class names.
    piece.type = type;
    piece.color = color;

    // Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
    // Yahoo Games does this too, but uses a yellow outline.
    Event.observe(piece, 'mouseover', function() {
            highlight_moves(piece, true);
            // for debugging
            //piece.setStyle({border: '1px solid black'});
        });
    Event.observe(piece, 'mouseout', function() {
            highlight_moves(piece, false);
            //piece.setStyle({border: 'none'});
        });

    // Make all new pieces draggable. I tried only making the active color's
    // pieces draggable, but then in Safari they can still be selected like text,
    // even with enable_document_selection(false), maybe I need to enable it on the
    // images too, but it wasn't appealing. In Firefox, the images can be dragged
    // as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
    // if they are the active colors move. The player can drag the opponent's pieces
    // around but not drop anywhere.

    var drag = new Draggable(piece, { 
        revert: true, 
        starteffect: undefined, 
        endeffect: undefined,
        onStart: function() { GAME_STATE.dragging = true; },
        onEnd: function() { GAME_STATE.dragging = false; }
        // TODO: figure out why on IE7, dragged pieces are below the highlighted squares!
        // even with zindex: 1001
     });
    // unused: drag

    return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
function highlight_moves(piece, enable)
{
    var from_square, moves;

    // If player is dragging a piece over another piece, don't show
    // legal moves for the piece under it.
    if (GAME_STATE.dragging) {
        return;
        }

    // If not this player's turn, no legal moves
    if (piece.color !== GAME_STATE.active_color) {
        return [];
    }

    from_square = piece.square;

    if (!from_square) {
        // Could not find a square for the piece, it no longer exists,
        // so no need to concern ourselves with highlighting its moves.
        return;
    }

    //console.log(from_square.filerank);
    moves = VALID_MOVES[from_square.filerank];
    //console.log(moves);
    if (!moves) {
        return;    
    }

    moves.each(function(move) {
        var x, y, flags, to_square;
        
        x = move.x;
        y = move.y;
        flags = move;
        to_square = SQUARES[x][y];

        if (enable) {
            if (to_square.color === "white") {
                to_square.addClassName("legal-move-white");
            } else {
                to_square.addClassName("legal-move-black");
            }
        } else {
                to_square.removeClassName("legal-move-white");
                to_square.removeClassName("legal-move-black");
        }
    });
}

// Unhighlight all highlighted black/white squares. Used in onEnd draggable, for
// some reason, highlight_moves(piece, false) does not unhighlight, maybe the piece changed..
function unhighlight_all()
{
    $$("td.legal-move-white", "td.legal-move-black").each(function(square) {
        square.removeClassName("legal-move-white");
        square.removeClassName("legal-move-black");
    });
}

//// SQUARE FUNCTIONS / FILE-RANK NOTATION

// Convert filerank f8 to the x,y coordinate [8,6], etc. These coordinates
// are used internally, but filerank notation is useful for human consumption
// (though I actually think better in descriptive notation, but maybe I'm in the minority there)
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// one-based table cell with (8,1) at the top-left. In filerank notation, this
// square is labeled a8. The bottom-right square (8,1) is filerank's h1.
function filerank2xy(code)
{
    var x = code.charCodeAt(0) - "a".charCodeAt(0) + 1; // corresponds to file (horizontal)
    var y = code.charCodeAt(1) - "1".charCodeAt(0) + 1; // corresponds to rank (vertical)

    //assert(x >= 1 && x <= FILE_MAX, "filerank2xy(" + code + "): bad x: " + x);
    //assert(y >= 1 && y <= RANK_MAX, "filerank2xy(" + code + "): bad y: " + y);

    return [x, y];
}

// Convert from x,y coordinates to filerank notation for human consumption. Can either pass
// xy2filerank(1, 8) === "a8"
// xy2filerank([1, 8]) === "a8"
// xy2filerank(1, "") === "a"
function xy2filerank(x, y)
{
    var filerank;

    if (y === undefined) {
        // Passed array
        y = x[1];
        x = x[0];
    }

    //assert(x >= 1 && x <= FILE_MAX, "xy2filerank(" + x + ", " + y + "): bad x: " + x);
    //assert(y === "" || (y >= 1 && y <= RANK_MAX), "xy2filerank(" + x + ", " + y + "): bad y: " + y);

    filerank = String.fromCharCode(x + "a".charCodeAt(0) - 1);
    if (y !== "") {
        filerank += String.fromCharCode(y + "1".charCodeAt(0) - 1);
    }

    return filerank;
}


// Return name of square from color's perspective in English descriptive notation
// Accepts an array of two numbers, for file and rank, or just a file
// Only works for chess1, not any variants where the pieces are arranged differently.
function xy2descriptive(color, xy)
{
    var x, y;
    if (Object.isArray(xy)) {
        x = xy[0];
        y = xy[1];
    } else if (xy.x && xy.y) {
        x = xy.x;
        y = xy.y;
    } else {
        x = xy;
        y = "";
    }

    assert(x >= 1 && x <= FILE_MAX, "xy2descriptive(" + x + ", " + y + "): bad x: " + x);
    assert(y === "" || (y >= 1 && y <= RANK_MAX), "xy2descriptive(" + x + ", " + y + "): bad y: " + y);

    return [null, "QR", "QN", "QB", "Q", "K", "KB", "KN", "KR"][x] + (color === "white" ? y : 9 - y);
}

// Return name of square from color's perspective in "algebraic descriptive notation".
// Same file as xy2algebraic, but rank is from symmetric, not always white's perspective.
function xy2adescriptive(color, xy)
{
    var x, y;
 
    if (Object.isArray(xy)) {
        x = xy[0];
        y = xy[1];
    } else if (xy.x && xy.y) {
        x = xy.x;
        y = xy.y;
    } else {
        x = xy;
        y = "";
    }

    assert(x >= 1 && x <= FILE_MAX, "xy2adescriptive(" + x + ", " + y + "): bad x: " + x);
    assert(y >= 1 && y <= RANK_MAX, "xy2adescriptive(" + x + ", " + y + "): bad y: " + y);

    return xy2filerank(x, "") + (color === "white" ? y : 9 - y);
}

// Shorten a file name, in descriptive notation, to a possibly-ambiguous name.
// QR for queen's rook file is shortened to R, and so is KR for king's rook. 
function short_descriptive(descriptive_file)
{
    return {
        QR:"R", QN:"N", QB:"B", KB:"B", KN:"N", KR:"R", K:"K", Q:"Q",
        QRP:"RP", QNP:"NP", QBP:"BP", KBP:"BP", KNP:"NP", KRP:"RP", KP:"KP", QP:"QP" 
    }[descriptive_file];
}

// Get a square cell, given location in either
// - filerank notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 1,8)
// To get the square of a piece, use .square
// Note: code should use SQUARES[x][y] or .square. This is 
// only for user convenience (console) and debugging.
function sq(code, extra)
{
    var x, y, xy;

    //assert(code !== undefined, "sq(" + code + ", " + extra + "): code is undefined");
    //assert(code !== null, "sq(" + code + ", " + extra + "): code is null");

    // Is it x,y passed as separate parameters?
    if (extra !== undefined) {
        x = code;
        y = extra;
    // Is it a string in algebraic notation that can be converted?
    } else if (code.charCodeAt) {
        xy = filerank2xy(code);

        // Note JavaScript 1.8 can do var [x,y] = ...
        x = xy[0];
        y = xy[1];
    } else {
        assert(false, "sq(" + code + ", " + extra + "): couldn't find out what I was given");
    }

    /*assert(x >= 1 && x <= FILE_MAX && y >= 1 && y <= RANK_MAX, "sq(" + code + ", " + extra + 
        "): out of range (" + x + ", " + y + ")");*/

    return SQUARES[x][y];
}

//// LOW-LEVEL FUNCTIONS

// Random integer within range
function randint(minimum, maximum)
{
    return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}

// Uppercase first character, like in Perl
function ucfirst(s)
{
    assert(s.substring, "ucfirst(" + s + "): no substring method, not a string? callee=" + 
            arguments.callee);
    return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
    return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
    if (!expression) {
        alert(message);
        if (window.console && console.trace) {
            // Give a stack trace for Firebug
            console.trace();
        }

        throw new AssertException(message);
    }
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
var ORIGINAL_ONSELECTSTART;
function enable_document_selection(enable) {
    if(enable) {
        document.onselectstart = ORIGINAL_ONSELECTSTART;
    } else {
        ORIGINAL_ONSELECTSTART = document.onselectstart;
        document.onselectstart = function() { return false; };
    }
}

</script>
</head>
<body>
<table id="outer">
 <tr>
  <td style="vertical-align: top">
<!-- TODO: dynamically generate, so can have arbitrary sizes -->
<table class="board" id="board">
<tbody id="board-body"
><tr
  ><td></td
  ><td class="file label">a</td
  ><td class="file label">b</td
  ><td class="file label">c</td
  ><td class="file label">d</td
  ><td class="file label">e</td
  ><td class="file label">f</td
  ><td class="file label">g</td
  ><td class="file label">h</td
></tr
><tr
  ><td class="rank label">8</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">7</td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square right-edge"></td
></tr
><tr
  ><td class="rank label">6</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">5</td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square right-edge"></td
></tr
><tr
  ><td class="rank label">4</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">3</td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square"></td
 ><td class="black square"></td
 ><td class="white square right-edge"></td
></tr
><tr
  ><td class="rank label">2</td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square"></td
  ><td class="white square"></td
  ><td class="black square right-edge"></td
></tr
><tr
 ><td class="rank label">1</td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge"></td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge"></td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge"></td
 ><td class="black square bottom-edge"></td
 ><td class="white square bottom-edge right-edge"></td
></tr
></tbody
></table>

 </td><td style="vertical-align: top">
 <noscript><p>JavaScript is disabled, nothing will work!</p></noscript>

 <div id="game_ui">

 <!-- Header elements, game metadata. Hidden/shown as needed. -->
 <p id="header" style="display: none; text-align: center" 
  onclick="javascript:edit_pgn()" class="show_White">
  <span class="players">
   <span id="PGN_White" class="player_name" style="display: none">White</span>
   <span class="player_elo"><span style="display: none" class="show_WhiteElo">(</span><span id="PGN_WhiteElo" style="display: none">1500</span><span class="show_WhiteElo" style="display: none">)</span></span>
    <span id="vs" style="display: none" class="show_White">vs.</span>
   <span id="PGN_Black" class="player_name" style="display: none">Black</span>
   <span class="player_elo"><span style="display: none" class="show_BlackElo">(</span><span id="PGN_BlackElo" style="display: none">1500</span><span class="show_BlackElo" style="display: none">)</span></span>
  </span>
   <br class="show_White" style="display: none">

   <span id="PGN_Event" style="display: none">Event</span>
   <span style="display: none" class="show_Round">(</span><span id="PGN_Round" style="display: none">Round</span><span style="display: none" class="show_PNG_Round">)</span>
   <span id="PGN_Site" style="display: none">Site</span><br class="show_PNG_Event" style="display: none">

   <span id="PGN_Date" style="display: none">Date</span>
   <span id="PGN_Time" style="display: none">Time</span>
 </p> 

 <p>
  <span id="status"></span> 
  <span id="dash" style="display: none">&mdash;</span>
  <span id="check"></span>
  <br>
  <span id="promote_container"></span>
 </p>


 <!-- TODO: disclosure triangles -->
 <p><a href="#" onclick="javascript:new Effect.toggle('controls', 'slide', { duration: 0.1 })">advanced</a>
 
 <div id="controls" style="display: block; border-left: 2px solid blue">
 <div>

 <p><select id="make_move_menu" onchange="make_move_by_menu(this)"></select>

 <p><span id="opening_name"></span>

 <!-- TODO: hide all this, since the purpose of this app is
 not to implement chess AI. But having automatic moves is useful for testing. -->
 <p><label for="white_computer">White AI<input type="checkbox" id="white_computer" name="white_computer" onclick="computer_move_if_applicable(this)"></label> 
 <label for="black_computer">Black AI<input type="checkbox" id="black_computer" name="black_computer" onclick="computer_move_if_applicable(this)"></label>

 <span id="score"></span><br>
 <span id="engine_status"></span>

 <div id="show_skill" style="display: none"><p>Skill Level: 
  <input type="text" size="3" maxlength="3" id="skill_level" onchange="update_skill(this)"></div>

 <p><select id="output_notation" name="output_notation"></select>

 <p><a href="#" onclick="edit_pgn()">edit PGN</a>

 <p><select id="saved_board_menu" onchange="change_loaded_board(this)"></select>
 </div>
 </div>

  <div id="moves_container" style="width: 500px; text-align: justify">
  <!-- TODO: scrollbar, http://livepipe.net/control/scrollbar -->
  <p id="move_history"></p>
  </div>
</div>

 </td>
</tr>
</table>

</body>
</html>
