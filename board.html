<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<!-- TODO: set to 0.4 onchangeorientation to landscape -->
<meta name="viewport" content="width=device-width; initial-scale=0.65; maximum-scale=0.65; user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<!-- TODO <base href="http://xyzzy.freeshell.org/chess/"> -->
<title>Chess by Jeff</title>
<!-- Copyright (C) 2009 Jeff Connelly -->
<!-- Created:20090411 -->
<style type="text/css">
body {
    font: medium 'Gill Sans', sans-serif;
    line-height: 1.3;
    word-spacing: 0.1em;
    margin: 0;
    padding: 0;
    border: 0;
}

a { text-decoration: none; }
a:hover { border-bottom: 1px dotted; }

/* Header */
span.players { font-size: large; }
span.player_name { font-weight: bold; }
span.player_elo { font-size: small; }

#status { font-weight: bold; }
#opening_name { font-size: small; }

/* PGN */
span.fmvn { font-weight: bold; }
a.active_move { border-bottom: 1px dashed; }
/*a.repeated_move { text-decoration: underline; }*/     /* goes well with dots and dashes */
/*a.repeated_move { background-color: yellow; }*/   /* highlight */

/* Element that can be dragged */
.draggable { position: absolute; cursor: move; }

/* TODO: switch to divs, for flexibility, and use background-image.. or maybe not */
img.piece
{ 
 border: none;
 margin: 0px;

 /* Make captured pieces (smaller) look better on IE7+. See
  * http://www.gabrielweinberg.com/blog/2009/06/things-about-web-images-i-just-learned.html
  */
 -ms-interpolation-mode: bicubic;

 /* TODO: Transition when promote, would be nice to be
  * able to do with a CSS transition, but img src is not
  * a CSS property, but a tag attribute. And even if tried to animate
  * background-image, it wouldn't work until 6806248 is fixed.
  *
  * Or could have two images and change their opacity, see
  * http://www.the-art-of-web.com/css/timing-function/ section 4, but
  * that is even worse. */
 /*-webkit-transition: background 1s linear;*/
}

img.captured
{
 width: 25px;
 height: 25px;
}

img.black {}
img.white {}

.canvas-board
{
/* Disable text selection when dragging */
/* http://www.w3.org/TR/1999/WD-css3-userint-19990916#user-select */
 -moz-user-select: none;
 -webkit-user-select: none;
 user-select: none;
}

td.square
{
 border-style: none;
 padding: 0em;
 margin: 0em;
 width: 55px; min-width: 55px;
 height: 55px; min-height: 55px;
 text-align: center;

 /* So absolutely positioned images in cell are not misaligned */
 vertical-align: top;
 text-align: left;
}

#piece-inspector {
    position: absolute; 
    border: 1px solid black; 
    background-color: #d3d3d3;
    /* Need to make this large, so king's movement doesn't extend beyond box. 
     * Would like to have the movement wrap, but I guess ; is not a word-breaking
     * character, so could use &shy;, works on Safari, and supposedly IE7 and Firefox.
     */
    width: 600px;

    /* Had to set this explicitly since inspector-diagram is positioned relatively
     * and won't expand the cell. */
    height: 450px;

    -webkit-box-shadow: 0 1px 20px rgba(0, 0, 0, 0.9); 
}

#inspector-diagram {
    margin-top: 10pt;
    font-family: Courier, Courier New; 
    font-size: 7pt;
    position: relative;
}

div.inspector-diagram-cell {
    width: 10px; 
    height: 10px; 
    position: absolute; 
    /*TODO: : 1px solid white;*/
}

</style>
<!--<script type='text/javascript' src='http://getfirebug.com/releases/lite/1.2/firebug-lite-compressed.js'></script>-->
<!--<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js.uncompressed.js"></script>-->

<script src="dojo.xd.js"></script>

<!--
<script src="http://o.aolcdn.com/dojo/1.3.1/dojo/dojo.xd.js"></script>
<script src="ZeroClipboard.js"></script>
<script src="http://www.google.com/jsapi"></script>
-->
<script type="text/javascript">
/*jslint bitwise: true, browser: true, eqeqeq: true, immed: true, newcap: true, nomen: true, plusplus: true, regexp: true, undef: true*/
/*global window google form_value Hash $break Event*/

/*
if (!window.google) {
    alert("Google was not found. Nothing will work.");
}

google.setOnLoadCallback(main);*/

/* TODO: why aren't these miniifed? http://code.google.com/apis/ajaxlibs/documentation/index.html#prototype has
 * direct paths but neither prototype nor scriptaculous are minified.. others are though. Maybe just use raw JS. */
/* TODO: http://compressorrater.thruhere.net/ */
//google.load("prototype", "1.6.0.3");

// Chess movement notations, in descending precedence. 
// For more info see http://en.wikipedia.org/wiki/Chess_notation
var AVAILABLE_NOTATIONS = {
    // Acronym: full name                               examples
    SAN:  "Standard Algebraic Notation",//              Bxc6        e5
    LAN:  "Long Algebraic Notation",//                  Bb5xc6      e7-e5
    MAN:  "Minimal Algebraic Notation",//               Bc6         e5
    RAN:  "Reversible Algebraic Notation",//            Bb5xNc6     e7-e5
    CRAN: "Concise Reversible Algebraic Notation",//    Bb5:Nc6     e75
    FAN:  "Figurine Algebraic Notation",//              ♗xc6        ♟e5
    ICCF: "ICCF Numeric Notation",//                    2536        5755
    coord:"Computer Coordinate Notation",// aka CCN     B5-C6       E7-E5
    smith:"Smith Notation",//                           b5c6n       e7e5
    descr:"English Descriptive Notation",// aka EDN     BxN         P-K4
    adesc:"Algebraic Descriptive Notation",//           BxN         P-e4
    raw:  "Fast Raw Notation"//                         /b5/c5/B    /e5/e7/p
};

// Notations to export with save_pgn(). The first notation is stored in
// the PGN move text, others in special tags.
// TODO: export all by default, but then only include these for email?
var EXPORT_NOTATIONS = [
    "SAN",
    "LAN",
    "MAN",
    "CRAN",
    "FAN",
    "ICCF",
    "coord",
    "smith",
    "descr",
    "adesc",
    "raw"
];

// Preferences, not game state.
var PREFS = {
    revert_time: 350,             // ms to take to revert

    input_notation: "SAN",

    // What piece images to use  - TODO: option to change
    image_set: "alfaerieomega",   // See README in that directory
    //image_set: "ariel",          // based on Ariel Unicode MS
    //image_set: "chessos",
    
    engine: "http://jeff.tk:81/chess/crafty.cgi",
    skill: 0,                   // engine strength, 0-100

    flipped: false,             // True if from black's perspective instead of white
    setup_mode: false,          // Setup pieces, instead of playing game

    saved_games_path: "games/",

    show_castling_impediments:false,    // Highlight squares preventing castling
    verbose_pgn:false,                  // Include extraneous PGN tags (CurrentFEN, Moves_[notations])
    variant_generator:null              // Setup function for randomized games

};

// Board display and drawing settings
var DISPLAY = {
    board_top:26,
    file_labels_top:19,
    file_labels_left:25,
    label_font:"12pt Gill Sans",
    board_left:20,
    rank_labels_left:10,
    rank_labels_top:4,
    board_border:2,

    // TODO: support smaller squares for larger boards like taikyoku shogi (3x36)? Since:
    // <rdar://problem/7128886> Cmd+ doesn't zoom canvas elements
    square_width:55,
    square_height:55,

    // Colors
 /* TODO: yellow - piece to promote
 * green - legal moves
 * red - blocked moves (when shift-hover), guarded squares
 * blue - move opponent just made
 */


   
    // Squares
    black:"#d18b47", white:"#ffce9e", // a pleasant tan

    // Use Applications/Utilities/DigitalColor Meter to get hex colors

    // From ExaChess
    //black:"#9999ff", white:"#ffffcc", // light blue
    //black:"#cc9966", white:"#ffdcab", // light brown
    //black:"#bbbbbb", white:"#eeeeee", // light gray
    //black:"#339933", white:"#eeeeee", // light green

    // From Chess with Friends (but has shadows)
    //black:"#8b8bb1", white:"#ecece7", // medium blue

    // Shredder, Yahoo Chess use textured boards
    // (would require images)
    

    //black:"#000000", white:"#ffffff",     // monochrome
    //black:"#00bb00", white:"#ffffcc",     // medium green (Wikipedia)
    //black:"#996600", white:"#cccc66",     // medium brown (ChessOS)

    // Highlighting of legal moves on mouseover
    legal_move_white: "seagreen",
    legal_move_black: "green",

    // Highlighting blocked moves on shift-mouseover
    blocked_move_white: "indianred",
    blocked_move_black: "firebrick",

    // Source move, when already moved a piece from this square, and mousing over when about to
    recent_move_white: "blue",
    recent_move_black: "blue",

    highlights: {},    // Color of legal move highlighted squares, for restoring color on drop over
    native_square_images:{}, // Image of square without any highlights (includes color and borders)

    text_color:"black",
    feature_border_width:3,

    canvas:null,        // The HTML canvas element
    context:null,       // 2D drawing context
    clean_board:null    // Image data of a clean, unmarked board
};


// Predefined game rules for rs EPD opcode, makes it more compact to store non-FIDE games
var RULE_SETS = {
    shatranj: { 
        uncheckered: true, 
        ruled: true, 
        stalemate: "win" 
    },

    // King moves three squares instead of two, useful for 8x10 board
    triple_castle: {
        castle_moves: {
            clong: {castle_to: 4, king_to: 3},
            cshort: {castle_to: 8, king_to: 9}
        },
    },

    // ... and four squares
    quad_castle: {
        castle_moves: {
            clong: {castle_to: 4, king_to: 3},
            cshort: {castle_to: 9, king_to: 8}
        },
    },


    // Xiangqi where pieces are on intersections
    xiangqi: {
        on_intersections:true,

        ranks:10, 
        files:9,
      
        // piece movement restrictions
        bounds1:"river,1,1,10,5,elephant", 
        bounds2:"palace,4,1,6,3,general,ferz",

        // Graphical board features to show piece movement restrictions
        features:[
            {fill:true, color:"lightblue", file:1, rank:5, width:9, height:5},      // background
            {over:true, fill: true, color:"lightblue", file:1, rank:6, width:9, height:1, shift_y:true}, // river

            // palace
            {cross:true, over:true, color:"black", file:4, rank:3, width:2, height:2, shift_y:true, shift_x:true},
        ],

        ruled:true,
        uncheckered:true
     },

     // "Westernized" Xiangqi, where pieces sit on squares
     xiangqiw: {
        ranks:10, 
        files:9,
      
        // piece movement restrictions
        bounds1:"river,1,1,10,5,elephant", 
        bounds2:"palace,4,1,6,3,general,ferz",

        // Graphical board features to show piece movement restrictions
        features:[
            // Karakus' Xiangqi westernization using lines and outlines to indicate features on a checkered board
            // http://www.chessvariants.com/xiangqi.dir/xiangqiwest.html
            // Draw these over the board (after the original lines are drawn)
            {over:true, color:"yellow", file:4, rank:3, width:3, height:3},    // palace
            {over:true, color:"blue", file:1, rank:5, width:9, height:5},      // river

            // Crockford's Xiangqi westernization using square color to indicate features on an uncheckered board
            // http://www.crockford.com/chess/xiangqi.html
            {fill:true, color:"same", file:1, rank:5, width:9, height:5},        // sides of river
            {fill:true, color:"opposite", file:4, rank:3, width:3, height:3},    // palace
        ],


        ruled:true,
        transparent:true
    }
};

// Info about the game
var GAME_STATE = null;
var GAME_STATE_DEFAULT = {
    // Whose turn it is
    active_color: '',
    
    // Castling privileges, keyed by file of castle (a or h for chess1)
    can_castle: {white: {}, black: {}},

    // Where the kings and castles are moved to when castling. 
    // Here, long means a-side (O-O-O) and short h-side (O-O).
    castle_moves: {
        clong: {castle_to: 4, king_to: 3},
        cshort: {castle_to: 6, king_to: 7}
    },

    ep_target: null,

    hmvc: 0,                    // Halfmove clock: Ply since last pawn advance / capture
    fmvn: 0,                    // Fullmove number: Increment after black moves

    position_moves: {},         // Board position -> move IDs, for 3n move repetition
    position_after: [],         // Board positions at each move, for quick playback
    made_moves: [],             // Piece, square and each move notation for past moves
    ended: false,               // Game is done (drawn, won)
    captured: {white:[], black:[]}, // Captured pieces

    boundaries: {},             // Board restrictions that bound piece movement
    transparent:false,          // Squares empty, otherwise are filled in
    uncheckered:false,          // Squares all white, otherwise alternating colors
    ruled:false,                // Squares have borders (useful for non-checkered boards)
    ranks:8,                    // Number of ranks
    files:8,                    // Number of files
 
    // Not game state, but other globals
    dragging: false,
    active_in_check: false,
    last_captured: null,        // export_captured() string _before_ current move 
    piece_under: null,          // Piece under cursor for piece inspector
    shift: false,               // Whether shift key is pressed
    update_custom: false,       // Whether custom movement field is focused and being typed in
    alert_assert: true          // Whether to alert assertion errors
};    

/// Drag and drop globals
var DRAG = 
{
    start_x: 0,
    start_y: 0,
    offset_x: 0,        
    offset_y: 0,
    element_m: null,    // what is being dragged by the mouse
    element_t: null,    // by the touch interface
    old_zindex: 0,      // z-index of dragging element to restore
    touching: false,    // whether something is being touched
    dragging: false     // whether a drag is in progress
};

var DROP = {
    area: {},           // box to detect drop areas in
    square: null,       // square dropping over 
    offboard: false     // whether dropping offboard or not
};

// Moves that can be made right now, for each active piece.
var VALID_MOVES = null;             // Keyed by filerank of source, array of moves, x, y and any flags
var IS_VALID_MOVE = null;           // Keyed by filerank of source, then filerank of dest
var BLOCKED_MOVES = null;           // Moves that would be valid except they're blocked
var VALID_MOVES_OPP = null;         // Moves opponent could make, if it was their turn (attacking)
var BLOCKED_MOVES_OPP = null;       // Opponent's blocked moves
var VALID_MOVE_NOTATIONS = null;    // Map SAN, LAN, MAN, RAN, CRAN, FAN, coord, desc, Smith etc. -> [piece, square]
var ALT_MOVE_NOTATIONS = null;      // Same as above, but non-canonical, longer forms (Nb1c3 when Nc3 would do, etc.)


// Board 
var SQUARES = null;                 // Get table cell square node by rank and file
var VBOARD = null;                  // Virtual in-memory board
var CLIPBOARD = null;               // ZeroClipboard instance

var AMP = String.fromCharCode(38);  // To avoid "not well-formed"

// Movement of pieces in extended Parlett notation
var PIECE_TYPES = {
    // Keys:
    // parlett: movement of piece in extended Parlett notation
    // letter: uppercase character representing the piece in FEN
    // alg_letter: uppercase character for algebraic notation [defaults to FEN letter]
    // figurines: [white, black] Unicode strings for Figurine Algebraic Notation
    // iccf_number: number for ICCF Numberic Notation
    // royal: if true, if checked, must make move that unthreatens, otherwise checkmate
    // resets_50move: if true, resets the counter for the 50-move rule (pawns)
    // castles_with: piece to move in conjunction with this piece if castling
    // castle: if true, this piece can be moved during castling
    // promote: array of piece names that this piece can promote to, in order of preference

    // Standard international chess piece
    
    // TODO: @ for absolute, @3,0 and @4,0 short, then @7,0 for @6,0, in order to allow
    // Chess960 orthodox castling when rooks &amp; kings are not at known positions.
    king: {parlett: "1*, " +     // or ~0/1, ~1/1
             "[3,0;absolute_x;if_can_castle=long], " +
             "[7,0;absolute_x;if_can_castle=short]",
          royal: true, letter: "K", figurines: ["\u2654", "\u265a"],
          castles_with: "rook", url:"pc:king"},
    queen: {parlett: "n*", letter: "Q", figurines: ["\u2655", "\u265b"], iccf_number: 1, url:"pc:queen"},
    rook: {parlett: "n+", letter: "R", castle: true, figurines: ["\u2656", "\u265c"], iccf_number: 2, url:"pc:rook", aka:["chariot", "car"]},
    bishop: {parlett: "nX", letter: "B", figurines: ["\u2657", "\u265d"], iccf_number: 3, url:"pc:bishop", aka:["courier"]},
    knight: {parlett: "~1/2", letter: "N", figurines: ["\u2658", "\u265e"], iccf_number: 4, url:"pc:knight"},


    // Pawns
    pawn: {parlett: 
        "o1>, c1X>, " + 
        "oi[0,2;if_unblocked=0,1;mark_ep_target=0,1], " +
        "[-1,1;if_ep_target;capture_at=-1,0], [1,1;if_ep_target;capture_at=-1,0]",

        image: "pawn",
        promote: ["queen", "knight", "rook", "bishop"],
        figurines: ["\u2659", "\u265f"],
        letter: "P",
        alg_letter: "",
        resets_50move: true,     // a pawn move resets the halfmove counter for the 50-move rule
        url: "pc:pawn"
    },
    optingpawn: {parlett:    // can make double-move on any rank
        "o1>, c1X>, " + 
        "o[0,2;if_unblocked=0,1;mark_ep_target=0,1], " +
        "[-1,1;if_ep_target;capture_at=-1,0], [1,1;if_ep_target;capture_at=-1,0]",
        promote: ["queen", "knight", "rook", "bishop"],
        url:"akm"
    },

    weakpawn: {parlett: "o1>, c1X>"},   // No double move, no promotion
    losalamospawn: {parlett: "o1>, c1X>", promote: ["queen", "rook", "knight"]},
    shatranjpawn: {parlett: "#weakpawn", promote:["ferz"], url:"http://en.wikipedia.org/wiki/Shatranj#Rules"},
    makrukpawn: {parlett: "#weakpawn", promote:["ferz"], promotion_rank:6, url:"http://en.wikipedia.org/wiki/Makruk#Pieces"},
    superpawn: {parlett: "on>, cnX>", letter: "XP", image:"quickpawn"},
    berolinapawn: {parlett: "o1X>, c1>, io2X>", letter: "XB", image:"berolinapawn", resets_50move: true, url:"pc:berolina"},
    //berolinapluspawn: {parlett: "#berolinapawn, c1=", url:"pc:berolina-plus"}, // TODO: image
    
    dragon: {parlett: "#pawn, #knight", image: ["dragon", "dragon2", "knightpawn", "pawnknight"], url:"pc:dragon"},   

    // David's pawn
    pawnattackrook: {parlett: "#pawn, c#rook", image:"pawn135cw", promote: ["dragon", "rookpawn"]},

    breakthru: {parlett: "o1>, 1X>", promote:["universal_leaper"], image:"pawn135ccw", url:"http://en.wikipedia.org/wiki/Breakthrough_(board_game)"},
    
    sergeant: {parlett: "#berolinapawn, #pawn", promote:["queen", "knight", "rook", "bishop"], resets_50move:true, url:"pc:sergeant", aka:["grazpawn"]},

    steward: {parlett: "o1+, c1X", aka:["fusilier", "quadrapawn", "walker"]},
    liapawn: {parlett: "o1>, o1=, c1X, io2>"},

    fiveriderpawn: {parlett: "#pawn", promote: ["rook", "bishop", "nightrider", "camelrider", "zebrarider"], url:"akm"},
    //freeleaperpawn: {parlett: "#pawn", promote: ["wazir", "knight", "zebra", "giraffe", "antelope"], url:"akm"}, // TODO: requires antelope
    ccpawn: {parlett: "#pawn", promote: ["archbishop", "bede", "waffle", "fad"]},
    rrpawn: {parlett: "#pawn", promote: ["chancellor", "r4", "woodyrook", "halfduck"]},
    nnpawn: {parlett: "#pawn", promote: ["colonel", "chargingrook", "fibnif", "chargingknight"]},
    pkpawn: {parlett: "#pawn", promote: ["pepperoni", "sausage", "mushroom", "meatball"]},
 

    // Hippogonal leapers
    man: {parlett: "1*", letter: "M", image:["mann2", "man", "guard", "wazirferz"], url:"pc:man"},    // same as king, but not royale (also known as commoner, guard)
    warmachine: {parlett: "~0/2", letter: "D", url:"pc:dabbabah"},  // or ~2+
    alfil: {parlett: "~2/2", letter: "Y", image:["elephant2", "elephantrev2", "elephant"], url:"pc:alfil"},       //  or ~2X
    threeheadmonster: {parlett: "~3/0", aka:"threeleaper"},
    bird: {parlett: "~3/3", letter: "XT", image:["bird", "bird2"], aka:"tripper"},
    camel: {parlett: "~1/3", letter: "W", image:["camel", "camel2", "camelrev2"], url:"pc:camel"},  // TODO: Timur's game
    zebra: {parlett:"~2/3", letter: "Z", url:"pc:zebra"},
    giraffe: {parlett: "~1/4", letter: "XG", url:"pc:giraffe"},
    fourleaper: {parlett: "~0/4",url:"http://www.ktn.freeuk.com/9a.htm#(2)"},
    //lancer: {parlett: "~2/4",url:"http://www.ktn.freeuk.com/9a.htm#(2)"}, // TODO: image
    //antelope: {parlett: "~3/4", url:"pc:antelope"},    // TODO: image
    //commuter: {parlett: "~4/4", url:"http://www.ktn.freeuk.com/9a.htm#(2)"}, // TODO: image
    //flamingo: {parlett: "~1/6", url:"pc:flamingo"},    // TODO: image
    bat: {parlett: "~1/8, ~7/4", url:"http://www.quadibloc.com/chess/ch0201.htm"},

    // Amphibians (combined leapers)
    squirrel: {parlett: "~0/2, ~1/2, ~2/2", letter: "S", url:"pc:squirrel"},
    frog: {parlett: "~1/1, ~0/3", letter: "F"},     
    duke: {parlett: "~0/2, ~1/1", url:"akm"},      // #ferz, #warmachine
    //bison: {parlett: "~1/3, ~2/3", url:"pc:bison"},                     // TODO: image (camel+antelope)
    gnu: {parlett: "~1/2, ~1/3", image:"knightcamel", url:"pc:gnus", aka:["wildebeest"]},
    //rootfiftyleaper: {parlett: "~5/5, ~7/1", url:"pc:root50"},         // TODO: image
    fiveleaper: {parlett: "~0/5, ~3/4", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"butterfly"},
    // TODO: root-65 leaper, bat, see http://members.shaw.ca/quadibloc/chess/ch03.htm
    //buffalo: {parlett: "~1/2, ~1/3, ~2/3", url:"pc:buffalo"},             // TODO: image
    //wazaba: {parlett: "~0/1, ~0/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    //diamond: {parlett: "~1/1, ~0/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    emperor: {parlett: "~0/1, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:"knightwazir"}, 
    knightwazir: {parlett: "#knight, #wazir"},
    prince: {parlett: "~1/1, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:["prince", "knightferz"]},
    templar: {parlett: "~0/2, ~1/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)", image:["templar2", "templar"]},
    //ferfil: {parlett: "~1/1, ~2/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    alibaba: {parlett: "~2*", letter: "L", image:"elephantwarmachine", url:"pc:alibaba"},   // or: #alfil, #warmachine = ~0/2, ~2/2
    // http://www.ktn.freeuk.com/9a.htm#(3) says caliph is ~0/1, ~2/2 (wazir + alfil), but Piececlopedia says it is camel+bishop
    hospitaler: {parlett: "~1/2, ~2/2", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    // http://www.ktn.freeuk.com/9a.htm#(3) says caliph is ~0/1, ~2/2 (wazir + alfil)
    //pterodactyl: {parlett: "~3/3, ~5/5, ~0/15", url:"http://www.ktn.freeuk.com/9a.htm#(3)"}, // TODO: image
    halfduck: {parlett: "~1/1, ~0/2, ~0/3", url:"http://www.chessvariants.com/d.betza/chessvar/dan/rookies.html", image:["greatwarmachinewazir"]}, 

    // Royal pieces
    royalknight: {parlett: "#knight", letter: "XR", royal: true, image:["bigknightking", "royalknight", "kingknight2"]}, 
    royalpawn: {parlett: "#pawn", royal: true},
    royalrook: {parlett: "#rook", royal: true},
    royalbishop: {parlett: "#bishop", royal: true},
    royalqueen: {parlett: "#queen", royal: true},
    maharajah: {parlett: "#amazon", letter: "XJ", royal: true, image:"paladin", url:"http://www.chessvariants.org/unequal.dir/maharaja.html"},   // Q+N+K, Maharajah chess TODO: crown amazon?
    supermaharajah: {parlett: "#amazon, #camel", royal: true, image:"supermaharajaschah"},
    kingpawn: {parlett: "#king, #pawn", royal: true},
    kingrook: {parlett: "#king, #rook", royal: true},

    // Generals from http://www.mayhematics.com/v/v_gm.htm
    // and some names from http://filer.case.edu/org/cwrums/games/chu-pieces.html#hiroku
    shogipawn: {parlett: "1>", url:"http://en.wikipedia.org/wiki/Shogi", aka:["soldier"]/*, promotion_rank:9*/}, // TODO: optional promotion

    // 1>, but when crosses "river", promotes and can move 1=
    chinesepawn: {parlett: "1>", url:"pc:pawn-xiangqi", promote:["advancedsoldier"], promotion_rank:6}, // TODO
    goose: {parlett: "o1X>", url:"akm", image:"goose"},
    swan: {parlett: "1X>", image:"ferzf"},
    drunk: {parlett: "1=", url:"akm", image:["pawn90cw", "pawn90ccw"]},
    sailor: {parlett: "1X<", image:["ship", "ferzb"], url:"akm"}, 
    backslider: {parlett: "1<", url:"akm"}, 
    //notcoppergeneral: {parlett: "1>, 1X>", url:"akm"},     // akm says can't move backwards, but shogi disagrees
    advancedsoldier: {parlett: "1>, 1=", url:"akm", aka:"drunkensoldier"},  // for Xiangqi after passing the river
    //ferzwazirhunter: {parlett: "1>, 1X<", url:"akm"}, // TODO: image
    //adjutant: {parlett: "1>, 1<", url:"akm", aka:["tsiu-yin", "chuuuin", "gobetween", "doublefootsoldier"]}, 
    //sidewinder: {parlett: "1X>, 1=", url:"akm"}, // TODO: image
    ferz: {parlett: "1X", letter: "XF", image:["ferz", "ferz2", "1bishop"], url:"pc:ferz", aka:["adviser", "firzin"]}, // or ~1/1
    //wazirferzhunter: {parlett: "1X>, 1<", url:"akm"}, // TODO: image
    drunkensailor: {parlett: "1=, 1X<", image:"shipinv", url:"akm"}, 
    //drunkenbackslider: {parlett: "1=, 1<", url:"akm", aka:["reversesoldier"]}, // TODO: image
    deserter: {parlett: "1<, 1X<", url:"akm", image:"pawninv"}, 
    //pikeman: {parlett: "1>, 1X>, 1=", url:"akm", image:"redpawn"}, // TODO: image
    silvergeneral: {parlett: "1>, 1X", url:"pc:silvergeneral",aka:["ginsho"]},
    coppergeneral: {parlett: "1=, 1X>, 1<", url:"http://filer.case.edu/org/cwrums/games/chu-pieces.html#dou", aka:["dousho"]}, 
    //drunkenmarine: {parlett: "1>, 1=, 1X<", image:"pinkpawn"}, // TODO: image
    wazir: {parlett: "1+", letter: "I", url:"pc:wazir", image:["wazir", "1rook2"]},    // or ~0/1
    //gorilla: {parlett: "1=, 1X<, 1<", url:"akm"}, // TODO: image
    //diabolo: {parlett: "1+, 1=", url:"akm"}, // TODO: image
    //yen: {parlett: "1X>, 1=, 1<", url:"akm"}, // TODO: image
    //invertedsilver: {parlett: "1X+, 1<", url:"akm"}, // TODO: image
    //drunkendeserter: {parlett: "1=, 1X<, 1<", url:"akm"}, // TODO: image
    drunkenelephant: {parlett: "1X, 1>, 1=", url:"akm", image:"drunkelephant", aka:["suizo"]},
    goldgeneral: {parlett: "1+, 1X>, 1=, 1<", url:"pc:goldgeneral", aka:["kinsho", "tokin"]},  // or: #wazir, [1,1], [-1,1]
    //crane: {parlett: "1+, 1>, 1<", url:"akm", aka:["horriblepanther", "mauhau", "mohyou", "ferciousleopard"]}, // TODO: image
    //drunkengorilla: {parlett: "1>, 1X<, 1=, 1<", url:"akm"}, // TODO: image
    blindtiger: {parlett: "1X, 1=, 1<", url:"akm", image:"moko_blindtiger", aka:["reversegold", "mouko"]}, 

    // Asymmetric generals
    rightpawn: {parlett: "[1,0]", image:"pawn45cw"},
    leftpawn: {parlett: "[-1,0]", image:"pawn45ccw"},

    "2moveferz": {parlett: "2X, 2+"},       // one move like a ferz, then another from that square
    "2movewazir": {parlett: "2+, 1*"},      // ..
    "2movewazirferz": {parlett: "#2moveferz, #2movewazir"},

    // Diminished pieces
    b3: {parlett: "nX.3"},
    b4: {parlett: "nX.4", image:["b4", "halfbishop"]},
    b4wazir: {parlett: "#b4, #wazir"},
    b4nd: {parlett: "#b4, #elephant", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/b4nd.html"},
    bw3: {parlett: "#b3, #wazir"},
    r2: {parlett: "n+.2", image:"1rook", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/shortrook.html"},
    r3: {parlett: "n+.3"},
    r4: {parlett: "n+.4", castle: true, image:["r4", "halfrook"]},
    //r5: {parlett: "n+.5", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/shortrook.html"}, // TODO: image
    //r6: {parlett: "n+.6", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/shortrook.html"}, // TODO: image
    fourfer: {parlett: "#r4, 1X", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/fr4.html"},
    narrowknight: {parlett: "[1,2], [1,-2], [-1,2], [-1,-2]"},
    wideknight: {parlett: "[2,1], [2,-1], [-2,1], [-2,-1]"},
    // Like knight, but can be blocked on orthogonal. 
    // Can almost do with this with n+.2\\45\\ or 1X(1+), but not quite (extra moves in intervening squares).
    // Would be really nice if could offset moves, blockable, in that way, though.
    mao: {parlett: "[1,2;if_unblocked=0,1], [-1,2;if_unblocked=0,1], " +
        "[2,1;if_unblocked=1,0], [2,-1;if_unblocked=1,0], " +
        "[1,-2;if_unblocked=0,-1], [-1,-2;if_unblocked=0,-1], " +
        "[-2,1;if_unblocked=-1,0], [-2,-1;if_unblocked=-1,0]",
        image:["mao", "horse"], url:"pc:mao", letter:"H"},
    moa: {parlett: "[1,2;if_unblocked=1,1], [2,1;if_unblocked=1,1], " +
        "[2,-1;if_unblocked=1,-1], [1,-2;if_unblocked=1,-1], " +
        "[-1,-2;if_unblocked=-1,-1], [-2,-1;if_unblocked=-1,-1], " +
        "[-2,1;if_unblocked=-1,1], [-1,2;if_unblocked=-1,1]"
    },
    moo: {parlett: "#mao, #moa", url:"http://chessvariants.wikidot.com/pcp-am:moo"}, 

    lord: {parlett: "1*", royal: true, url:"http://en.wikipedia.org/wiki/Shatranj#Rules", aka:["shah", "khun"]},  // like a king, but no castling 
    r4ferz: {parlett: "#r4, #ferz"},
    n2r4: {parlett: "#r4, 2(~1/2)"},
    alfilr4: {parlett: "#alfil, #r4"},
    mastodon: {parlett: "n*.2", url:"http://www.quadibloc.com/chess/ch0502.htm"},
    q3: {parlett: "n*.3"},
    q4: {parlett: "n*.4", image:["q4", "halfqueen"]},

    // Combined pieces (compound pieces)
    // TODO: aanca http://chessvariants.wikidot.com/pcp-aa:aanca
    // From piececlopedia http://www.chessvariants.org/index/mainquery.php?type=Piececlopedia&orderby=LinkText&displayauthor=1&displayinventor=1&usethisheading=Piececlopedia
    // or http://members.shaw.ca/quadibloc/chess/ch03.htm or 
    // http://www.chessvariants.com/graphics.dir/alfaerie/
    equesrex: {parlett: "#king, #knight", image:"equesrex", royal: true},
    //centaur: {parlett: "#knight, #man", url:"pc:centaur"},         // not royal, so not an equesrex  TODO: remove cross, make bcentaur.gif? also, ~0/1, ~1/1, ~1/2. K+N
    amazon: {parlett: "#queen, #knight", letter: "XV", url:"pc:amazon", aka:["superqueen"]},
    amazonrider: {parlett: "#queen, #nightrider", aka:["queenofthenight"]},
    //banshee: {parlett: "#bishop, #nightrider", url:"http://www.mayhematics.com/v/v_gm.htm"}, // TODO: image
    chancellor: {parlett: "#rook, #knight", letter: "C", image:["chancellor", "chancellor1", "empress2", "marshal2", "rookknight2"], url:"pc:rook-knight", aka:["empress", "marshal", "NR"]},   // R+N
    chancellorrider: {parlett: "#rook, #nightrider", aka:["raven"]},
    chancellorwazir: {parlett: "#chancellor, #wazir"},
    archbishop: {parlett: "#bishop, #knight", letter: "A", image: ["cardinal", "cardinal1", "cardinal2", "princess", "bishopknight2"], url:"pc:bishop-knight", aka:["cardinal", "princess", "janus", "NB"]}, // B+N
    archbishoprider: {parlett: "#archbishop, #nightrider", image:"cardinalrider"},
    cardinalferz: {parlett: "#archbishop, #ferz"},
    dragonhorse: {parlett: "#bishop, #wazir", image: "promotedbishop", url:"pc:dragonhorse"},
    //berse: {parlett: "#rook, #ferz", image: "promtoedrook", aka:["dragonking"]},    // TODO: image
    caliph: {parlett: "#camel, #bishop", image: "camelbishop", url:"pc:caliph"},
    pope: {parlett: "#king, #bishop", image:"kingbishop"},  // http://www.chessvariants.com/difftaking.dir/thunder.html 
    //dragonking: {parlett: "#king, #rook", royal: true, url:"pc:dragonking"},   // TODO: image

    alfilbishop: {parlett: "#alfil, #bishop"},
    bishoppawn: {parlett: "#bishop, #pawn"},
    crookedbishopwazir: {parlett: "#crookedbishop, #wazir"},
    duchess: {parlett: "#bishop, #warmachinerider", image:["duchess", "bishopwarmachinerider"], url:"http://www.mayhematics.com/v/v_gm.htm"},
    elephantwarmachine: {parlett: "#elephant, #warmachine"},
    elephantwarmachinewazir: {parlett: "#elephant, #warmachine, #wazir"},
    dayrider: {parlett: "#alfilrider, #warmachinerider", image:"elephantwarmachinerider", aka:["alibabarider"]},
    //duck: {parlett: "#ferz, #warmachinerider"},   // TODO: image
    rookpawn: {parlett: "#rook, #pawn"},
    knightwizard: {parlett: "#knight, #wizard", image:"horsezzmoon"},
    horsewazir: {parlett: "#honorablehorse, #wazir"},  
    guardknight: {parlett: "#knight, #man", image:["guardknight2", "guardknight"]}, 
    elephantwazir: {parlett: "#elephant, #wazir"},
    elephantferzwarmachine: {parlett: "#elephant, #ferz, #warmachine"},
    camelferz: {parlett: "#camel, #ferz", image:["camelferz", "camel2ferz"]},
    camelqueen: {parlett: "#camel, #queen"},
    camelwarmachine: {parlett: "#camel, #warmachine"},
    camelwazir: {parlett: "#camel, #wazir", image:["camelwazir", "camel2wazir"]},
    camelbishoprider: {parlett: "#camelrider, #bishop"},
    starrider: {parlett: "#camelrider, #knight, #antelope", url:"http://www.mayhematics.com/v/v_gm.htm", image:"knightzzstar"}, 
    camelpawn: {parlett: "#camel, #pawn"},
    camelwarmachinerider: {parlett: "#camel, #warmachinerider"},
    //camelopard: {parlett: "#camelrider, #fiveleaper", url:"http://www.mayhematics.com/v/v_gm.htm"}, // TODO: image
    crabalfil: {parlett: "#crab, #alfil"},
    crabwarmachine: {parlett: "#crab, #warmachine", image:"crabdabbaba"},
    crabferz: {parlett: "#crab, #ferz"},
    crabwazir: {parlett: "#crab, #wazir"},
    crabshortrook: {parlett: "#crab, #r4"},
    elephantcamel: {parlett: "#elephant, #camel"},
    elephantcamelrider: {parlett: "#elephant, #camelrider"},
    elephantferz: {parlett: "#elephant, #ferz", image:["elephantferz", "elephant2ferz"]},
    elephantferzrook: {parlett: "#elephant, #ferz, #rook"},
    elephantknight: {parlett: "#elephant, #knight"},
    elephantknightrider: {parlett: "#elephant, #nightrider"},
    elephantknightwazir: {parlett: "#elephant, #knight, #wazir"},
    elephantwizard: {parlett: "#elephant, #wizard", image:"elephantzzmoon"},
    //fibnifrook: {parlett: "#fibnif, #rook"}, // TODO: image
    genscher: {parlett: "#panda, #knight"},
    giraffeferz: {parlett: "#giraffe, #ferz"},
    giraffewazir: {parlett: "#giraffe, #wazir"},
    knightcamelzebra: {parlett: "#knight, #camel, #zebra"},
    knightwarmachineferz: {parlett: "#knight, #warmachine, #ferz", image:"knightdababaferz"},
    knightwazirwarmachine: {parlett: "#knight, #wazir, #warmachine"},
    rookwarmachine: {parlett: "#rook, #warmachine", image:"rookdabbaba"},
    rookelephantrider: {parlett: "#rook, #alfilrider"},
    narrowknightferz: {parlett: "#narrowknight, #ferz"},
    narrowknightwazir: {parlett: "#narrowknight, #wazir"},
    minister: {parlett: "#knight, #warmachine, #wazir", image:"nwd", url:"http://chessvariants.wikidot.com/pcp-am:minister"},
    //rhinocamel: {parlett: "#rhino, #camel"},
    //rhinocamelrider: {parlett: "#rhino, #camelrider"},
    //rhinozebra: {parlett: "#rhino, #zebra"},
    //rhinozebrarider: {parlett: "#rhino, #zebrarider"},
    //scorpion: {parlett: "#man, #grasshopper"}, 
    //scorpionpawn: {parlett: "#scorpion, #pawn"},
    squire: {parlett: "#man, #squirrel"},       // haha.. man + squirrel. Actually defined as 2 squares, any direction.
    queenalfilwarmachine: {parlett: "#queen, #alfil, #warmachine", image:"queenalfildabbaba3"},
    // TODO: herowarmachinewazir, lemurianwarmachinewazir, flexibleknight, linearchieftainjumpinggeneral, from http://chessvariants.wikidot.com/joe-s-strange-notation
    wazirwarmachinealfil: {parlett: "#wazir, #warmachine, #alfil", image:"wazirdababaalfil"},
    woodyrook: {parlett: "#warmachine, #wazir", image:"warmachinewazir", url:"http://www.chessvariants.com/d.betza/chessvar/dan/rookies.html", aka:["WD"]},
    warmachineriderwazir: {parlett: "#warmachinerider, #wazir"},
    warmachineferz: {parlett: "#warmachine, #ferz"},
    warmachineferzrider: {parlett: "#warmachinerider, #ferz"},
    wizardrider: {parlett: "#camelrider, #ferz", image:"moonrider"},
    //witch: {parlett: "#rook, #bishop, #nightrider, #camelrider, #zebrarider"}, // TODO: image
    zebracamel: {parlett: "#zebra, #camel"},
    zebracamelrider: {parlett: "#zebra, #camelrider"},
    zebraferz: {parlett: "#zebra, #ferz"},
    zebrawazir: {parlett: "#zebra, #wazir"},
    zebrawizard: {parlett: "#zebra, #wizard", image:"zebrazzmoon"},

    // Snipers (move like one piece, capture like another), from http://www.mayhematics.com/v/v_gm.htm
    roobis: {parlett: "o#rook, c#bishop", image:"frookbbishop", castle:true, url:"akm"},
    ensign: {parlett: "o#bishop, c#rook", image:"fbishopbrook", url:"akm", aka:["bishroo"]},
    rookni: {parlett: "o#rook, c#knight", image:"frookbknight", castle:true, url:"akm"},
    kniroo: {parlett: "o#knight, c#rook", image:"fknightbrook", url:"akm"},
    bishkni: {parlett: "o#bishop, c#knight", image:"fbishopbnight", url:"akm"},
    knibis: {parlett: "o#knight, c#bishop", image:"fknightbbishop", url:"akm"},
    // .. logical extensions
    kinkni: {parlett: "o#king, c#knight", image:"fkingbknight", royal:true, castles_with:"rook"},
    knikin: {parlett: "o#knight, c#king", image:"fknightbking", royal:true},
    knique: {parlett: "o#knight, c#queen", image:"fknightbqueen"},

    tiger: {parlett: "o#bishop, c#knight"},
    bede: {parlett: "#warmachine, #bishop", image:"bishopwarmachine", url:"pc:bd"},
    canvasser: {parlett: "#camel, #rook", image:"camelrook", url:"pc:canvassr"}, // yes, url is canvassr (no e)
    carpenter: {parlett: "#knight, #warmachine", image:"knightwarmachine", url:"pc:carpentr"},
    champion: {parlett: "#wazir, #alfil, #warmachine", url:"pc:champion"},
    //crownedrook: {parlett: "#rook, #ferz"},       // TODO: image
    crownedcamel: {parlett: "#camel, #ferz"},
    camelking: {parlett: "#camel, #king", image:["simplecamelking", "cbjcamelking", "tinyscamelking"]},
    // TODO: telepotency - can attack opposing general on same open file
    general: {parlett: "#wazir", royal: true, url:"pc:general", image:["general2", "general"], aka:["chineseking"]}, 
    kangaroo: {parlett: "#knight, #alfil", url:"pc:cangaroo"},  // Newton kangaroo, different than pc:kangaroo
    // http://www.mayhematics.com/v/v_gm.htm has a different definition of wizard
    wizard: {parlett: "#camel, #ferz", image:"moon",  url:"pc:wizard"},
    waffle: {parlett: "#wazir, #alfil", image:"elephantwazir", url:"pc:waffle", aka:["WA"]},
    fad: {parlett: "#ferz, #alfil, #warmachine", image:["elephantferzwarmachine"], url:"pc:fad"},
    bede: {parlett: "#bishop, #warmachine", image:"bishopwarmachine"},
    //zurafa: {parlett: "i#giraffe, #rook"}, // TODO: image, and no rook move on initial

    // More complex fairy / non-intl chess pieces
    // See http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples
    // and even better, Piecelopedia 
    // http://chessvariants.wikidot.com/pcp:piececlopedia
 
    //hornedfalcon: {parlett: "n=x, 2>"},    // from Parlett, TODO: image
    
    // Despite appearances, this is not ~1/2>, since that would allow also
    // allow the forward moves [2,-1] and [-2,1].
    honorablehorse: {parlett: "[-1,2], [1,2]", image:"shogiknight", url:"pc:shogiknight", aka:["kei", "keima"]},

    //chineseknight: {parlett: "1//2"}, // TODO: intervening must be unblocked
    lance: {parlett: "n>", url:"pc:lance", image:["lance", "lance1"], aka:["kyosha", "yari", "fragrantchariot"]},     // TODO: promote to hakku from http://filer.case.edu/org/cwrums/games/chu-pieces.html
    //reversechariot: {parlett: "n>, n<", url:"http://filer.case.edu/org/cwrums/games/chu-pieces.html#hansha", aka:["hansha"]}, // TODO: image

    //murray_lion: {parlett: "~0/2, ~2/2, c1*", letter: "XM"}, // TODO: image
    lion: {parlett: "~n*", letter: "XL", url:"pc:lion"},
    elephant: {parlett: "2X", letter: "E", image:["elephantmodern", "elephant1"], url:"pc:elephant", aka:["minister"]},  // Not a leaper, path can be blocked (unlike alfil, ~2X)
    //khohn: {parlett: "1X, 1>", letter: "XK"}, // TODO: image

    // TODO: support ~0/0 for "null move" (---), but don't let drop to null, instead show a button
    //kraken: {parlett: "~n/m ~0/0"},     // any square, not realistic since always checkmates! TODO: image
    //octopus: {parlett: "o~n/m ~0/0", letter: "XD"}, // any square (8x8, octo, get it?) but can't capture, much less powerful TODO: image
    universal_leaper: {parlett: "~n/m", image:"ubiubi"},// like kraken, but can't go to square it is on (like a zero) TODO: image
    allseeingeye: {parlett: "o~n/m", image:"allseeingeye2"},       // anywhere

    // Riders
    nightrider: {parlett: "~1/2&", letter:"XN", image:["nightrider", "knightinv"], url:"pc:knightrider"},  // Wikipedia says n(1/2), but Parlett says ~1/2&
    alfilrider: {parlett: "~2/2&", image:"elephantrider", aka:["skipbishop"]},
    //elephantrider: {parlett: "n(2X)", image:"elephantridermodern"}, // TODO: gets blocked
    warmachinerider: {parlett: "~2/0&", image:["warmachinerider","dababbarider"], aka:["skiprook", "dabbabarider"]}, 
    squirrelrider: {parlett: "n(#squirrel)"},
    crabrider: {parlett: "n(#crab)"},
    barcrider: {parlett: "n(#barc)"},
    //alibabarider: {parlett: "#alfilrider, #warmachinerider", aka:["skipqueen"]},    // TODO: image
    // TODO: slip-rook (panda), slip-bishop, slip-queen: omits second and every other even cell in path
    camelrider: {parlett: "~1/3&"},
    alibabariderferz: {parlett: "~2/0&, ~2/2&"},
    girafferider: {parlett: "~1/4&"},
    zebrarider: {parlett: "~2/3&"},

    // Projectiles
    airplane: {parlett: "#allseeingeye, {cn+<;snapback}", letter: "U", image:"plane"},  // drops bombs
    gun: {parlett: "o#man, {c#queen;snapback}"},            // able to walk around, powerful distance projectiles
    rocket: {parlett: "o<<1, o>>1, {~cn+>;snapback}"},    // shoots straight, not very mobile
    // Note: not the patented archer at http://www.google.com/patents?id=MLEWAAAAEBAJ&dq=5901957
    archer: {parlett: "o#bishop, {c#knight;snapback}"},     // quite mobile, but can't shoot very far
    archerzz2: {parlett: "o#rook, {c#knight;snapback}"},
    archerzz3: {parlett: "o#bishop, {c#squirrel;snapback}"},

    // Invincibles
    block: {parlett: "", invincible: true},
    // Stone is an invincible warmachinerider
    stone: {parlett: "~2/0&",
                    // Explicit notation, before had rider syntax
                    /*"[0,2], [0,4;if_unblocked=0,2], [0,6;if_unblocked=0,4], " +
                     "[2,0], [4,0;if_unblocked=2,0], [6,0;if_unblocked=4,0], " +
                     "[-2,0], [-4,0;if_unblocked=-2,0], [-6,0;if_unblocked=-4,0], " +
                     "[0,-2], [0,-4;if_unblocked=0,-2], [0,-6;if_unblocked=0,-4]",*/
                     invincible: true},
    fort: {parlett: "o#man", invincible: true},
    fortress: {parlett: "o#bishop", invincible: true},
    nwall: {parlett: "o1>, o1=", invincible: true},

    // Kamikaze pieces - disappear when making a capture 
    bomb: {parlett: "o1*, {c1*;self_destruct}", image:"medusa", invincible:true},
    superbomb: {parlett: "on*, {c~n*;self_destruct}", image:"gorgona"},

    // Pieces from chess-3
    // http://www.chessbase.com/newsdetail.asp?newsid=4553
    
    // rook + can move (not capture) like bishop
    tower: {parlett: "#rook, o#bishop", castle: true, letter: "T", image: "redrook"},  

    // knight + can move (not capture!) like wazir
    jous: {parlett: "#knight, o#wazir", letter: "J", image: "orangeknight"}, 

    // bishop + can move (not capture) 1 or 2 squares orthogonally
    vicar: {parlett: "#bishop, o2+", letter: "V", image: "yellowbishop"},

    // Ralph Betza's crazy pieces
    chargingrook: {parlett: "n+>=, 1<, 1X<", image:"forwardrookbackwardsprince", url:"http://www.chessvariants.com/unequal.dir/cwda.html", castle:true},
    fibnif: {parlett: "#ferz, [1,2], [-1,2], [1,-2], [-1,-2]", url:"pc:fibnif", image:"narrowknightferz"},
    chargingknight: {parlett: "~1/2>, 1<, 1=", image:"forwardknightbackwardsprince", url:"http://www.chessvariants.com/unequal.dir/cwda.html"},
    colonel: {parlett: "n>, n=, ~1/2>, 1*", letter: "XC", url:"http://www.chessvariants.com/unequal.dir/cwda.html", image:"forwardchancellorprince"},
    //furlrulbakking: {parlett: "n=, n>, 1<, 1<X", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/frlrrlbk.html"}, // TODO: image, from http://mafiascum.net/cgi-bin/wiki.pl/SandBox?
    //forfnifbakking: {parlett: "~1/2>, 1<, 1<X", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/fhnrlbk.html"}, // TODO: image, verify
    //forfnifurlrurking: {parlett: "~1/2>, n=, n>, 1*", url:"http://www.chessvariants.com/d.betza/chessvar/pieces/fhnfrlrk.html"}, // TODO: image
 
    // Hoppers
    //checker: {parlett: "cn(^2X)>, o1X>", url:"http://en.wikipedia.org/wiki/Fairy_chess_piece#Notations"}, // TODO: movement
    
    //cannon: {parlett: "on+, cn+^^", aka:["pao"]}, // TODO: movement. Like rook, but hops.
    //vao: {parlett: "onX, cnX^^"}, // TODO: movement. Like bishop, but hops.
    //leo: {letter: "XO", parlett: "on*, c^&", url:"http://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples"}, // TODO: locust movement, cn*^&?? cn*^^?. Like queen, but hops
    
    grasshopper: {parlett: "n*^", url:"http://en.wikipedia.org/wiki/Grasshopper_(chess)"}, // TODO: movement
   
    // Complex riders
    
    griffon: {parlett: "[1,0](n+>), [1,0](n+<), [0,1](n+>>), [0,1](n+<<), [-1,0](n+<), [-1,0](n+>), [0,-1](n+<<), [0,-1](n+>>)", 
        image:"gryphon", url:"pc:griffon"}, 

    panda: {parlett: "[0,-1](~2/0>&), [0,1](~2/0<&), [1,0](~2/0<<&), [-1,0](~2/0>>&)", image:["panda", "sliprook"], url:"http://www.chessvariants.org/unequal.dir/seeping-switchers.html"},

    slipbishop: {parlett: "[1,-1](~2/2↖&), [-1,-1](~2/2↗&), [-1,1](~2/2↘&), [1,1](~2/2↙&)"},
    slipqueen: {parlett: "#panda, #slipbishop"},

    crookedbishop: {parlett: "nX\\90,-90\\, nX\\-90,90\\", url:"pc:crookedbishop", image:["crookedbishop", "eaglescout"], aka:["hotdog"]}, 
    crookedrook: {parlett: "n+\\90,-90, n+\\-90,90\\"},
    crookedqueen: {parlett: "#crookedbishop, #rook", url:"pc:crooked-queen"},

    // Invented rotations
    galaxy: {parlett: "n+\\45\\", image:"horsezzstar"},
    nazi: {parlett: "nX\\45,0\\.3", image:"thief"},
    hitler: {parlett: "n*\\90,0,0\\", image:"theif2"}, // image name actually is misspelled

    // Explicit movements
    crab: {parlett: "[1,2], [-1,2], [-2,-1], [2,-1]", image: ["betzancrab", "crab2", "crab"], url:"pc:crab"},
    barc: {parlett: "[1,-2], [-1,-2], [-2,1], [2,1]", image: ["barc2", "barc"], url:"pc:barc"},
    mushroom: {parlett: "[-1,2], [1,2], [3,1], [-3,1], [1,-1], [1,-2], [-1,-1], [-1,-2]", url:"pc:mushroom"},
    sausage: {parlett: "1X, 1=, ~0/3<>, [1,2], [-1,2], [1,-2], [-1,-2]", url:"http://www.chessvariants.org/unequal.dir/pizza-kings.html", castle:true},
    pepperoni: {parlett: "2=, 1X, 1<, 1>, ~2/2>"},
    meatball: {parlett: "#ferz, #wazir, #alfil, #warmachine, [1,2], [-1,2]", url:"http://www.chessvariants.org/unequal.dir/pizza-kings.html"},

    
    // Pieces that probably won't be supported without significant coding
    // TODO: "darters", blockable 'leapers' - 1//2, elban knight, like mao and moa
    //checker: {parlett: "cn(^2X>), o1X>", promote: "checker_kinged", letter:"XY"},  // no grouping
    //checker_kinged: {parlett: "cn(^2X), o1x", letter:"XZ"},
    //spy: {parlett: "2>, 2=, (1/1)>", letter:"XS"}  // no grouping
    // pieces with no notation. WinChloe supports 1400 pieces.
    //
    // TODO: pieces from http://members.shaw.ca/quadibloc/chess/ch04.htm
   
    // TODO: Can go be supported? http://news.ycombinator.com/item?id=678145

    dummy: {parlett: "~0/0", letter: "O", image:"banner"},

    custom: {parlett: "", image: "hexagon"}
};

var DEFAULT_BOARD_GROUP = "Recognized";
var DEFAULT_BOARD_NAME = "FIDE Chess";

// Saved board setups in FEN
var SAVED_BOARDS = {
    // Recognized chesses, ordered roughly chronologically and/or increasing complexity
    // http://chessvariants.org/index/mainquery.php?type=Any&orderby=LinkText&displayauthor=1&displayinventor=1&showimages=1&showtextnotes=1&listrecognizedonly=1&primarylinksonly=1&usethisheading=Recognized+Chess+Variants
    "Recognized": {
// TODO: Indian Chess (Chaturanga)
// TODO: Support Chaturanga pawns. No double move/en passant, and promotes to where started, but only if piece was captured.
// Stalemate / bare king = win for stalemating player,
//"Indian Chess (Chaturanga)": "rnekxfenr/pppppppp/8/8/8/8/PPPPPPPP/RNEKXFENR w - statemate=win",

// Shatranj (2nd known variant), except that this rule is not implemented:
// - Taking the last piece of your opponent wins, unless your opponent
//    can take your last non-king piece too, in which case the game is drawn
// Note that K v. K will result in a "draw by insufficient material" anyway, and
// bareing the king will often result in a win eventually.
// aka Iranian Chess, http://www.garagegames.com/community/blogs/view/17595
"Iranian Chess (Shatranj)":     "rnyx(lord)xfynr/x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)x(shatranjpawn)/8/8/8/8/X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)X(shatranjpawn)/RNYX(lord)XFYNR w - - rs=shatranj",

// TODO: Tamerlane Chess, Timur's game, http://en.wikipedia.org/wiki/Tamerlane_Chess and http://www.pathguy.com/chess/Tamerlan.htm http://filer.case.edu/org/cwrums/games/tamerlane.html
// TODO: Korean Chess (Changgi)
// TODO: Omega Chess
// TODO: Japanese Chess (Shogi), see http://www.crockford.com/chess/shogi.html
// TODO: Minishogi, 5x5 board, http://en.wikipedia.org/wiki/Minishogi

// Chinese Chess (Xiangqi),
"Chinese Chess (Xiangqi) (w/o cannons)": "rx(mao)ex(ferz)x(general)x(ferz)ex(mao)r///x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)///X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)///RX(mao)EX(ferz)X(general)X(ferz)EX(mao)R w - - rs=xiangqi",

"Chinese Chess (Xiangqi, Westernized) (w/o cannons)": "rx(mao)ex(ferz)x(general)x(ferz)ex(mao)r///x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)1x(chinesepawn)///X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)1X(chinesepawn)///RX(mao)EX(ferz)X(general)X(ferz)EX(mao)R w - - rs=xiangqiw",

// Counting rules on http://en.wikipedia.org/wiki/Makruk are not implemented
"Thai Chess (Makruk)": "rnx(silvergeneral)x(ferz)x(lord)x(silvergeneral)nr/8/x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)x(makrukpawn)/8/8/X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)X(makrukpawn)/8/RNX(silvergeneral)X(lord)X(ferz)X(silvergeneral)NR w - -",
"FIDE Chess": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -",
"Chess960": setup_chess960,
// TODO: pawns promote to rook,knight,queen, no double-move
"Los Alamos Chess": "rnqknr/x(losalamospawn)x(losalamospawn)x(losalamospawn)x(losalamospawn)x(losalamospawn)x(losalamospawn)/6/6/X(losalamospawn)X(losalamospawn)X(losalamospawn)X(losalamospawn)X(losalamospawn)X(losalamospawn)/RNQKNR w - - ranks=6 files=6",
"Capablanca Chess": "rnabqkbcnr/pppppppppp/8/8/8/8/PPPPPPPPPP/RNABQKBCNR w AJaj - files=10 stalemate=win rs=triple_castle",
"Berolina Chess": "rnbqkbnr/xbxbxbxbxbxbxbxb/8/8/8/8/XBXBXBXBXBXBXBXB/RNBQKBNR w KQkq -",
"Courier Chess": "rnybmkxfibynr/x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)x(weakpawn)/////X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)X(weakpawn)/RNYBMKXFIBYNR w - - files=12 ranks=8",
// Note that in this implementation, only 4-move castling is supported, but chessvariants.com describes how one, two, three, or four is supported.
"Wildebeest Chess": "rnwwx(gnu)kqbbnr/ppppppppppp///////PPPPPPPPPPP/RNWWX(gnu)KQBBNR w AKak - files=11 ranks=10 stalemate=win rs=quad_castle shredder_castle"
//"Taikyoku Shogi": "/ w - - ranks=36 files=36",
// TODO: Modern variants
// Ultima

    },

    "Randomized": {
"Chess960": setup_chess960,
"Chess256": setup_chess256,
"D-Chess (swap manually)": setup_dchess
    },

    "New Pieces": {
"Amazon Chess":         "rnbxvkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBXVKBNR w KQkq -",
// http://en.wikipedia.org/wiki/Breakthrough_(board_game)
// TODO: Win if promote.. have a universal leaper, but there is nothing to checkmate.
"Breakthrough": "x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)/x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)x(breakthru)/8/8/8/8/X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)/X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru)X(breakthru) w - - uncheckered",
"Commoner Chess":     "rnbqmbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQMBNR w KQkq -",
"Knightmate Chess":    "rmbqxrbmr/pppppppp/8/8/8/8/PPPPPPPP/RMBQXRBMR w KQkq -",
// A winning line of play for the roaylty pieces, from _The Oxford History of Board Games_ by David Parlett, pg. 192, regardless of the moves for the maharajah:
// a4 a5 a6 a7 e3 Nh3 Nf4 Bd3 O-O Qh5 Nc3 Ncd5 Ra6 b4 h3 (if M on g7) Bb2 Rfa1 Re6 Rae6 (I think this is supposed to be Raa6) Re7 Rae6 and mate the on the next move
"Maharajah and the Sepoys (black)":     "4xj3/8/8/8/8/8/PPPPPPPP/RNBQKBNR w KQ -",
// TODO: No black pawn promotion
"Maharajah and the Sepoys (white)":     "rnbqkbnr/pppppppp/8/8/8/8/8/4XJ3 w kq -",
"Milener's Chess-3 (non-random)": "rnbqkvjt/pppppppp/8/8/8/8/PPPPPPPP/RNBQKVJT w KQkq -",
"Nightrider Chess I": "r1bx(nightrider)kb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BX(nightrider)KB1R w KQkq -",
"Nightrider Chess II": "rx(nightrider)bqkbx(nightrider)r/pppppppp/8/8/8/8/PPPPPPPP/RX(nightrider)BQKBX(nightrider)R w KQkq -",
"Fox and Geese": "8/8/8/4x(ferz)/5X(goose)/2X(goose)1X(goose)/3X(goose) w - -", // geese win by stalemating fox, solution at http://www.mayhematics.com/v/v_gm.htm
// http://hem.passagen.se/melki9/royalpawn.htm
"Royal Pawn Chess": "rnbqmbnr/ppppx(royalpawn)ppp/8/8/8/8/PPPPX(royalpawn)PPP/RNBQMBNR w - -",
"Sniper Chess": "x(rookni)x(kniroo)x(bishkni)qkx(bishroo)x(knibis)x(roobis)/pppppppp/8/8/8/8/PPPPPPPP/X(rookni)X(kniroo)X(bishkni)QKX(bishroo)X(knibis)X(roobis) w KQkq -",

    //"Chess with Different Armies": {
// Chess with Different Armies http://www.chessvariants.com/unequal.dir/cwda.html
// TODO: Choose each? Colorbound Clobberers vs. Remarkable Rookies, randomized, etc.
// TODO: new pawns to promote to pieces on each board
"Colorbound Clobberers": "x(bede)x(waffle)x(fad)x(archbishop)kx(fad)x(waffle)x(bede)/x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)x(ccpawn)/8/8/8/8/X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)X(ccpawn)/X(bede)X(waffle)X(fad)X(archbishop)KX(fad)X(waffle)X(bede) w KQkq -",
"Remarkable Rookies": "x(r4)x(woodyrook)x(halfduck)ckx(halfduck)x(woodyrook)x(r4)/x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)x(rrpawn)/8/8/8/8/X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)X(rrpawn)/X(r4)X(woodyrook)X(halfduck)CKX(halfduck)X(woodyrook)X(r4) w KQkq -",
"Nutty Knights": "x(chargingrook)x(fibnif)x(chargingknight)x(colonel)kx(chargingknight)x(fibnif)x(chargingrook)/x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)x(nnpawn)/8/8/8/8/X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)X(nnpawn)/X(chargingrook)X(fibnif)X(chargingknight)X(colonel)KX(chargingknight)X(fibnif)X(chargingrook) w KQkq -",

"Amazon Army": "x(r4)nbxvkbnx(r4)/pppppppp/8/8/8/8/PPPPPPPP/X(r4)NBXVKBNX(r4) w KQkq -",
/// TODO: Cylindrical Cinders, fighting fizzes, etc.
/// http://en.wikipedia.org/wiki/Chess_with_different_armies#cite_note-2
// http://www.chessvariants.org/unequal.dir/pizza-kings.html
"Pizza Kings": "x(sausage)x(mushroom)x(pepperoni)x(meatball)kx(pepperoni)x(mushroom)x(sausage)/x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)x(pkpawn)/8/8/8/8/X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)X(pkpawn)/X(sausage)X(mushroom)X(pepperoni)X(meatball)KX(pepperoni)X(mushroom)X(sausage) w KQkq -"
    },

    "Miniature Variants": {
// See Parlett, pg. 317-318. Not all of the rules might be correct.
"7x7 Microchess-49 (Paletta, 1980)": "rbnknbr/ppppppp/7/7/7/PPPPPPP/RBNKNBR w KQkq - files=7 ranks=7",
"6x8 Microchess-48 (Paletta, 1980)": "rnqknr/1b2b/pppppp///PPPPPP/1B2B/RNQKNR w KQkq - files=6 ranks=8",
"6x6 Diana (Hopwood, 1870)": "rbnkbr/pppppp///PPPPPP/RNBKBR w KQkq - files=6 ranks=6",
"6x6 Compact Chess (Dean-Smith, 1988)": "rnkqnr/bppppb/pp2pp/PP2PP/BPPPPB/RNKQNR w KQkq - files=6 ranks=6",
"6x6 Lilliputian Chess (Dekle, 1986)": "raqkar/pppppp///PPPPPP/RAQKAR w KQkq - files=6 ranks=6",
"5x6 Petty Chess (Walker, 1930)": "qkbnr/ppppp///PPPPP/QKBNR w KQkq - files=5 ranks=6",
"8x4 Chi-Chi's Chess (Hackenberg, 1968)": "rnbqkbnr/p1ppp2p/P1PPP2P/RNBQKBNR w KQkq - files=8 ranks=4",
"5x5 Baby Chess (Gardner, 1989)": "kqbnr/ppppp//PPPPP/RNBQK w KQkq - files=5 ranks=5",
"5x5 Minichess (AISE, 1978)": "kqbnr/ppppp//PPPPP/KQBNR w KQkq - files=5 ranks=5",
"5x5 Minichess (Jacobs, 1983)": "bnrqk/ppppp//PPPPP/KQNBR w KQkq - files=5 ranks=5"
// See Parlett, pg. 319 for the rules. 
// pawns: may advance 2 squares initially
// knights: two or three squares, jumping if necessary
// bishops: move only on square of own color, ignoring those on the other
// kings: one or two squares
// castling: changing places
//"One-Dimensional Chess (Glimne)": "kqrbbnp4PNBBRQK w - - files=18 ranks=1",
    },

    "Orthodox Variants": {
// Standard chess and variants using no new pieces.  
// Sources:
// http://www.pathguy.com/chess/ChessVar.htm
// http://www.chessclub.com/helpcenter/tips/wild.html
"Advance Chess":        "rnbqkbnr/8/pppppppp/8/8/PPPPPPPP/8/RNBQKBNR w KQkq -",
"Atheist Chess": "rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RN1QK1NR w KQkq -",
"Church Chess":         "bbbbkbbb/pppppppp/8/8/8/8/PPPPPPPP/BBBBKBBB w - -",
"Corner Chess":         "4rbqk/4rb1q/4r1bb/5rrr/RRR5/BB1R4/Q1BR4/KQBR4 w - -",
"Corner Chess II":      "kbp2pbq/nrp2prn/pp4pp/8/8/PP4PP/NRP2PRN/QBP2PBK w - -",
"Corridor Chess":       "1nrqkrn1/2b2b2/1pppppp1/8/8/1PPPPPP1/2B2B2/1NRQKRN1 w - -",
"Black Begins": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR ? KQkq -",
"Desegregated Chess": "RNbqKBnr/ppPpPPPp/8/8/8/8/PPpppPpP/rnBQkBnr w KQkq -",
"Dunsany's Chess": "rnbqkbnr/pppppppp/8/8/PPPPPPPP/PPPPPPPP/PPPPPPPP/PPPPPPPP w kq -",
"Eight Kings Chess":    "kkkkkkkk/pppppppp/8/8/8/8/PPPPPPPP/KKKKKKKK w - -",
"Fianchetto Chess":     "bnrqkrnb/pppppppp/8/8/8/8/PPPPPPPP/BNRQKRNB w KQkq -",
"Fortress Chess":       "rnbqkbnr/pppppppp/ppp4/8/8/5PPP/PPPPPPPP/RNBQKBNR w KQkq -",
// TODO: White wins if captures all black's pieces
"Horde Chess":          "ppp2ppp/pppppppp/pppppppp/pppppppp/3pp3/8/PPPPPPPP/RNBQKBNR w KQ -",
"Knight Odds Chess":   "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/R1BQKBNR w KQkq -",
"Marxist Chess (DLS-CSB)":       "8/pppppppp/8/8/8/8/PPPPPPPP/8 w - -",
"Marxist Chess (2x)":       "pppppppp/pppppppp/8/8/8/8/PPPPPPPP/PPPPPPPP w - -",
"Missionary Chess": "pppppppp/ppppqppp/8/8/4K3 w - -",
"Mind Chess": "8/8/8/8/8/8/8/8 w - -",
// chess-3 http://www.chessbase.com/newsdetail.asp?newsid=4553
// TODO: 48 unique setups
"Mongredian Chess":    "rbbqknnr/pppppppp/8/8/8/8/PPPPPPPP/RBBQKNNR w - -",
"Obama Chess": "rnbqKbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQkBNR b KQkq -",
"Pawn's Game Chess": "rnbqkbnr/pppppppp/8/8/2PPPP2/1PP2PP1/PPPPPPPP/RNB1KBNR w KQkq -",
"Pawn Massacre Chess": "RNBQKBNR/pppppppp/8/8/8/8/PPPPPPPP/rnbqkbnr w KQkq -",
"Pawn Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPP1PP/RNBQKBNR w KQkq -",
"Pawnless Chess":      "rnbqkbnr/8/8/8/8/8/8/RNBQKBNR w KQkq -",
"Peasant's Revolt Chess I":"1nn1knn1/4p3/8/8/8/8/PPPPPPPP/4K3 w - -",
"Peasant's Revolt Chess II":"1nn1k1n1/4p3/8/8/8/8/PPPPPPPP/4K3 w - -",
"Peasant's Revolt Chess III":"1n2k1n1/2p1p3/8/8/8/8/PPPPPPPP/4K3 w - -",
"Power Chess / Wild 18":"qqqqkqqq/pppppppp/8/8/8/8/PPPPPPPP/QQQQKQQQ w - -",
"Power Chess II":       "rrbqkbrr/bbnnnnbb/pppppppp/8/8/PPPPPPPP/BBNNNNBB/RRBQKBRR w - -",
"Queen Odds Chess":    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNB1KBNR w KQkq -",
"Reverso Chess":        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBKQBNR w KQkq -",
"Revolt Chess": "pppppppp/rnbqkbnr/8/8/8/8/RNBQKBNR/PPPPPPPP w KQkq -",
"Republican Chess": "rnb2bnr/pppppppp/8/8/8/8/PPPPPPPP/RNB2BNR w - -",
"Rook Odds Chess":     "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/1NBQKBNR w KQkq -",
"Royal Stables Chess":  "nnnnknnn/pppppppp/8/8/8/8/PPPPPPPP/NNNNKNNN w - -",
"Survival Chess": "nnnpnpnn/pppnnnpn/nppppppp/np4pn/np2P1pn/pp4pn/nppppppp/nnpnnnpn w - -",
"Stalemate Wins": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - stalemate=win",
"Twin Chess":           "rbqkkqbr/pppppppp/n6n/8/8/N6N/PPPPPPPP/RBQKKQBR w - -",
"Twin Chess B":         "nkbqqbkn/r2pp2r/pppppppp/8/8/PPPPPPPP/R2PP2R/NKBQQBKN w - -",
"Upside-Down Chess / Wild 5":    "RNBQKBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbqkbnr w KQkq -",
"Vegetarian Chess": "r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/R1BQKB1R w KQkq -",
"Weak! / Seven Knights Chess":  "nnnnknnn/pppppppp/2p2p2/1pppppp1/8/8/PPPPPPPP/RNBQKBNR w - -",
"Wild Chess 7 ":        "4k3/5ppp/8/8/8/8/PPP5/3K4 w - -",
"Wild Chess 8":         "rnbqkbnr/8/8/pppppppp/PPPPPPPP/8/8/RNBQKBNR w KQkq -",
"Wild Chess 19":        "8/6k1/4p3/4N3/8/6K1/7N/8 w - -"
    },

    "Chess Openings": {
    },

    "Test Pieces": {
"Test Pawns": "8/x(rookpawn)x(dragon)x(bishoppawn)x(superpawn)x(weakpawn)x(berolinapawn)x(pawnattackrook)//2x(steward)4X(optingpawn)/4X(sergeant)1X(liapawn)/8/X(rookpawn)X(dragon)X(bishoppawn)X(superpawn)X(weakpawn)X(berolinapawn)X(pawnattackrook)P w - -",
"Test Leapers": "K/2E1Y1H1/3M/1XT1W1XG1Z/8/3Z1N/4oo/5k w - -", // TODO: antelope, flamingo
"Test Riders": "B2R4/5X(barcrider)2/4Q3/4XN3/2X(alibabariderferz)3X(stone)1/3X(crabrider)1X(warmachinerider)X(squirrelrider)1/2X(alfilrider)X(camelrider)2X(zebrarider)1/4X(girafferider)3 w - - 0 1",
"Test Complex Riders": "1X(crookedbishop)/8/3X(dummy)/4X(griffon)/7X(panda)//5X(slipbishop) w - -",
"Test Complex Riders I": "8/8/8/8/4X(crookedrook) w - -",
"Test Hoppers": "///4X(grasshopper)kx(dummy)//4X(dummy) w - -",
"Test Chinese Pieces": "8/8/8/3X(moa)X(moo)/3x(mao)X(mao)3/8/8/8 w - -",
"Test Amphibians": "4k/8/8/slslslsl/8/8/FFFFFFFF/4K w - -",
"Test Royalty": "x(royalrook)x(royalknight)x(royalbishop)xjkx(royalbishop)x(royalknight)x(royalrook)/pppppppp/8/8/8/8/PPPPPPPP/X(royalrook)X(royalknight)X(royalbishop)XJKX(royalbishop)X(royalknight)X(royalrook) w KQkq -",
"Test Projectiles": "x(airplane)X(airplane)4x(airplane)/X(allseeingeye)/1x(bird)/2x(bird)x(bird)x(bird)1x(bird)/3x(bird)x(bird)/3X(archerzz3)x(bird)/4X(archerzz2)X(archer)/x(frog)1X(gun)3X(rocket) w - -",
"Test Invincibles": "3x(dummy)x(dummy)/7x(nwall)/x(dummy)3x(block)1X(fortress)/4K3/5x(stone)X(fort)/8/1kX(block)1X(stone)/1X(block)x(block)3X(nwall) w - -",
"Test Consumables": "4k/pppppppp/1pppppp1/2pppp2/X(bomb)2X(superbomb)/8/PPPPPPPP/4K w - -",
"Test Diminished": "/1X(b4)5X(q4)//4X(b3)//3X(r3)X(honorablehorse)/2X(r4)/7X(q3) w - -",
"Test Mix 1": "X(airplane)x(airplane)/3x(pawnattackrook)x(caliph)x(pope)X(elephantwarmachine)/8/8/8/4S/X(lance)fwZ1X(pawnattackrook)/AcDeIFvT w - -",
"Test Mix 2": "//2/1X(silvergeneral)2X(mushroom)/3X(crab)X(wizard)/4X(barc)1X(goldgeneral)//7m w - -",
"Test Mix 3": "x(zebracamel)//3X(2moveferz)//3X(bishop)1X(2movewazirferz)/2X(2movewazir) w - -",
"Test Custom": "8/8/8/8/4X(custom)/8/8/8 w - -"
    },

    "Test Rules": {
"Test Checkmate": "r1bknbrN/pppppppp/8/8/8/8/PPPPPPPP/nRBNKB1R b - -",
"Test Stalemate":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmnv=5",
"Test Stalemate (win)":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmvn=5 stalemate=win",
"Test Stalemate (half-win)":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmvn=5 stalemate=halfwin",
"Test Stalemate (loss)":     "k7/2Q5/8/8/p7/1P6/8/8 w KQkq - fmvn=5 stalemate=loss",
"Test Remove Check by Capture":     "4k3/1p6/2Q5/8/8/8/8/7K b - - 0 5",
"Test Promotion":     "K/1X(fiveriderpawn)1X(ccpawn)X(rrpawn)X(nnpawn)X(pkpawn)/8/PX(makrukpawn)/5X(makrukpawn).X(chinesepawn)/8/pppppppp/7k w - -",
"Test Promotion to Rook": "8/k1P5/p7/P3K3/8/8/8/8 w - - 0 53", // from http://chessteacher.110mb.com/2008/10/22/minor-promotion/
"Test Promotion to Bishop": "8/5P1k/5K1p/7P/8/8/8/8 w - - 0 51",
"Test En Passant (alone)":     "8/8/8/3pP3/8/8/8/8 w - d6",
"Test En Passant":     "rnbqkbnr/ppp2ppp/8/3pP3/3Qn/5N2/PPP2PPP/RNB1KB1R w KQkq d6 0 5",
"Test En Passant into Check": "qk6/8/8/3pP3/8/8/8/7K w - d6 0 5",
"Test Lone King": "K w KQkq -",
"Test K + K":     "k7/8/K7/8/8/8/8/8 b - - 0 30",
"Test K + KQ":     "k7/8/8/8/8/8/8/5KQ1 w - d6 0 50",
"Test K + KR":     "k7/8/8/8/8/8/8/5KR1 w - d6 0 50",
"Test K + KB":     "k7/8/K7/8/8/8/8/B b - - 0 30",
"Test K + KN":     "k7/8/K7/8/8/8/8/N b - - 0 30",
"Test KB + KB opposite colors":     "k7/8/K7/8/8/8/b/B b - - 0 30",
"Test KB + KB same colors":     "k7/8/K7/8/8/8/3b/B b - - 0 30",
"Test KBB + KBB same colors":     "k7/8/K7/8/8/8/3b1b/B3B b - - 0 30",
"Test KBB + KBB opposite colors":     "k7/8/K7/8/8/8/3b1b/B2B b - - 0 30",
"Test Castling K/Q": "1k/8/8/8/8/8/8/R3K2R w KQ -",
"Test Castling Unable": "1k/8/8/8/8/8/8/R3K2R w - -",
"Test Castling Through Check Short":     "1k3r/8/8/8/8/7Q/8/R3K2R w KQ -",
"Test Castling Through Check Long":     "1k1r/8/8/8/8/7Q/8/R3K2R w KQ -",
"Test Castling Not Through Check (Rook)":     "1r/3k/8/8/8/5Q/8/R3K2R w KQ -",
"Test Castling Through Check (pawn)": "rnbqkbnr/pppp2pp/8/6N1/4p3/3B4/PPPP2pP/RNBQK2R w KQkq - 0 7",
"Test Castling out of Check":     "4r3/8/8/8/8/8/8/R3K2R w KQ -",
"Test Castling A/H king B": "1k/8/8/8/8/8/8/RK5R w AH -",
"Test Castling A/H king C": "1k/8/8/8/8/8/8/R1K4R w AH -",
"Test Castling A/H king D": "1k/8/8/8/8/8/8/R2K3R w AH -",
"Test Castling A/H king E": "1k/8/8/8/8/8/8/R3K2R w AH -",
"Test Castling A/H king F": "1k/8/8/8/8/8/8/R4K1R w AH -",
"Test Castling A/H king G": "1k/8/8/8/8/8/8/R5KR w AH -",
"Test Castling D/F king E": "1k/8/8/8/8/8/8/3RKR w DF -",
"Test Castling B/D king C": "7k/8/8/8/8/8/8/1RKR w BD -",
"Test Castling w/ Intervening Pieces":     "1k/8/8/8/8/8/8/R3KQ1R w KQ -",
"Test Only Move ":     "rnbqkbnr/ppp2ppp/8/8/8/8/PPP2PPP/RNBQKBNR w KQkq -",
"Test Disambiguation by File":     "k7/8/8/8/8/8/3N4/6N1 w - -",
"Test Disambiguation by Rank":     "k7/8/8/6N1/8/8/8/6N1 w - -",
"Test Disambiguation by File+Rank":     "k7/8/8/4N1N1/3N3N/8/3N3N/4N1N1 w - -",
"Test Disambiguation w/ 8 Queens": "3Q4/6q1/2Q5/7q/1Q6/4q3/7Q/5q2 w - -",
"Test vboard Check-Checking": "8/8/R2k2p1/3n1bp1/1p6/1P3P1P/5KP1/8 b - - 0 36",
"Test Getting out of Check": "rnbqkbnr/ppp1p1pp/4P3/3p3Q/5p2/8/PPPP1PPP/RNB1KBNR b KQkq - 0 4",
"Test Check Checking": "rnbQ1bnr/ppp1kppp/8/4p3/7q/8/PPPP1PPP/RNBQKBNR b KQ - 0 5",
"Test Parlett Move Interference": "r/8/8/1N3b2/3PP3/1P1BBN/8/8 w - - 0 17",
"Test Captures": "8/MMMMMMMM/mmmmmmmm/8/QQQQQQQQ/qqqqqqqq/NNNNNNNN/xlxlxlxlxlxlxlxl w - -",
"Test Guarding": "8/8/8/2P/3P/4B/3P/ w KQkq -",
"Test Extended Position Description": "r/8/8/1N3b2/3PP3/1P1BBN/8/8 w - - hmvc=0 fmvn=17",
"Test Bare King": "///4k//p/1P w - -"
    }
};

// Opening positions along with extended ECO codes and common names
// Extended ECO codes are from scid.eco, see http://scid.sourceforge.net/help/ECO.html
//  and http://scid.sourceforge.net/help/EPD.html
// These are listed keyed by FEN without move information, so they can be recognized
// directly from the board position, rather than the move history, allowing for easier
// transposition.
var OPENINGS = {
    // 0th level
    "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -": "A00a Standard Start Position",

    // 1st level
    "rnbqkbnr/pppppppp/8/8/8/P7/1PPPPPPP/RNBQKBNR b KQkq -": "A00f Anderssen Opening",
    "rnbqkbnr/pppppppp/8/8/P7/8/1PPPPPPP/RNBQKBNR b KQkq a3": "A00e Ware Opening / Meadow Hay",
    "rnbqkbnr/pppppppp/8/8/8/N7/PPPPPPPP/R1BQKBNR b KQkq -": "A00h Durkin Opening / Sodium Attack",
    "rnbqkbnr/pppppppp/8/8/8/2N5/PPPPPPPP/R1BQKBNR b KQkq -": "A00l Van Geet (Dunst) Opening",
    "rnbqkbnr/pppppppp/8/8/8/1P6/P1PPPPPP/RNBQKBNR b KQkq -": "A01 Nimzowitsch-Larsen Attack",
    "rnbqkbnr/pppppppp/8/8/1P6/8/P1PPPPPP/RNBQKBNR b KQkq b3": "A00p Polish Opening / Orangutan",
    "rnbqkbnr/pppppppp/8/8/8/2P5/PP1PPPPP/RNBQKBNR b KQkq -": "A00i Saragossa Opening / Hempel's",
    "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq c3": "A10 English Opening",
    "rnbqkbnr/pppppppp/8/8/8/3P4/PPP1PPPP/RNBQKBNR b KQkq -": "A00j Mieses Opening",
    "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3": "A40a Queen's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/4P3/PPPP1PPP/RNBQKBNR b KQkq -": "A00k Van 't Kruijis Opening",
    "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3": "B00a King's Pawn Game",
    "rnbqkbnr/pppppppp/8/8/8/5P2/PPPPP1PP/RNBQKBNR b KQkq -": "A00b Barnes Opening / Gedult's",
    "rnbqkbnr/pppppppp/8/8/5P2/8/PPPPP1PP/RNBQKBNR b KQkq f3": "A02 Bird's Opening / Dutch Attack",
    "rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -": "A04 R\u00e9ti Opening",
    "rnbqkbnr/pppppppp/8/8/8/7N/PPPPPPPP/RNBQKB1R b KQkq -": "A00g Amar Opening / Drunken Knights / Ammonia",
    "rnbqkbnr/pppppppp/8/8/8/6P1/PPPPPP1P/RNBQKBNR b KQkq -": "A00t Benko's Opening / Hungarian",
    "rnbqkbnr/pppppppp/8/8/6P1/8/PPPPPP1P/RNBQKBNR b KQkq g3": "A00n Grob's Attack",
    "rnbqkbnr/pppppppp/8/8/8/7P/PPPPPPP1/RNBQKBNR b KQkq -": "A00d Clemenz Opening",
    "rnbqkbnr/pppppppp/8/8/7P/8/PPPPPPP1/RNBQKBNR b KQkq h3": "A00c Desprez Opening / Reagen's Attack",

    // A few common 2nd level responses - not comprehensive! Keep this short.
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6": "B20 Sicilian Defense",
    "rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq -": "B27a Sicilian Defense Main Line",
    "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6": "C20 Open Game / Mutual King's Pawn",
    "rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq d6": "B01a Scandinavian Centre Counter Game",
    "r1bqkbnr/pppppppp/2n5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B00l Nimzowitsch Defense",
    "rnbqkb1r/pppppppp/5n2/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B02a Alekhine Defense",
    "rnbqkbnr/pp1ppppp/2p5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq -": "B10a Caro-Kann Defense"

    // TODO: Ajax to load scid.eco from a server optionally, to get deeper into the
    // openings. scid.eco has 20K+ lines, not practical to load into this file.
};


// TODO: library of interesting games, in PGN format. See
// http://www.xs4all.nl/~timkr/records/records.htm and http://www.xs4all.nl/~timkr/ChessTutor/pgnview.htm


/* Global functions for jslint to recognize. TODO: move to objects? */

/*global edit_pgn restore_edit save_pgn reload_pgn load_pgn parse_pgn output_pgn_dict load_ply set_next_back_accesskeys move_link decode_ply encode_ply mv should_promote promote in_check calculate_notations disambiguate_notations calculate_moves computer_move_if_applicable would_check piece_moved unfiltered_moves filtered_moves relative_decode_direction parse_move_flags nested_flags decode_explicit_move decode_one_parlett without_dupes opposite_color set_turn set_check_message check_repetition load_notations capture_piece notation_from_piece_square forwards_vector move_piece_to_square mark_repeated_moves move_dropped_piece save_fen load_fen clear_board load_starting_position init_board label_board name_pieces algebraic_letter piece_letter2name full_piece_prefix algebraic_piece_prefix figurine_piece_prefix pc_or_offboard pc image_path_for create_piece create_piece_by_letter highlight_moves unhighlight_all filerank2xy xy2filerank xy2descriptive xy2adescriptive short_descriptive sq randint ucfirst AssertException assert enable_document_selection make_move_by_menu populate_make_a_move_list realize_vboard*/
 
function main() {
// http://o.aolcdn.com/dojo/1.0.0/dojo/cookie.xd.js
// This file is small enough to just include here (without the module provisions)
dojo.cookie=function(_2,_3,_4){var c=document.cookie;if(arguments.length==1){var _6=c.lastIndexOf(_2+"=");if(_6==-1){return null;}var _7=_6+_2.length+1;var _8=c.indexOf(";",_6+_2.length+1);if(_8==-1){_8=c.length;}return decodeURIComponent(c.substring(_7,_8));}else{_4=_4||{};_3=encodeURIComponent(_3);if(typeof (_4.expires)=="number"){var d=new Date();d.setTime(d.getTime()+(_4.expires*24*60*60*1000));_4.expires=d;}document.cookie=_2+"="+_3+(_4.expires?"; expires="+_4.expires.toUTCString():"")+(_4.path?"; path="+_4.path:"")+(_4.domain?"; domain="+_4.domain:"")+(_4.secure?"; secure":"");return null;}}


    // Safari and IE7: Disable text selection to stop interfering with dragging 
    enable_document_selection(false);    

    // Hide address bar. TODO: Get this working
    //setTimeout(function() { window.scrollTo(0, 1); }, 0);

    // Let the games begin
    load_notations();
    init_board();
    init_dnd();

    // test 50 move rule (game from http://www.chessville.com/misc/History/Mad_Aussie_Trivia_Archive_12.htm)
    //load_pgn('[White "Filipowicz,A"]\n[Black "Smederevac,P"]\n[Site "Rubinstein mem 04th Polanica Zdroj (14)"]\n[Date "1966"]\n\n1. e4 e6 2. d3 Ne7 3. g3 c5 4. Bg2 Nbc6 5. Be3 b6 6. Ne2 d5 7. 0-0 d4 8. Bc1 g6 9. Nd2 Bg7 10. f4 f5 11. a3 0-0 12. e5 a5 13. a4 Ba6 14. b3 Rb8 15. Nc4 Qc7 16. Kh1 Nd5 17. Bd2 Rfd8 18. Ng1 Bf8 19. Nf3 Be7 20. h4 h5 21. Qe2 Ncb4 22. Rfc1 Bb7 23. Kh2 Bc6 24. Na3 Ra8 25. Qe1 Rdb8 26. Qg1 Qb7 27. Qf1 Kg7 28. Qh1 Qd7 29. Ne1 Ra7 30. Nf3 Rba8 31. Ne1 Bd8 32. Nf3 Rb8 33. Ne1 Bc7 34. Nf3 Rh8 35. Ng5 Bd8 36. Nf3 Be7 37. Qg1 Bb7 38. Nb5 Raa8 39. Na3 Ba6 40. Qf1 Rab8 41. Nc4 Bd8 42. Qd1 Ne7 43. Nd6 Bc7 44. Qe2 Ng8 45. Ng5 Nh6 46. Bf3 Bd8 47. Nh3 Ng4+ 48. Kg1 Be7 49. Nc4 Nd5 50. Nf2 Bb7 51. Nh3 Bc6 52. Qg2 Rhc8 53. Re1 Rc7 54. Re2 Ra7 55. Ree1 Ra6 56. Re2 Rba8 57. Ree1 R8a7 58. Na3 Ra8 59. Nc4 Nh6 60. Na3 Nf7 61. Nf2 Rd8');

    // test PGN embedded notes
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 {This opening is called the Ruy Lopez.} 3... a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    
    //pgn = load_pgn('[Event "F/S Return Match"]\n[Site "Belgrade, Serbia JUG"]\n[Date "1992.11.04"]\n[Round "29"]\n[White "Fischer, Robert J."]\n[Black "Spassky, Boris V."]\n[Result "1/2-1/2"]\n \n1. e4 e5 2. Nf3 Nc6 3. Bb5 a6\n4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O 9. h3 Nb8  10. d4 Nbd7\n11. c4 c6 12. cxb5 axb5 13. Nc3 Bb7 14. Bg5 b4 15. Nb1 h6 16. Bh4 c5 17. dxe5\nNxe4 18. Bxe7 Qxe7 19. exd6 Qf6 20. Nbd2 Nxd6 21. Nc4 Nxc4 22. Bxc4 Nb6\n23. Ne5 Rae8 24. Bxf7+ Rxf7 25. Nxf7 Rxe1+ 26. Qxe1 Kxf7 27. Qe3 Qg5 28. Qxg5\nhxg5 29. b3 Ke6 30. a3 Kd6 31. axb4 cxb4 32. Ra5 Nd5 33. f3 Bc8 34. Kf2 Bf5\n35. Ra7 g6 36. Ra6+ Kc5 37. Ke1 Nf4 38. g3 Nxh3 39. Kd2 Kb5 40. Rd6 Kc5 41. Ra6\nNf2 42. g4 Bd3 43. Re6 1/2-1/2');
    

     /* Note: chessos generates PGNs with minimal algebraic notation, sometimes, 
      * not always standard algebraic. 4. ... Bb4 should be Bxb4. Need synonym 
      * support in order to read this, or MAN support. 
      *
pgn = load_pgn(
"[Event \"ChesSOS Game\"]\n" + 
"[Site \"http://www.chessos.com\"]\n" + 
"[Date \"2009.03.18\"]\n" + 
"[Round \"-\"]\n" + 
"[White \"Dema9o9ue\"]\n" + 
"[Black \"shellreef\"]\n" + 
"[WhiteElo \"1500\"]\n" + 
"[BlackElo \"1500\"]\n" + 
"[Result \"0-1\"]\n" + 
"[URL \"http://www.chessos.com/p/?m=board" + AMP + "g=15722\"]\n" + 
"\n" + 
"1. b4 e5 2. Nc3 Bb4 3. a3 Bc3 4. dxc3 Nf6 5. h3 O-O 6. f3 d5 \n" + 
"7. e3 Nc6 8. a4 Qd6 9. Ba3 Qd8 10. g4 g5 11. h4 gxh4 12. Rh4 \n" + 
"Ne4 13. fxe4 Qh4 14. Ke2 Bg4 15. Nf3 Qh2 16. Kd3 dxe4 17. Ke4 \n" + 
"f5 18. Kd5 Rad8 19. Ke6 Qh6 \n" + 
"0-1");*/

     /* TODO: support 1.move in addition to 1. move  */
     /* TODO: support [White "Foo"][Black "Bar"], without newlines. Ignore whitespace. */
     /*
     pgn = load_pgn("[Event \"Berlin\"]\n" + 
"[Site \"?\"]\n" + 
"[Date \"1842\"]\n" + 
"[Round \"?\"]\n" + 
"[White \"Hanstein\"]\n" + 
"[Black \"Von der Lasa\"]\n" + 
"[Result \"1-0\"]\n" + 
"\n" + 
"1.e4 e5 2.f4 exf4 3.Nf3 g5 4.Bc4 Bg7 5.d4 d6 6.O-O h6 7.c3 Ne7 8.h4 Ng6\n" + 
"9.h5 Ne7 10.g3 fxg3 11.Nxg5 hxg5 12.Bxf7+ Kd7 13.Bxg5 c6 14.e5 d5\n" + 
"15.e6+ Kc7 16.Bf4+ Kb6 17.Qb3+ Ka6 18.Qa3+ Kb6 19.b4 a5 20.Bxb8 Nf5\n" + 
"21.Rxf5 Qh4 22.Qb2 Rxb8 23.b5 Qe4 24.Na3 Qxf5 25.bxc6+ Kc7 26.Nb5+\n" + 
"Kxc6 27.Na7+ Kc7 28.Nb5+ Kd8 29.Rf1 Qh3 30.e7+ Kxe7 31.Qa3+ Kd8\n" + 
"32.Qd6+ Qd7 33.Qb6+ Ke7 34.Re1+ Kxf7 35.Qg6+ Kg8 36.Re8+ Qxe8\n" + 
"37.Qxe8+ Kh7 38.Qg6+ Kg8 39.Qd6 Ra8 40.Qxd5+ Kh7 41.Qe4+ Kg8\n" + 
"42.Qe8+ Kh7 43.Qg6+ Kg8 44.Nc7 Ra6 45.Nxa6 bxa6 46.h6 Rxh6 47.Qe8+\n" + 
"Bf8 48.Qxc8 Kf7 49.Kg2 Bd6 50.Qb7+ Ke8 51.Qc6+ Kf8 52.c4 Rf6 53.c5\n" + 
"Rf2+ 54.Kg1 Bf4 55.Qf6+ Ke8 56.d5 Kd7 57.Qf7+ Kc8 58.Qe8+ Kc7\n" + 
"59.Qe7+ Kb8 60.c6 1-0");*/


}

// PGN (PORTABLE GAME NOTATION) FUNCTIONS

// Load the chess notations into the input/output notation select boxes
function load_notations()
{
    var menu = dojo.byId("output_notation");

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var name = AVAILABLE_NOTATIONS[notation];

            menu.appendChild(dojo.create("option", {value:notation, innerHTML:name}));
        }
    }

    menu.selectedIndex = 0;
}

// Open a mail message with a link to the board state
// If get_text, then return the email body instead
function email_board(get_text)
{
    var to, subject, body, url, dots, link, link_text, ply, ply_info;
    
    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fmvn) - 1;
    ply_info = decode_ply(ply);

    to = "shellreef@gmail.com";
    subject = "Chess game";
    dots = ply_info.color ? (ply_info.color === "black" ? "... " : " ") : "";

    link = dojo.byId("copyable_link").href;
    link_text = GAME_STATE.made_moves[ply] ? GAME_STATE.made_moves[ply].notations[form_value("output_notation")] : "*";
    // Note: IE ActiveXObject for Outlook: http://www.webdeveloper.com/forum/showthread.php?t=176548
    // Got an automation error when I tried it, but it could supposedly allow HTML bodies on Windows
    //body = ply_info.fmvn + ". " + dots + '<a href="' + link + '">' + link_text + '</a>';
    // Plain text
    body = ply_info.fmvn + ". " + dots + link_text + " <" + link + ">";

    if (get_text) {
        return body;
    }

    url = "mailto:" + encodeURIComponent(to) + 
        "?subject=" + encodeURIComponent(subject) + 
        "&body=" + encodeURIComponent(body);
    window.open(url);
}

// Make the PGN content editable (not to be confused with edible).
var ORIGINAL_UI_HTML;
function edit_pgn()
{
    var game_ui = dojo.byId("game_ui");

    ORIGINAL_UI_HTML = game_ui.innerHTML;

    game_ui.innerHTML = "<textarea id='edited_pgn' name='edited_pgn' cols='80' rows='35'>" + escape_html(save_pgn()) + 
        "<\/textarea>" + 
        "<button type='button' name='ok' accesskey='k' " + 
        "onclick='reload_pgn()'>OK<\/button>" +
        "<button type='button' name='cancel' onclick='restore_edit()' accesskey='x'>Cancel<\/button>";

    dojo.byId("edited_pgn").focus();
}

// Restore the game interface, removing the edit area.
function restore_edit()
{
    dojo.byId("game_ui").innerHTML = ORIGINAL_UI_HTML;
}

// Return a string of color-coded captured piece codes, or null if none.
function export_captured()
{
    var captureds = [];

    for (var i = 0; i < GAME_STATE.captured.white.length; i += 1) {
        var p = GAME_STATE.captured.white[i];
        captureds.push(color_piece_prefix(p));
    }
    for (i = 0; i < GAME_STATE.captured.black.length; i += 1) {
        var p = GAME_STATE.captured.black[i];
        captureds.push(color_piece_prefix(p));
    }
    if (captureds.length === 0) {
        return null;
    } else {
        return captureds.join("");
    }
}


// Import a color-coded string of captured pieces from export_captured() into GAME_STATE
function import_captured(captured)
{
    for (var i = 0; i < captured.length; i += 1) {
        var length = piece_code_length(captured.substr(i));
        var letter = captured.substr(i, length);
        i += length - 1;

        var decoded_piece = decode_piece_letter(letter);
        GAME_STATE.captured[decoded_piece.color].push(decoded_piece);
    }
}

// Export game as PGN.
function save_pgn()
{
    var pgns = [], dict, captured;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
  
    // PGN header information
    dict = {};
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var elt = dojo.byId("PGN_" + tag);

        if (elt.style.display !== "none") {
            dict[tag] = elt.innerHTML;
        }
    }

    // Non-standard: captured pieces
    captured = export_captured();
    if (captured) {
        dict.Captured = captured;
    }

    if (PREFS.verbose_pgn) {
        // Non-standard: current board state. The standard tags are FEN and SetUp, for starting position only.
        dict.CurrentFEN = save_fen(); 
    }

    // Generate move text (not in a tag) 
    var move_texts = [];
    var other_move_texts = {};
    for (var ply = 1; ply < GAME_STATE.made_moves.length; ply += 1) {
        var made = GAME_STATE.made_moves[ply];
        if (!made) {
            // Missing move, for one reason or another. Game started late?
            continue;
        }

        var ply_info = decode_ply(ply);

        if (ply_info.color === "white") {
            move_texts.push(ply_info.fmvn + ". ");
        }
        // TODO: include +, #, ?, !, $n notations
        move_texts.push(made.notations[EXPORT_NOTATIONS[0]]);
        move_texts.push(" ");

        for (var i = 1; i < EXPORT_NOTATIONS.length; i += 1) {
            var notation = EXPORT_NOTATIONS[i];
            if (!other_move_texts[notation]) {
                other_move_texts[notation] = [];
            }
            other_move_texts[notation][ply] = made.notations[notation];
        }
    }

    if (PREFS.verbose_pgn) {
        // Alternate moves, in tag
        for (notation in other_move_texts) {
            if (other_move_texts.hasOwnProperty(notation)) {
                var texts = [];
                for (ply = 1; ply < other_move_texts[notation].length; ply += 1) {
                    texts.push(other_move_texts[notation][ply] + " ");
                }

                dict["Moves_" + notation] = texts.join("");
            }
        }

    } 

    pgns.push(output_pgn_dict(dict));
    pgns.push("");
    pgns.push(move_texts.join("") + (GAME_STATE.ended ? " " + GAME_STATE.ended : ""));

    return pgns.join("\n");
}

// Reload PGN after editing it.
function reload_pgn()
{
    var pgn = form_value("edited_pgn");

    restore_edit();

    load_pgn(pgn);
}

// Load Portable Game Notation data
// TODO: support a tag for captured pieces, and tags for FEN at each move so don't need to compute
// TODO: http://www.mafiascum.net/wiki/index.php?title=Chess
function load_pgn(pgn)
{
    var games = parse_pgn(pgn);
    var game;
    var tags = ["White", "WhiteElo", "Black", "BlackElo", "Event", "Round", "Site", "Date", "Time"];
    var time_started = new Date().getTime();

    // TODO: UI to list all games in a PGN and pick one to load, move out parsing from this function
    assert(games.length === 1,
            "load_pgn(" + pgn + "): multiple games (" + games.length + ") found, but only one can be loaded at a time");

    game = games[0];

    // Header
    for (var i = 0; i < tags.length; i += 1) {
        var tag = tags[i];
        var node = dojo.byId("PGN_" + tag);

        assert(node, "load_pgn(" + pgn + "): no element for tag " + tag);

        if (game[tag] && game[tag].substr(0, 1) !== "?") {
            var value = game[tag];

            node.style.display = "";

            node.innerHTML = value;

            dojo.query(".show_" + tag).forEach(function(node) {
                    node.style.display = "";
                });
        } else {
            node.style.display = "none";
            dojo.query(".show_" + tag).forEach(function(node) {
                    node.style.display = "none";
                });
        }
    }

    // Starting position
    load_fen(game.FEN);
    GAME_STATE.position_after[0] = game.FEN;

    // Captured pieces
    if (game.Captured) {
        import_captured(game.Captured);
        update_captured_piece_images();
    }


    // Alternate notations for moves given in tags
    var other_notations = [];
    for (i = 0; i < EXPORT_NOTATIONS.length; i += 1) {
        var not = EXPORT_NOTATIONS[i];
        if (game["Moves_" + not]) {
            var ns = game["Moves_" + not].split(" ");

            for (var j = 0; j < ns.length; j += 1) {
                var ply = j + 1;
                if (!other_notations[ply]) {
                    other_notations[ply] = {};
                }
                other_notations[ply][not] = ns[j];
            }
        }
    }

    // Movetext given in SAN
    for (ply = 1; ply < game.moves.length; ply += 1) {
        var move = game.moves[ply];

        var others = other_notations[ply] || {};
        others.SAN = move;

        if (others && others.raw) {
            // Fast move
            // TODO: XXX: Use mv() but without calculate_moves()
            //mv(others.raw, true, others);
            var dr = decode_raw_move(others.raw);
            do_virtual_move(dr.piece, dr.move);
        } else {
            //console.log("slow move",move);
            mv(move, true, others);
        }
    }

    realize_vboard();

    // TODO: remove
    if (others && others.raw) {
        var last_ply = decode_ply(ply);
        set_turn(last_ply.color);
    }

    populate_make_a_move_list();
    show_move_history();

    /*
    var time_took = new Date().getTime() - time_started;
    if (window.console) {
        alert("load_pgn took " + time_took + " ms");
    }
    */
}

// Parse PGN into an array of dictionaries, one dictionary per game.
function parse_pgn(pgn)
{
    var dict = {};
    var dicts = [dict];
    var move_texts = [];

    // Parse headers into dictionaries
    for (var i = 0; i < pgn.length; i += 1) {
        var ch = pgn.charAt(i);

        // Tag
        if (ch === "[") {
            var key, start, quoted;

            // Read tag key name
            for (i += 1, start = i; pgn.charAt(i) !== " "; i += 1) {
                assert(i < pgn.length && pgn.charAt(i) !== "]",
                    "parse_pgn(" + pgn + "), at " + i + ", tag without space, like [foo] instead of [foo bar]");
            }
            key = pgn.substring(start, i);

            // Read value, terminated by end of tag. It can be quoted, which
            // allows for the value to contain the ] character.
            quoted = false;
            for (i += 1, start = i; !quoted ? pgn.charAt(i) !== "]" : true; i += 1) {
                if (pgn.charAt(i) === '"') {
                    quoted = !quoted;
                }

                assert(i < pgn.length, 
                    "parse_pgn(" + pgn + "), at " + i + ", tag value for " + key + " without ]");
            }
            value = pgn.substring(start, i);
            // Dequote value, as the quotes were only there for including ] characters
            if (value.charAt(0) === '"' && value.charAt(value.length - 1) == '"') {
                value = value.substr(1, value.length - 2);
            }

            if (dict[key]) {
                // Duplicate key means this is a new game
                dict.move_text = move_texts.join("");
                dict = {};
                move_texts = [];
                dicts.push(dict);
            }
            dict[key] = value;

        } else if (ch === "\n") {
            move_texts.push(" ");
        } else {
            move_texts.push(ch);
        }
    }
    dict.move_text = move_texts.join("");

    // Process each game, parsing move text
    for (var k = 0; k < dicts.length; k += 1) {
        dict = dicts[k];

        // Standard FEN
        if (!dict.FEN) {
            dict.FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
            dict.SetUp = 1;
        }

        // Parse move text
        var tokens = dict.move_text.split(" ");
        delete dict.move_text;  // not for anyone but this function
        var fmvn = 1, outcome, moves = [], color = "white";
        var in_comment = false;

        for (i = 0; i < tokens.length; i += 1) {
            var token = tokens[i];

            if (token === "") {
                // Skip
            } else if (in_comment) {
                if (token.substr(token.length - 1) === "}") {
                    in_comment = false;
                }
                // TODO: support annotations
            } else if (token.substring(token.length - 1) === ".") {
                fmvn = parseInt(token, 10);

                // 3... means black moves
                if (token.substring(token.length - 3) === "...") {
                    color = "black";
                } else {
                    color = "white";
                }

            } else if (token === "1-0") {
                outcome = "White wins";
            } else if (token === "0-1") {
                outcome = "Black wins";
            } else if (token === "1/2-1/2") {
                outcome = "Draw";
            } else if (token === "*") { 
                outcome = "(In progress)";
            } else if (token.substr(0, 1) === "{") {
                in_comment = true;
            } else {
                // Move 
                
                var ply = encode_ply(color, fmvn);
                // TODO: handle #, + for checkmate and check, part of move
                moves[ply] = token;

                // white, then black
                if (color === "white") {
                    color = opposite_color(color);
                } 
            }
        }

        dict.outcome = outcome;
        dict.moves = moves;
    }

    return dicts;
}

// Export a PGN tag dictionary to PGN format, opposite of parse_pgn.
function output_pgn_dict(dict)
{
    var lines, quoted_value, have_key, keys;

    // PGN Seven Tag Roster (STR) appears first
    keys = ["Event", "Site", "Date", "Round", "White", "Black", "Result"];
    have_key = {Event:1, Site:1, Date:1, Round:1, White:1, Black:1, Result:1};

    // Other keys
    for (var key in dict) {
        if (dict.hasOwnProperty(key)) {
            if (!have_key[key]) {
                keys.push(key);
                have_key[key] = 1;
            }
        }
    }

    lines = [];
    for (var i = 0; i < keys.length; i += 1) {
        var key = keys[i];
        var value = dict[key];

        if (value === undefined) {
            value = "?";
        }

        // TODO: unparenthetize, uncommaify, etc. .. or just set attributes
        // to exactly what we want in load_pgn(), then fetch it.
        // TODO: rules for quoting values?
        quoted_value = '"' + value + '"';
        lines.push("[" + key + " " + quoted_value + "]");
    }

    return lines.join("\n");
}


// Load a move by ply. Used to navigate to past moves.
function load_ply(ply)
{
    // TODO: would be cool to be able to also decode
    // color + fullmove number, for ease of human use.
    // Make "1." be ply 1, and "1..." or "1. ..." be ply 2.
    // Maybe make it a user function, go()
    
    dojo.query("a.active_move").removeClass("active_move");

    load_fen(GAME_STATE.position_after[ply], true);

    dojo.addClass(dojo.byId("ply_" + ply), "active_move");

    set_next_back_accesskeys(ply);
   
    unhighlight_all();

    if (ply !== 0) {
        highlight_recent_move(GAME_STATE.made_moves[ply].from_square, 
                GAME_STATE.made_moves[ply].square);
    }
}

// Setup accesskeys for next and back given the current ply.
function set_next_back_accesskeys(ply)
{
    var next_link, prev_link;

    dojo.query("a.accessible_move").forEach(function(x) {
            dojo.removeClass(x, "accessible_move");
            x.removeAttribute("accesskey");
        });


    // Note: first/last keys won't work on the 1st and penultimate move,
    // since the accesskey attributes are overwritten by the next/prev!

    // first
    dojo.byId("ply_0").setAttribute("accesskey", ";"); // ctrl+option+;

    // last
    dojo.byId("ply_" + (GAME_STATE.made_moves.length - 1)).setAttribute("accesskey", "'"); // ctrl+option+,
  
    // next
    next_link = dojo.byId("ply_" + (ply + 1));
    if (next_link) {
        // Not the last move.. there is another one ahead.
        next_link.setAttribute("accesskey", ".");       // ctrl+option+.
        dojo.addClass(next_link, "accessible_move");
    }

    prev_link = dojo.byId("ply_" + (ply - 1));

    // previous
    if (prev_link) {
        prev_link.setAttribute("accesskey", ",");       // ctrl+option+,
        dojo.addClass(prev_link, "accessible_move");
    }
}

// Make a link to a ply, which can be clicked to load the board after this move was made.
function move_link(ply, text)
{
    return '<a id="ply_' + ply + '" class="active_move" ' +
        'href="#" onclick="load_ply(' + 
            ply +
        ')">' + text + "<\/a>";
}

// Decode ply number to color and fullmove number.
function decode_ply(ply)
{
    var color, fmvn;

    color = (ply % 2 === 1) ? "white" : "black";
    fmvn = Math.ceil(ply / 2);

    return {color: color, fmvn: fmvn};
}

// Encode color and fullmove number back to ply. Ply is useful for 
// arrays of moves, since it is one integer, instead of integer+color.
function encode_ply(color, fmvn)
{
    var ply;

    ply = fmvn * 2;
    ply -= (color === "white" ? 1 : 0);

    return ply;
}

//// USER FUNCTIONS

// Make a move using any notation. Useful to use for moving within the JavaScript
// console (Develop -> Show Error Console in Safari), if you prefer CLI over GUI,
// and computer moves also use this function. 
// If is_not_immediate is true, then the UI is not updated after the move; useful
// for quickly making many moves without UI slowness.
// notations is for specifying move notations of the raw move
// Examples:
// mv("e4")
// mv("P-K4")
// mv("/e2/e4/P", false, {SAN:"e4", descr:"P-K4"})
function mv(alg_move, is_not_immediate, notations)
{
    var piece_square, piece, square, is_raw;

    if (!alg_move) {
        assert(VALID_MOVE_NOTATIONS, "mv(" + alg_move + "): called with VALID_MOVE_NOTATIONS false");
        return own_properties(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    }

    if (alg_move.substr(0, 1) === "/") {
        // Raw move notation, parsed directly, no legal move checking. For
        // loading in-progress games quickly, as no move calculation is
        // needed.
        piece_square = decode_raw_move(alg_move);
        dojo.mixin(piece_square, {notations:notations});
        is_raw = true;
    } else {
        // For ordinary notations, find move in precalculated notations. 
        piece_square = find_legal_move(alg_move);
    }

    assert(piece_square, "mv(" + alg_move + "): illegal move");

    // TODO: do some moving animation, optionally (make two functions)
 
    // There is only one choice..
    var promote_to = piece_square.move.promote_to;
    var choices = {};
    choices[promote_to] = piece_square;

    execute_move(promote_to, choices, false, !is_not_immediate, is_raw);
}

// Find a legal move, given the move text, precalculated already with
// calculate_notations().
function find_legal_move(text)
{
    var piece_square;

    // Accept digits, but prefer the letter oh.
    text = text.replace("0-0-0", "O-O-O").replace("0-0", "O-O");

    // Check/mate indicators not part of move.
    text = text.replace("+", "").replace("#", "");

    // Promotions, e1=Q, not needed, e1Q is fine
    text = text.replace("=", "")

    // Prefer these move notations, in this order.
    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            if (notation === "descr" || notation === "adesc") {
                text = text.replace(/Kt/g, "N");
            }

            piece_square = VALID_MOVE_NOTATIONS[notation][text];

            if (piece_square) {
                // Found one.
                break;
            }
        }
    }

    // Allow alternate, non-canonical forms. These are overly-descriptive
    // notations for ambiguous move notation formats. For example, in SAN
    // the canonical form of a particularly bad opening move is Nh3, but 
    // it can also be written as N1h3 or Ngh3 or Ng1h3, even though this longer
    // form is only supposed to be used when Nh3 is ambiguous, and it is not
    // standard. But you might see it, so allow it.
    if (!piece_square) {
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                if (notation === "descr" || notation === "adesc") {
                    text = text.replace(/Kt/g, "N");
                }

                piece_square = ALT_MOVE_NOTATIONS[notation][text];

                if (piece_square) {
                    //console.log("Warning: non-canonical move notation: ", notation);
                    break;
                }
            }
        }
    }

    if (piece_square) {
        // Find move in all other notations
        // TODO: avoid calling get_notations() which loops; the answer should be above
        piece_square.notations = get_notations(piece_square.piece,
                piece_square.square, 
                piece_square.move.promote_to)[piece_square.move.promote_to].notations;
    }

    return piece_square;
}
 
//// SPECIAL MOVE FUNCTIONS

// Return whether a piece should be promoted
function should_promote(piece)
{
    var square, relative_rank, promotion_rank;

    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

    square = piece.square;

    // Get rank from player's perspective (as in descriptive notation, not algebraic)
    relative_rank = GAME_STATE.active_color === "white" ? square.y : (GAME_STATE.ranks + 1) - square.y;

    // Default to last rank
    promotion_rank = PIECE_TYPES[piece.type].promotion_rank || GAME_STATE.ranks;

    return relative_rank === promotion_rank;
}

// Return whether the move would cause the piece to promote
function would_promote(piece, move)
{
    var relative_rank, promotion_rank;

    // Does it promote?
    if (!PIECE_TYPES[piece.type].promote) {
        return false;
    }

     // Get rank from player's perspective (as in descriptive notation, not algebraic)
    relative_rank = GAME_STATE.active_color === "white" ? move.y : (GAME_STATE.ranks + 1) - move.y;

    // Default to last rank
    promotion_rank = PIECE_TYPES[piece.type].promotion_rank || GAME_STATE.ranks;

    return relative_rank === promotion_rank;
}


// Finish up a promotion move.
function promote(piece, square, type, notation, is_immediate)
{
    // TODO: Puff out, or fade in from new to old piece. Is there an
    // effect that can fade from one image to another? LikE IE page transitions.
    // http://sachiniscool.blogspot.com/2006/01/implementing-page-transitions-in.html
    // ... except when changing images. Safari has CSS animations.
    // or try CSS transitions, see CSS at the top of this document.
    //piece.style.background = image_path_for(promotes_to, piece.color);
    // or TODO: create another img, same place same time, change opacity to reveal it
    // but this leaves the old image behind..
    piece.src = image_path_for(type, piece.color);
    piece.type = type;

    dojo.byId("promote_container").style.display = "none";

    // TODO: call with a correct tieback. Re-find it?
    var tieback = get_notations(piece, square, type);

    finish_up_move(tieback, is_immediate, type);
}

// Change a piece to whatever it promotes to.
function ask_to_promote(piece, tieback, is_immediate)
{
    var element, container, choice;

    realize_vboard();

    // Clear previous container
    var container = dojo.byId("promote_container");

    while(container.firstChild) {
        container.removeChild(container.firstChild);
    }

    // Create clickable promotion pieces
    for (var type in tieback) {
        if (tieback.hasOwnProperty(type)) {
            // The move the user selected that will be made
            var notation = tieback[type].notations[form_value("output_notation")];

            //element = create_piece(GAME_STATE.active_color, type);
            element = dojo.create("img", {src:image_path_for(type, piece.color), piece_type:type, notation:notation});
            element.onclick = function() {
                // Finishes up the move
                promote(piece, tieback[type].square, dojo.attr(this, "piece_type"), dojo.attr(this, "notation"), is_immediate);
            };
            container.appendChild(element);
        }
    }

    container.style.display = "";

}

//// VALID MOVE FUNCTIONS
//
// TODO: step through moves, like on http://www.pgnview.com/ (jspgnviewer) as used on http://www.zenpawn.com/chessblog/

// Check if any royal pieces of victim_color are being attacked; that is:
// victim_color's royal pieces could be captured after any of all_moves.
function in_check(victim_color, all_moves)
{
    var royals;
    var attacked = false;

    // Pieces that can't be captured and need to move if attacked
    royals = [];
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var piece;

            piece = VBOARD[x][y].piece;

            if (piece && PIECE_TYPES[piece.type].royal) {
                royals.push(piece);
            }
        }
    }

    // Attack the royal pieces?
    for (var filerank in all_moves) {
        if (all_moves.hasOwnProperty(filerank)) {
            var moves = all_moves[filerank];

            dojo.forEach(moves, function(move) {
                dojo.forEach(royals, function(royal) {
                    var square = royal.square;

                    if (move.x === square.x && move.y === square.y) { 
                        // Being attacked!
                        //console.log("CHECKED BY",piece,filerank,xy2filerank(move.x, move.y));
                        attacked = true;
                    }
                });
            });
        }
    }

    return attacked;
}

// Calculate and save the move notations for a move.
// Note: only do this if not hypothetical.
function calculate_notations(color, piece, moves, starting_filerank, ps, square_from)
{
    dojo.forEach(moves, function(move) {
        var square = VBOARD[move.x][move.y];

        // Building blocks
        var dest_filerank = xy2filerank(move.x, move.y);        // e4
        var dest_file = dest_filerank.substr(0, 1);             // e
        var dest_rank = dest_filerank.substr(1, 1);             // 4
        // starting_filerank (passed in as parameter)           // e2
        var starting_file = starting_filerank.substr(0, 1);     // e
        var starting_rank = starting_filerank.substr(1, 1);     // 2
        var descriptive_origin = xy2descriptive(color, filerank2xy(starting_filerank));             // K2
        var adescriptive_origin = xy2adescriptive(color, filerank2xy(starting_filerank));           // e2
        var descriptive_dest = xy2descriptive(color, move);                                         // K4
        var adescriptive_dest = xy2adescriptive(color, move);                                       // e4
        var descriptive_dest_file = descriptive_dest &&
            descriptive_dest.substr(0, descriptive_dest.length - 1);                                // K
        var descriptive_dest_rank = descriptive_dest &&
            descriptive_dest.substr(descriptive_dest.length - 1);                                   //  4
        var descriptive_origin_file = descriptive_origin &&
            descriptive_origin.substr(0, descriptive_origin.length - 1);                            // K
        var descriptive_origin_rank = descriptive_dest && 
            descriptive_dest.substr(descriptive_dest.length - 1);                                   //  4
        //var adescriptive_dest_file = adescriptive_dest.substr(0, 1);                              // e
        //var adescriptive_dest_rank = adescriptive_dest.substr(1, 1);                              //  4
        var adescriptive_origin_file = adescriptive_origin.substr(0, 1);                            // e
        var adescriptive_origin_rank = adescriptive_dest.substr(1, 1);                              //  4

        var capture_x;                  // x/blank
        var capture_slash;              // slash/blank
        var capture_or_dash;            // x/-
        var captured_letter = "";       // capital letter of piece, P for pawn, etc. or blank
        var captured_colon_letter = ""; // colon if captured, then piece letter if not pawn
        var captured_piece = move.capture; 

        var promote_or_blank = "";      // Q/blank
        var promote_figurine = "";      // ♕/blank
        var promote_iccf = "";          // 1/blank
        var promote_paren = "";         // (Q)/blank

        if (move.promote_to) {
            var promote_piece = {type:move.promote_to};

            promote_or_blank = full_piece_prefix(promote_piece);
            promote_figurine = figurine_piece_prefix(GAME_STATE.active_color, promote_piece);
            promote_iccf = PIECE_TYPES[move.promote_to].iccf_number;
            promote_paren = "(" + promote_or_blank + ")";
        }

        if (captured_piece) {
            capture_x = "x";
            capture_slash = "/";
            capture_or_dash = "x";
            captured_letter = full_piece_prefix(captured_piece);
            captured_colon_letter = ":" + (captured_letter === "P" ? "": captured_letter);
        } else {
            capture_or_dash = "-";
            capture_x = "";
            capture_slash = "";
            captured_letter = "";
            captured_colon_letter = "";
        }


        // Compute notations: SAN, FAN, MAN, LAN, RAN, CRAN and also descriptive.
        // But first check if the move text was overridden in decode_one_parlett(), for the
        // notations where it can be overridden. Not all have special notation for castling.
        if (move.notation_override) {
            // Override notation; used for special moves (castling)
            // Note: not all notations have special notation for castling.
            ps.SAN.push([piece, square, [move.notation_override], move]);
            ps.LAN.push([piece, square, [move.notation_override], move]);
            ps.MAN.push([piece, square, [move.notation_override], move]);
            ps.RAN.push([piece, square, [move.notation_override], move]);
            ps.CRAN.push([piece, square, [move.notation_override], move]);
            ps.descr.push([piece, square, [move.notation_override], move]);
            ps.adesc.push([piece, square, [move.notation_override], move]);
        } else {
            var algs, figurine_prefix, algebraic_prefix, piece_letter, minimal_algs;

            if (capture_x === "x" && piece.type === "pawn") {
                // Pawn captures begin with file of pawn.
                algs = [starting_file + capture_x + dest_filerank]; // ?xd5
            } else {
                algs = [
                    capture_x + dest_filerank,                      // ?f3
                    starting_file + capture_x + dest_filerank,      // ?gf3
                    starting_rank + capture_x + dest_filerank,      // ?1f3
                    starting_filerank + capture_x + dest_filerank   // ?g1f3
                ];
            }

            piece_letter = full_piece_prefix(piece);               // P, N, etc.
            algebraic_prefix = algebraic_piece_prefix(piece);      // blank, N, etc.
            figurine_prefix = figurine_piece_prefix(color, piece); // ♟, ♞, ♙, ♘, etc.

            ps.SAN.push([piece, square, dojo.map(algs, function(a) { return algebraic_prefix + a + promote_or_blank; }), move]);  // N??
            ps.FAN.push([piece, square, dojo.map(algs, function(a) { return figurine_prefix + a + promote_figurine; }), move]);   // ♘??

            // Minimal notation, supposedly used in Informant
            minimal_algs = [
                algebraic_prefix + dest_filerank + promote_or_blank,                      // ?f3
                algebraic_prefix + starting_file + dest_filerank + promote_or_blank,      // ?gf3
                algebraic_prefix + starting_rank + dest_filerank + promote_or_blank,      // ?1f3
                algebraic_prefix + starting_filerank + dest_filerank + promote_or_blank]; // ?g1f3
            ps.MAN.push([piece, square, minimal_algs, move]);

            ps.LAN.push([piece, square, [algebraic_prefix + starting_filerank + 
                    capture_or_dash + dest_filerank + promote_or_blank], move]);

            // TODO: Find out for sure how promotions are shown in RAN
            ps.RAN.push([piece, square, [algebraic_prefix + starting_filerank + capture_or_dash + 
                captured_letter + dest_filerank + promote_or_blank], move]);

            // Best online documentation I could find on CRAN: 
            //  http://main.uschess.org/forums/viewtopic.php?f=2&t=1428&start=30
            // Always gives origin square filerank, then only non-redundant file/rank of dest square
            // Uses ':' for capture instead of 'x', and piece letter isn't given if pawn
            // Full description will have to wait until I receive the book
            //  http://www.amazon.com/Play-Stronger-Chess-Examining-Chess960/dp/0977452107
            ps.CRAN.push([piece, square, [
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_filerank + promote_or_blank,  // Rd3:d7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_file + promote_or_blank,      // Rd3:7
                algebraic_prefix + starting_filerank + captured_colon_letter + dest_rank + promote_or_blank       // Rd3:e
                ], move]);

            // English descriptive notation
            // TODO: 
            // - alt_letter (Kt for knight instead of N) and
            //   alt_descriptive_dest (QKt1 for b1 instead of QN1) - currently, Kt is preprocessed to N in mv()
            //   would be nice to have an option to prefer Kt over N, for using old books (though N/Kt would be synonyms)
            // - allow slashes in addition to parenthesises, or maybe not, since would be shorter and therefore preferred
 
            // Descriptive vs algebraic is like imperial vs. metric units, in some ways. Descriptive
            // is from each player's perspective, so 1. P-K4 P-K4 is easily recognizable as the same
            // move from both players, more readily than 1. e4 e5. And 2. PxP PxP more clearly shows
            // a pawn trade than 10. exd5 cxd5. Smith notation shows the latter, too, but the coordinates
            // are still not symmetric from each player's perspective. I like descriptive. Problem is
            // just that it needs to be disambiguated often, algebraic less so.
            // This paper mentions how a book on openings for black showed all of the diagrams from
            // white's perspective: http://www.castlelong.com/essay/Essay_HSym_fd47b_Doc_Prn.PDF
            // -- it discusses symmetric figurines, interesting. Although it says algebraic is superior.
          
            var piece_name = piece.descriptive_name;
            var short_piece_name = short_descriptive(piece_name);
            var short_descriptive_dest = short_descriptive(descriptive_dest_file) + descriptive_dest_rank;

            var piece_aname = piece.adescriptive_name;

            if (capture_or_dash === "-") { 
                // non-capturing move
                ps.descr.push([piece, square, 
                    // Must uniq() the array, since some of the notations actually appear twice
                    // in the list above, and disambiguate_moves() will delete both since it'll think they
                    // are ambiguous. This would have occurred when piece_name === short_piece_name, that is,
                    // for KP, QP, K, and Q. 
                    uniq([
                    piece_letter + capture_or_dash + short_descriptive_dest + promote_paren,        // P-B4
                    piece_name + capture_or_dash + short_descriptive_dest + promote_paren,          // QBP-B4
                    short_piece_name + capture_or_dash + short_descriptive_dest + promote_paren,    // BP-B4
                    piece_letter + capture_or_dash + descriptive_dest + promote_paren,              // P-QB4
                    short_piece_name + capture_or_dash + descriptive_dest + promote_paren,          // BP-QB4
                    piece_name + capture_or_dash + descriptive_dest + promote_paren,                // QBP-QB4

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + descriptive_dest + promote_paren,      // P(K2)-K4
                    piece_letter + "(" + descriptive_origin_rank + ")" + capture_or_dash + descriptive_dest + promote_paren, // P(2)-K4
                    piece_letter + "(" + descriptive_origin_file + ")" + capture_or_dash + descriptive_dest + promote_paren  // P(K)-K4
                ]), move]);


                ps.adesc.push([piece, square, uniq([
                    piece_letter + capture_or_dash + adescriptive_dest + promote_paren,             // P-c4
                    piece_aname + capture_or_dash + adescriptive_dest + promote_paren,              // cP-c4
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + adescriptive_dest + promote_paren,       // P(c2)-c4
                    piece_letter + "(" + adescriptive_origin_rank + ")" + capture_or_dash + adescriptive_dest + promote_paren,  // P(2)-c4
                    piece_letter + "(" + adescriptive_origin_file + ")" + capture_or_dash + adescriptive_dest + promote_paren   // P(c)-c4
                ]), move]);
            } else if (capture_or_dash === "x") {
                var captured_name = captured_piece.descriptive_name;
                var short_captured_name = short_descriptive(captured_name);
                
                var captured_aname = captured_piece.adescriptive_name;

                // capture
                ps.descr.push([piece, square, uniq([
                    // Note: a permutation function would be handy here
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + short_captured_name + promote_paren,       // PxBP
                    piece_letter + capture_or_dash + captured_name + promote_paren,             // PxQBP
                    short_piece_name + capture_or_dash + captured_letter + promote_paren,       // NPxP
                    short_piece_name + capture_or_dash + short_captured_name + promote_paren,   // NPxBP
                    short_piece_name + capture_or_dash + captured_name + promote_paren,         // NPxQBP
                    piece_name + capture_or_dash + captured_letter + promote_paren,             // QNPxP
                    piece_name + capture_or_dash + short_captured_name + promote_paren,         // QNPxBP
                    piece_name + capture_or_dash + captured_name + promote_paren,               // QNPxQBP

                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_name + promote_paren,    // P(K4)xQP
                    piece_letter + "(" + descriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren,  // P(K4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren,    // PxP(Q4)
                    piece_name + capture_or_dash + captured_letter + "(" + descriptive_dest + ")" + promote_paren       // KPxP(Q4)
                ]), move]);

                ps.adesc.push([piece, square, uniq([
                    piece_letter + capture_or_dash + captured_letter + promote_paren,           // PxP
                    piece_letter + capture_or_dash + captured_aname + promote_paren,            // PxcP
                    piece_aname + capture_or_dash + captured_letter + promote_paren,            // bPxP
                    piece_aname + capture_or_dash + captured_aname + promote_paren,             // bPxcP

                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_aname + promote_paren,  // P(b4)xcP
                    piece_letter + "(" + adescriptive_origin + ")" + capture_or_dash + captured_letter + promote_paren, // P(b4)xP
                    piece_letter + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren,   // PxP(c5)
                    piece_aname + capture_or_dash + captured_letter + "(" + adescriptive_dest + ")" + promote_paren     // bPxP(c5)
                ]), move]);
            } else {
                assert(false, "calculate_notations: " + capture_or_dash + " is not - or x");
            }
        }

        // Coordinate notation - least descriptive notation possible, but must include promotion to be non-ambiguous
        ps.coord.push([piece, square, [starting_filerank.toUpperCase() + "-" + dest_filerank.toUpperCase() + promote_paren], move]);

        // ICCF numeric notation
        var starting_xy = filerank2xy(starting_filerank);
        var starting_x = starting_xy[0], starting_y = starting_xy[1];
        ps.ICCF.push([piece, square, [starting_x + "" + starting_y + "" + move.x + "" + move.y + promote_iccf], move]);

        // Smith notation, reversible, non-ambiguous: https://www.chessclub.com/chessviewer/smith.html
        var smith_capture_letter;
        if (move.smith_castle) {
            // c = short castle, C = long castle
            smith_capture_letter = move.smith_castle;
        } else if (move.en_passant_capture) { 
            // E = en passant capture
            smith_capture_letter = "E";
        } else if (move.capture) {
            // pnbrqk = captured respective piece. This is what makes it reversible.
            smith_capture_letter = captured_letter.toLowerCase();
        } else {
            smith_capture_letter = "";
        }
        ps.smith.push([piece, square, [starting_filerank + dest_filerank + smith_capture_letter + promote_or_blank], move]);
       
        // Should NEVER need to lookup raw notation, but calculate here so it is treated like all the others
        ps.raw.push([piece, square, [make_raw_notation(piece, move)], move]);
    });

    // TODO: check for cross-notation ambiguities. Inputs are tested in the order of
    // AVAILABLE_NOTATIONS, but a notation that matches two different moves in
    // two different notations, if it exists, is sure to cause trouble!
}

// Used for sorting a function by length
function by_length(x, y) 
{ 
    return x.length - y.length; 
}

// Given a list of all valid move notations, remove the ambiguous 
// (Nf3 and Nf3, remove both) overly-disambiguated (Ng1f3 if Ngf3
// or N1f3 is not ambiguous).
function disambiguate_notations(notations)
{
    var freq_count = {};
    var canonical_notations = {};
    var synonymous_notations = {};
    var piece, square, same_moves, abs_move;

    // Count occurrences of each notation text, so know if is ambiguous.
    for (var i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];

        for (var j = 0; j < same_moves.length; j += 1) {
            var move = same_moves[j];

            if (!freq_count[move]) {
                // Store index so can delete if is a dupe
                freq_count[move] = [[i, j]];
            } else {
                freq_count[move].push([i, j]);
            }
        }
    }

    // Delete ambiguous moves (or actually, replace with 'undefined')
    for (notation in freq_count) {
        if (freq_count.hasOwnProperty(notation)) {
            var locations = freq_count[notation];

            if (locations.length > 1) {
                for (var k = 0; k < locations.length; k += 1) { 
                    var i = locations[k][0], j = locations[k][1];
                    delete notations[i][2][j];
                }
            }
        }
    }

    // Find shortest notation text
    for (i = 0; i < notations.length; i += 1) {
        piece = notations[i][0];
        square = notations[i][1];
        same_moves = notations[i][2];
        abs_move = notations[i][3];
        var shortest, synonyms;

        // Remove undefined elements
        same_moves = dojo.filter(same_moves, function(x) { return x !== undefined; });
       
        // Choose shortest (now unambiguous) notation
        // Could also do: min_length = same_moves.pluck("length").min();, then partition
        // Rather, sort by length, ascending.
        same_moves.sort(by_length);

        // The shortest, non-ambiguous move is canonical. But also keep the
        // synonymous moves around.
        shortest = same_moves.shift();
        synonyms = same_moves;

        canonical_notations[shortest] = {piece:piece, square:square, move:abs_move};

        for (j = 0; j < synonyms.length; j += 1) {
            synonymous_notations[synonyms[j]] = {piece:piece, square:square, move:abs_move};
        }
    }

    // TODO: also return synonymous_notations, so overly-disambiguated move
    // notations can be used, too, but return them separately so they won't be
    // listed as unique, canonical moves.
    return [canonical_notations, synonymous_notations];
}

// After the board changes and it is the next person's turn, calculate 
// what the next possible allowable moves are, and update the globals with this information.
//
// If is_hypothetical, do not update globals, and allow "moves" that put in
// check (useful for attacks, see is_hypothetical elsewhere).
//
// This operates on VBOARD only.
function calculate_moves(color, is_hypothetical)
{
    var valid_moves = {}, is_valid_move = {}, blocked_moves = {};
    var possible_notations, notation, raw_notations = {};

    if (!is_hypothetical) { 
        // Values are [ [ [piece, square ], [possible move names] ], ... ]
        // Instead of a hash or assocative array, because I couldn't use
        // [piece, square] as a key, even with Prototype's Hash. Could use
        // http://www.tutorials4html.com/2009/02/06/true-javascript-hash-table/
        // but instead, using an array with linear lookup.
        possible_notations = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                possible_notations[notation] = [];
            }
        }
    }

    // Look at all the active pieces
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var starting_filerank, square_from, moves, moves_all, piece;

            square_from = VBOARD[x][y];
            piece = square_from.piece;
 
            // Skip blank squares and inactive pieces
            if (!piece || piece.color !== color) {
                continue;
            }

            // Convert xy to filerank notation (a string), so it can be easily used
            // as a hash key, class name for droppables, and also for notations.
            starting_filerank = square_from.filerank;

            moves_all = filtered_moves(piece, color, is_hypothetical);
            moves = moves_all.legal;
            if (!is_hypothetical) {
                // Fills in possible_notations with possibly-ambiguous move notations in each system
                calculate_notations(color, piece, moves, starting_filerank, possible_notations, square_from);
            }

            // Store valid moves for mouseovers etc.
            if (moves.length !== 0) {
                // For move highlighting
                valid_moves[starting_filerank] = moves;

                // Lookup for accepts()
                is_valid_move[starting_filerank] = {};
                dojo.forEach(moves, function(m) {
                    is_valid_move[starting_filerank][xy2filerank([m.x, m.y])] = m;
                });
            }

            if (blocked_moves.length !== 0) {
                blocked_moves[starting_filerank] = moves_all.blocked;
            }

            //console.log(starting_filerank, moves);
        }
    }


    // Gather all the notations, disambiguate and apply
    if (!is_hypothetical) {
        var notations = possible_notations;
        VALID_MOVE_NOTATIONS = {};
        ALT_MOVE_NOTATIONS = {};
        for (notation in AVAILABLE_NOTATIONS) {
            if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
                var canonical_and_synonyms;

                canonical_and_synonyms = disambiguate_notations(notations[notation]);
                VALID_MOVE_NOTATIONS[notation] = canonical_and_synonyms[0];
                ALT_MOVE_NOTATIONS[notation] = canonical_and_synonyms[1];
            }
        }

        // For reals.
        VALID_MOVES = valid_moves;
        BLOCKED_MOVES = blocked_moves;
        IS_VALID_MOVE = is_valid_move;
    }
    
    return {moves:valid_moves, blocked:blocked_moves};
}

// Get the number of properties an object has on its own.
// Conceptually, the "size" of an "associative array"
function own_property_count(obj)
{
    var count = 0;

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            count += 1;
        }
    }

    return count;
}

// Get the properties of an object as an array
function own_properties(obj)
{
    var props = [];

    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            props.push(prop);
        }
    }

    return props;
}



// Populate the menu of valid moves, where you can make a move
// by selection instead of moving a piece with your mouse.
function populate_make_a_move_list()
{
    var active_name = AVAILABLE_NOTATIONS[PREFS.input_notation];
    var move_group, change_group, count, menu;

    menu = dojo.byId("make_move_menu");
    menu.innerHTML = "";

    count = own_property_count(VALID_MOVE_NOTATIONS[PREFS.input_notation]);
    if (count === 0) {
        // TODO: This fails, _35e. Fix.
        menu.appendChild(dojo.create("option", {value:"", innerHTML:"No legal moves"}));
        return;
    }

    menu.appendChild(dojo.create("option", 
                {value:"", innerHTML:"Make a move... (" + count + ")"}));
   
    // Moves in active input notation.
    move_group = dojo.create("optgroup", {label:active_name});
    menu.appendChild(move_group);

    for (var notation in VALID_MOVE_NOTATIONS[PREFS.input_notation]) {
        if (VALID_MOVE_NOTATIONS[PREFS.input_notation].hasOwnProperty(notation)) {
            move_group.appendChild(dojo.create("option", 
                        {value: notation, innerHTML:notation}));
        }
    }

    // Change the input notation.
    change_group = dojo.create("optgroup", {label:"Other notation..."});
    menu.appendChild(change_group);

    for (var n in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(n) && n !== PREFS.input_notation) {
            var name = AVAILABLE_NOTATIONS[n];
            change_group.appendChild(dojo.create("option", 
                        {value: "change_" + n, innerHTML:name}));
        }
    }

    menu.selectedIndex = 0;
}

// Called when the make a move menu is changed, either to change the
// input notation or actually make a move by the menu.
function make_move_by_menu(menu)
{
    var choice = form_value("make_move_menu");

    // Notation change
    if (choice.indexOf("change_") === 0) {
        var new_notation = choice.substring("change_".length);
   
        PREFS.input_notation = new_notation;
        populate_make_a_move_list();
        return;
    }

    mv(choice);
}

// AI - artificial intelligence 
// Do this after a delay, so that when playing computer vs. computer, you can
// see the move, since they are not animated (Effect.Move) yet.
function computer_move_if_applicable(clicked)
{
    if (clicked) {
        if (form_value("black_computer") || form_value("white_computer")) {
            dojo.byId("skill_level").value = PREFS.skill;
            dojo.byId("show_skill").style.display = "";
        } else {
            dojo.byId("show_skill").style.display = "none";
        }
    }

    if (!form_value(GAME_STATE.active_color + "_computer")) {
        return;
    }

    // TODO: better variables
    if (dojo.byId("check").innerHTML.indexOf("Checkmate") !== -1 ||
        dojo.byId("check").innerHTML.indexOf("Draw") !== -1) {
        // Game is completed, don't bug the computer
        return;
    }

    unhighlight_all();

    if (PREFS.skill === 0) {
        setTimeout(random_move, 1);
    } else {
        schedule_engine_move(PREFS.skill);
    }
}

// Update the skill level when the user changes the form field.
function update_skill(element)
{
    var skill = parseInt(element.value, 10);

    if (skill < 0) {
        skill = 0;
    }  else if (skill > 100) {
        skill = 100;
    }

    element.value = skill;

    PREFS.skill = skill;
}

// Make a random move with equal probability. No intelligence.
function random_move()
{
    // simply choose a random move
    var keys = own_properties(VALID_MOVE_NOTATIONS.SAN);
    var alg_move = keys[randint(0, keys.length - 1)];
    //var alg_move = keys[0];

    //var piece_square = VALID_MOVE_NOTATIONS.SAN[alg_move];

    // TODO: do some animation when moving, Effect.Move, to slow it down so we can see it.
    mv(alg_move);
}

// Ask a chess engine, via Ajax, for its move and the board score.
// TODO: also allow remote human moves, for realtime games?
function schedule_engine_move(skill)
{
    var query;

    // TODO: pass skill, too.
    
    query = "?skill=" + skill + ";fen=" + encodeURIComponent(active_fen());

    dojo.xhrGet({
        url: PREFS.engine + query,
        handleAs: "json",
        load: got_engine_move,
        error: got_engine_error
        });

    set_check_message("Analyzing...");
}

// Callback for when the chess engine Ajax request move is received.
function got_engine_move(response)
{
    if (!response.error) {
        set_check_message("");
        mv(response.next_move);
        // TODO: show a meter for the board position
        dojo.byId("score").innerHTML = "Score: " + response.score;
    } else {
        disable_engine("Engine error: " + response.error);
    }
}

// Called when the Ajax request fails
function got_engine_error(response)
{
    disable_engine("Engine unavailable: " + response);
}

// Disable the external chess engine usage and make a random move in its place.
function disable_engine(why)
{
    PREFS.skill = 0;
    dojo.byId("skill_level").value = PREFS.skill;
    dojo.byId("skill_level").title = "Reset because of: " + why;
    window.status = "Skill level reset because: " + why;

    // It'll have to do
    random_move();
}

// Codes for raw notation
// TODO: generalize in raw notation and abs_move? 
var RAW_NOTATION_FLAG_LONG2SHORT = {
    en_passant_capture: "e",    // captures pawn behind destination square
    snapback: "s",              // clears "destination square", piece doesn't move
    self_destruct: "d"          // destination square is cleared
};

var RAW_NOTATION_FLAG_SHORT2LONG = {
    e: "en_passant_capture",
    s: "snapback",
    d: "self_destruct"
};

// Decode a serialized "raw" notation and execute it using do_virtual_move().
// This move notation allows moves to be made without calculating the valid
// moves, a time-consuming process.
// Syntax: /from_square/to_square/piece_code/flags
// TODO: Use for quickly loading a saved game, in a URL, without calculating valid
// moves (time consuming)
function decode_raw_move(s)
{
    var a, piece, move, square, notations, flags;

    assert(s.substr(0, 1) === "/", "do_raw_move(" + s + "): must begin with /");

    // TODO: support X(...) piece codes
    piece = decode_piece_letter(s.substring(5, 6));
    piece.square = filerank2obj(s.substring(1, 3));
    move = filerank2obj(s.substring(3, 5));
    flags = s.substring(6);

    for (var i = 0; i < flags.length; i += 1) {
        var flag_code = flags.charAt(i);
        var long_flag = RAW_NOTATION_FLAG_SHORT2LONG[flag_code];
        
        assert(long_flag, "decode_raw_move(" + s + "): invalid flag code: " + flag_code);
        move[long_flag] = true;
    }

    
    square = VBOARD[move.x][move.y];

    // Populate move with flags
    dojo.mixin(move, parse_move_flags(flags));

    return {piece:piece, square:square, move:move};
    //do_virtual_move(piece, move);
}

// Generate the raw move notation for a move
function make_raw_notation(piece, move)
{
    var from_square, to_square, piece_code, flags;

    from_square = xy2filerank([piece.square.x, piece.square.y]);
    to_square = xy2filerank([move.x, move.y]);
    piece_code = color_piece_prefix(piece);

    flags = "";
    for (var prop in move) 
    {
        if (move.hasOwnProperty(prop)) {
            var code = RAW_NOTATION_FLAG_LONG2SHORT[prop];
            if (code) {
                flags += code;
            }
        }
    }

    return "/" + from_square + to_square + piece_code + flags;
}

// Make a move in the VBOARD, which can be undone. Only makes the move.
function do_virtual_move(piece, move)
{
    var did = {};

    did.piece = piece;
    did.move = move;

    did.from_square = piece.square;

    did.to_square = VBOARD[move.x][move.y];
 
    // Special case: en passant captures to an empty square
    if (move.en_passant_capture) {
        var forward = forwards_vector(GAME_STATE.active_color);

        did.capture_square = VBOARD[did.to_square.x][did.to_square.y - forward];
    } else {
        did.capture_square = did.to_square;
    }

    // The piece that was captured, not always where the piece moved to.
    did.captured = did.capture_square.piece;

    // This flag prevents a move from causing the piece to capture itself
    // when it "moves" to the same square that it is on.
    if (move.ignore_self_capture && did.captured === piece) {
        return {};
    }

    // Piece that was on destination square, if any. For restoring old piece.
    did.piece_moved_over = did.to_square.piece;

    if (did.captured) { 
        VBOARD[did.capture_square.x][did.capture_square.y].piece = null;
        did.captured.square = null;
    }

    if (move.snapback) {
        // Projectile attack, withdrawals back to where it came from
        did.to_square = did.from_square;    // this is key
        did.piece_moved_over = did.captured;
        return did;
    }
    if (move.self_destruct) {
        VBOARD[did.to_square.x][did.to_square.y].piece = null;
        did.self_destructed = true;
        VBOARD[did.from_square.x][did.from_square.y].piece = null;
        return did;
    }

    piece.square = VBOARD[did.to_square.x][did.to_square.y];
    VBOARD[did.to_square.x][did.to_square.y].piece = piece;
    if (did.from_square) {
        VBOARD[did.from_square.x][did.from_square.y].piece = null;
    }

    return did;
}

// Undo a move given the result of do_virtual_move().
function undo_virtual_move(did)
{
    // Restore captured piece
    if (did.captured) {
        did.captured.square = VBOARD[did.capture_square.x][did.capture_square.y];
        did.captured.square.piece = did.captured;
    }

    // Piece that was clobbered by the move
    VBOARD[did.move.x][did.move.y].piece = did.piece_moved_over;

    // Move piece back
    did.piece.square = VBOARD[did.from_square.x][did.from_square.y];
    VBOARD[did.from_square.x][did.from_square.y].piece = did.piece;
}


// Return whether moving piece to move would mean that
// color is in check. Note, that doesn't mean that the move
// *caused* the check, they could have already been in check and
// this move didn't take them out. Either way, its illegal.
function would_check(piece, move, color)
{
    var from_square = piece.square;
    var to_square = VBOARD[move.x][move.y];
    var checked, all_moves, did;


    // Hypothetical move, with possible capture
    did = do_virtual_move(piece, move);

    // TODO: This is a lot of calculation to do, see if can speed it up
    all_moves = calculate_moves(opposite_color(color), true);
    checked = in_check(color, all_moves.moves);

    // Restore move
    undo_virtual_move(did); 

    return checked;
}

// Return whether a pawn has moved from its initial position. Unfortunately,
// the starting ranks of black and white pawns are hardcoded, so that games
// in-progress can be loaded and pawns that have moved, but we haven't seen move,
// are recognized as in fact having moved. Other games with pawns in ranks other
// than 2nd and 7th (Chinese Chess, etc.) will need to have this modified.
// TODO: store initial rank in piece information
function piece_moved(piece)
{
    // Bit of a hack, but castling privileges take care of this.
    if (piece.type === "king") {
        return false;
    }

    // TODO: don't hardcode! Give rank in piece type, mirror black/white.
    //assert(piece.type === "pawn" || piece.type === "berolina_pawn" || piece.type === "pawnattackrook", "piece_moved(" + piece + "): can only tell if pawns moved, not " + piece.type);

    var square = piece.square;

    if (piece.color === "white") {
        return square.y !== 2;    // 2nd rank
    } else if (piece.color === "black") {
        return square.y !== 7;    // 7th rank
    } else {
        assert("piece_moved(" + piece + "): neither white nor black");
    }
}

//// PARLETT NOTATION FUNCTIONS

// Convert an unfiltered moves array into a textual graphical representation
function movement_diagram(moves)
{
    var board = {}, texts;

    // Empty board
    for (var x = -GAME_STATE.files; x <= GAME_STATE.files; x += 1) {
        board[x] = {};
        for (var y = -GAME_STATE.ranks; y <= GAME_STATE.ranks; y += 1) {
            board[x][y] = " ";
        }
    }

    // Mark moves
    for (var i = 0; i < moves.length; i += 1) {
        var move = moves[i];
        var ch;

        if (!board[-move[1]]) {
            // Invalid move
            continue;
        }

        // Basic movement - leaper or rider
        if (move[2].if_blocked_skip) {
            // might block (rider)
            ch = "x";
        } else {
            // probably a leaper
            ch = "+";
        }

        if (move[2].capture_only) {
            ch = "c";
        }
        if (move[2].no_capture) {
            ch = "m";   // move only, no capture
        }
        if (move[2].initial_only) {
            ch = "i";
        }
        if (move[2].if_unblocked_dx !== undefined) {
            ch = "u";   // unblocked
        }
        if (move[2].if_blocked_dx !== undefined) {
            ch = "^";   // probably a hopper
        }

        // Flip directions
        board[-move[1]][move[0]] = ch;

        if (move[2].if_unblocked_dx !== undefined) {
            board[-move[2].if_unblocked_dy][move[2].if_unblocked_dx] = "|";
        }
    }

    // Origin
    board[0][0] = "O";

    // Stringify
    texts = [];
    for (var x = -GAME_STATE.files; x <= GAME_STATE.files; x += 1) {
        for (var y = -GAME_STATE.ranks; y <= GAME_STATE.ranks; y += 1) {
            var ch = board[x][y];
            var top = (x + GAME_STATE.files) * 10;
            var left = (y + GAME_STATE.ranks) * 10;
            texts.push("<div class='inspector-diagram-cell' style='top:" + top + "px; left: " + left + "px;'>" + ch + "</div>");
        }
    }


    return texts.join("");
}


// Get the unfiltered, relative moves for a Parlett string.
// Warning: do not modify the moves returned! Otherwise other moves will get confused.
var PARLETT_CACHE = {};
function unfiltered_moves(parlett)
{
    var choice_groups, rel_moves;

    // Cache for a performance improvement, since Parlett is constant per move.
    if (PARLETT_CACHE[parlett]) {
        //return deep_copy(PARLETT_CACHE[parlett]);
        //return PARLETT_CACHE[parlett].evalJSON();
        return PARLETT_CACHE[parlett];
    }

    // Get all the unfiltered moves for the mutually exclusive choices
    choice_groups = parlett.split(", ");

    rel_moves = [];
    for (var i = 0; i < choice_groups.length; i += 1) {
        // For each group, gather the move options. 
        // (Would be nice if JavaScript arrays had a Python-like .extend)
        rel_moves.push.apply(rel_moves, decode_one_parlett(choice_groups[i]));
    }   
    //rel_moves = without_dupes(rel_moves);

    PARLETT_CACHE[parlett] = rel_moves;
    //PARLETT_CACHE[parlett] = dojo.toJson(rel_moves);

    return rel_moves;
}

// Get the legal moves for a piece.
function filtered_moves(piece, color, is_hypothetical)
{
    var parlett, rel_moves, moves, blocked_moves, start, blocked;
    var start_x, start_y, piece_info;

    start = piece.square;
    if (!start) {
        return [];
    }

    start_x = start.x;
    start_y = start.y;

    piece_info = PIECE_TYPES[piece.type];
    parlett = piece_info.parlett;

    rel_moves = unfiltered_moves(parlett);

    // Absolutize and find what is allowed
    moves = [];
    blocked_moves = [];
    blocked = {};
    for (var i = 0; i < rel_moves.length; i += 1) {
        var rel_x, rel_y, flags, abs_move, x, y;
       
        rel_x = rel_moves[i][0];
        rel_y = rel_moves[i][1]; 
        flags = rel_moves[i][2];

        // Local copies of relative coords, so don't modify original.
        var if_unblocked_dx = flags.if_unblocked_dx, if_unblocked_dy = flags.if_unblocked_dy;
        var if_blocked_dx = flags.if_blocked_dx, if_blocked_dy = flags.if_blocked_dy;
        var if_unblocked2_dx = flags.if_unblocked2_dx, if_unblocked2_dy = flags.if_unblocked2_dy;
        var if_unblocked3_dx = flags.if_unblocked3_dx, if_unblocked3_dy = flags.if_unblocked3_dy;
        //var capture_at_dx = flags.capture_at_dx, capture_at_dy = flags.capture_at_dy;
        var mark_ep_target_dx = flags.mark_ep_target_dx, mark_ep_target_dy = flags.mark_ep_target_dy;

        // Positive is forwards, so mirror for black.
        if (color === "black") {
            rel_y = -rel_y;
            // Reverse any embedded relative coordinates.
            if (if_unblocked_dy) { if_unblocked_dy = -if_unblocked_dy; }
            if (if_blocked_dy) { if_blocked_dy = -if_blocked_dy; }
            if (if_unblocked2_dy) { if_unblocked2_dy = -if_unblocked2_dy; }
            if (if_unblocked3_dy) { if_unblocked3_dy = -if_unblocked3_dy; }
            //if (capture_at_dy) { capture_at_dy = -capture_at_dy; }
            if (mark_ep_target_dy) { mark_ep_target_dy = -mark_ep_target_dy; }
        }

        x = rel_x + (flags.absolute_x ? 0 : start_x);
        y = rel_y + (flags.absolute_y ? 0 : start_y);

        abs_move = {x: x, y: y};

        // Default to limiting movement based on board dimensions, but
        // allow boards to also limit based on a river or palace
        var x1 = 1, y1 = 1, x2 = GAME_STATE.files, y2 = GAME_STATE.ranks;
        if (GAME_STATE.boundaries[piece.type]) {
            var boundary = GAME_STATE.boundaries[piece.type][color];

            x1 = boundary[0];
            y1 = boundary[1];
            x2 = boundary[2];
            y2 = boundary[3];
        }

        if (x < x1 || y < y1 || x > x2 || y > y2) {
            // Out of bounds
            blocked[rel_x + "," + rel_y] = true;
            continue;
        }

        var dest_square = VBOARD[x][y];
        var capture_piece = dest_square.piece;

        // If there is any piece there, it may block other moves
        if (capture_piece) {
            blocked[rel_x + "," + rel_y] = true;

            if (flags.if_blocked_skip) {
                i += flags.if_blocked_skip;
            }
        
            // Can't move to self-occupied square
            if (capture_piece.color === color) {
                // Castling moves can never guard, since the destination must be unoccupied
                if (!flags.if_can_castle) {
                    // to indicate we are guarding this piece
                    blocked_moves.push(abs_move);
                }

                if (flags.if_can_castle) {
                    // You move your king over your rook to castle, so this _can_ be legal.
                    if (!PIECE_TYPES[capture_piece.type].castle && !PIECE_TYPES[capture_piece.type].castles_with) {
                        continue;
                    }
                } else {
                    // Non-castling move to self-occupied square is illegal
                    continue;
                }
            }

            // Can't move to invincible piece
            if (PIECE_TYPES[capture_piece.type].invincible) {
                continue;
            }

            // For move notations
            abs_move.capture = capture_piece;
        } 

        // Must be a capture
        if (flags.capture_only && !capture_piece) {
            continue;
        }

        // Must not be capture
        if (flags.no_capture && capture_piece) {
            continue;
        }

        // TODO: Does piece_moved() need to be virtualized?
        if (flags.initial_only && piece_moved(piece)) {
            continue;
        }

        // Blocked by an obstruction. Can check for up to three spaces. To check
        // more, chain the moves. 
        var key;
        if (if_unblocked_dy !== undefined) {
            key = if_unblocked_dx + "," + if_unblocked_dy;

            // If was either blocked by a previous move (faster), or there is a
            // piece there but it wasn't a valid move. For example, elephant (2X)
            // can be blocked, since it is not a leaper (sticking the elephant's eye),
            // non-hippogonal rider.
            if (blocked[key] || pc_or_offboard(if_unblocked_dx + start_x, if_unblocked_dy + start_y)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }

        // Only if *is* blocked
        if (if_blocked_dy !== undefined) {
            key = if_blocked_dx + "," + if_blocked_dy;
            if (!blocked[key] && !pc_or_offboard(if_blocked_dx + start_x, if_blocked_dy + start_y)) {
                continue;
            }
        }

        if (if_unblocked2_dy !== undefined) {
            key = if_unblocked2_dx + "," + if_unblocked2_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked2_dx + start_x, if_unblocked2_dy + start_y)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }
        if (if_unblocked3_dy !== undefined) {
            key = if_unblocked3_dx + "," + if_unblocked3_dy;
            if (blocked[key] || pc_or_offboard(if_unblocked3_dx + start_x, if_unblocked3_dy + start_y)) {
                blocked[rel_x + "," + rel_y] = true;
                continue;
            }
        }

        // Snap back after moving - for guns
        if (flags.snapback !== undefined) {
            abs_move.snapback = true;
        }
       
        // Self-destruct - for kamikaze pieces 
        if (flags.self_destruct !== undefined) {
            abs_move.self_destruct = true;
        }


        // Map pawn moves to what the en passant target will be if
        // the pawn moves there.

        if (!is_hypothetical) {
           if (mark_ep_target_dx !== undefined) {
                abs_move.create_ep_target = [
                    mark_ep_target_dx + start_x, 
                    mark_ep_target_dy + start_y];
            }

        }

        // Only valid if this move is to an ep target.
        if (flags.if_ep_target) {
            if (!GAME_STATE.ep_target || GAME_STATE.ep_target[0] !== x ||
                GAME_STATE.ep_target[1] !== y)  {
                continue;
            }

            abs_move.en_passant_capture = true;
        }

        // Castling moves
        if (flags.if_can_castle) {
            // long=a-side, short=h-side, but exact file depends on castles_come_from()
            var castle_side = flags.if_can_castle;
            // Where the "castle" (such as a rook, NOT the king) comes from
            var castle_from_file = castles_come_from()[castle_side + "_file"];
            var castle_from_x = castle_from_file.charCodeAt(0) - "a".charCodeAt(0) + 1;

            // Moved and lost castling privileges
            if (!GAME_STATE.can_castle[color][castle_from_file]) {
                continue;
            }

            // Can't castle if in check
            if (GAME_STATE.active_in_check) {
                continue;
            }


            var found = false;
            var goes_to;

            // King captures rook
            abs_move.x = castle_from_x;

            if (castle_from_x < start.x) {
                // a-side castling
                abs_move.notation_override = "O-O-O";
                goes_to = GAME_STATE.castle_moves.clong;
            } else if (castle_from_x > start.x) {
                // h-side castling
                abs_move.notation_override = "O-O";
                goes_to = GAME_STATE.castle_moves.cshort;
            } else {
                assert(false, "castling: castle_from_x === start.x (" + castle_from_x + " === " + start.x + ")");
            }

            var first_rank = color === "white" ? 1 : GAME_STATE.ranks;
            var castle_piece = VBOARD[castle_from_x][first_rank].piece;
            if (!castle_piece) {
                continue;
            }

            // Check the path that the rook takes during castling.
            // It must be unobstructed, otherwise castling is temporarily not possible.
            if (!dojo.every(inclusive_range(castle_from_x, goes_to.castle_to), function(x) {
                var piece_between = VBOARD[x][first_rank].piece;
                if (piece_between && 
                        piece_between.unique_id !== piece.unique_id &&          // king can be in the way
                        piece_between.unique_id !== castle_piece.unique_id) {   // this rook only " " "
                    if (PREFS.show_castling_impediments) {
                        push_highlight(sq(x,1),"orange");
                    }
                    return false;
                }

                // Return true if unblocked, or false if blocked and this move is invalid
                return true;
            })) {
                continue;
            }

            // King's path must be unobstructed, too.
            if (!dojo.every(inclusive_range(start.x, goes_to.king_to), function(x) {
                var piece_between = VBOARD[x][first_rank].piece;
                if (piece_between && 
                        piece_between.unique_id !== piece.unique_id &&          // king can be in the way
                        piece_between.unique_id !== castle_piece.unique_id) {   // castling rook only " " "
                    if (PREFS.show_castling_impediments) {
                        push_highlight(sq(x,1),"darkorange");
                    }
                    return false;
                }

                // Check that the king is not moving through check on its path
                for (var attack_from in VALID_MOVES_OPP) {
                    if (VALID_MOVES_OPP.hasOwnProperty(attack_from)) {
                        var attacks = VALID_MOVES_OPP[attack_from];
                        for (var k = 0; k < attacks.length; k += 1) 
                        {
                            var attack = attacks[k];

                            if (attack.x === x && attack.y === first_rank) {
                                return false;
                            }
                        }
                    }
                }

                return true;
            })) {
                continue;
            }
        }

        // Capture at relative location, instead of at destination square.
        // Not actually implemented. En passant capture location is hardcoded.
        /*
        if (capture_at_dx !== undefined) {
           var cx = capture_at_dx + start_x, cy = capture_at_dy + start_y;

           if (cx < 1 || cy < 1 || cx > GAME_STATE.ranks || cy > GAME_STATE.files) {
               continue;
           }

           var capture = VBOARD[cx][cy].piece;
           //console.log("C",xy2filerank([cx,cy]));
           if (capture) {
               abs_move.capture = capture;
           } else {
               // Nothing there to capture.
               continue;
           }
        }*/

        // TODO: faster check checking? maybe split into:
        // 1. if not in check, can't move into
        //   a. can't move a pinned piece that would cause check, unblocks attack
        //   b. can't move royal piece into attacked square
        // 2. if in check, must move out of
        //   a. move royal piece (if double check, only can move)
        //   b. capture with another piece
        //   c. block with another piece
        if (!is_hypothetical && would_check(piece, abs_move, color)) { 
            continue; 
        }

        if (would_promote(piece, abs_move)) {
            // Expand promotions; make a move for each piece you can promote to
            for (var j = 0; j < piece_info.promote.length; j += 1) {
                var prom_move = {promote_to: piece_info.promote[j]};

                dojo.mixin(prom_move, abs_move);
               
                moves.push(prom_move);
            }
        } else {
            // Just one move
            moves.push(abs_move);
        }
    }

    var unique = [];
    var unique_xy = {};

    // Remove/merge duplicate absolute moves. They must be removed after
    // making absolute, not when they are relative, since riders may have
    // multiple rays that need to be blocked (such as the griffon).
    for (var i = 0; i < moves.length; i += 1) {
        var move = moves[i];
        var key = move.x + "," + move.y + "," + move.promote_to;

        if (!unique_xy[key]) {
            unique.push(move);
            unique_xy[key] = unique.slice(-1);
        } else {
            // Merge flags
            dojo.mixin(unique_xy[key], move);
        }
    }

    return {legal:unique, blocked:blocked_moves};
}

// Rotate a direction vector by the given number of degrees, clockwise,
// rounded to nearest 45 degree multiple.
//
// Example:
//
//  rotate_direction([0,1], 180) === [0,-1]
//
function rotate_direction(vector, degrees)
{
    var rotate45 = {
        v01: [1,1],
        v11: [1,0],
        v10: [1,-1],
        "v1-1": [0,-1],
        "v0-1": [-1,-1],
        "v-1-1": [-1,0],
        "v-10": [-1,1],
        "v-11": [0,1]
    };
    // TODO: support non-unit vectors, like [0,2] hippogonal rider moves?
    // Could get complicated.

    if (degrees < 0) {
        degrees = 360 - (-degrees);
    }

    var ticks = Math.round(degrees / 45);

    for (var i = 0; i < ticks; i += 1) {
        var vector_string = "v" + vector[0] + vector[1];

        vector = rotate45[vector_string];
        assert(vector !== undefined, "rotate_direction(" + vector + ", " + degrees + "): failed to rotate " + vector_string);
    }


    return vector;
}

// Return {vectors, consumed}. The vectors are positive for forward/right, 
// negative for backwards/left. Consumed is number of characters, 1 or 2.
function relative_decode_direction(ch, ch2)
{
    var vectors, consumed;

    consumed = 1;
    if (ch === "+") { 
        // orthogonally four possible directions
        vectors = [[1, 0], [0, 1], [-1, 0], [0, -1]];
    } else if (ch === "=") {
        // orthogonally sideways
        vectors = [[1, 0], [-1, 0]];
    } else if (ch === ">") {
        if (ch2 === "=") {
            // >= orthogonally forwards or sideways
            vectors = relative_decode_direction(">", undefined).vectors.concat(relative_decode_direction("=", undefined).vectors);
            consumed += 1;
        } else if (ch2 === ">") {
            // >> right (Extended Parlett)
            vectors = [[1, 0]];
            consumed += 1;
        } else {
            // > orthogonally forward
            vectors = [[0, 1]];
        }
    } else if (ch === "<") {
        if (ch2 === ">") {
            // <> orthogonally forwards and backwards
            vectors = [[0, 1], [0, -1]];
            consumed += 1;
        } else if (ch2 === "=") {
            // <= orthogonally backwards or sideways
            vectors = relative_decode_direction("<", undefined).vectors.concat(relative_decode_direction("=", undefined).vectors);
            consumed += 1;
        } else if (ch2 === "<") {
            // << left (Extended Parlett)
            vectors = [[-1, 0]];
            consumed += 1;
        } else {
            // < orthogonally backwards
            vectors = [[0, -1]];
        }
    } else if (ch === "X") { 
        if (ch2 === ">") {
            // X> diagonally forwards
            vectors = [[1, 1], [-1, 1]];
            consumed += 1;
        } else if (ch2 === "<") {
            // X< diagonally backwards
            vectors = [[1, -1], [-1, -1]];
            consumed += 1;
        } else {
            // X diagonally four possible directions
            vectors = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        }

    // Unicode arrows - see http://www.alanwood.net/unicode/arrows.html for a
    // good list - since we were running out of ASCII..
    } else if (ch === "↖") {
        // ↖ diagonally left up (Extended Parlett)
        vectors = [[-1, 1]];
    } else if (ch === "↗") {
        // ↗ diagonally right up (Extended Parlett)
        vectors = [[1, 1]];
    } else if (ch === "↘") {
        // ↘ diagonally right down (Extended Parlett)
        vectors = [[1, -1]];
    } else if (ch === "↙") {
        // ↙ diagonally left down (Extended Parlett)
        vectors = [[-1, -1]];

    } else if (ch === "*") {    
        // orthogonally or diagonally (eight possible directions)
        vectors = relative_decode_direction("+", undefined).vectors.concat(relative_decode_direction("X", undefined).vectors);
    } else {
        assert(false, "relative_decode_direction('" + ch + "', '" + ch2 + "'): invalid direction");
    }

    return {vectors:vectors, consumed:consumed};
}

// Attempt to parse an integer in base 10, but if it fails, return the input.
function parseInt10(x) 
{ 
    var number = parseInt(x, 10); 

    return isNaN(number) ? x : number;
}

// Parse semicolon separated flags, possibly key/value pairs
// foo;bar sets foo:true and bar:true, can also set relative coordinates:
// if_unblocked=1,2.
function parse_move_flags(text, flags)
{
    var flags_text;

    if (flags === undefined) {
        flags = {};
    }

    if (dojo.isArray(text)) {
        flags_text = text;
    } else {
        flags_text = text.split(";");
    }

    // Semicolon-separated flags
    for (var i = 0; i < flags_text.length; i += 1) {
        var flag_text = flags_text[i];
        var value;
       
        // Allow if_unblocked=0,1, etc.
        if (flag_text.indexOf("=") !== -1) { 
            // Unfortunately, need JavaScript 1.8 to do [x,y] = ...
            var ary = flag_text.split("=");
            var left = ary[0], right = ary[1];
            value = right.split(",");
            value = dojo.map(value, parseInt10);
            if (value.length === 1) {
                flags[left] = value[0];
            } else if (value.length === 2) {
                flags[left + "_dx"] = value[0];
                flags[left + "_dy"] = value[1];
            } else {
                assert(false, "parse_move_flags(" + text + ", " + flags + "): not 1 or 2 elements: " + value);
            }
        } else {
            flags[flag_text] = true;
        }
    }

    return flags;
}

// Decode the Extended Parlett {} construct, which adds flags
// to arbitrary move text. {parlett, flags}
function nested_flags(parlett)
{
    var rel_moves, flags_text, flags;
    
    flags_text = parlett.split(";");
    // Do not cache, since can be modified
    rel_moves = dojo.clone(unfiltered_moves(flags_text.shift()));

    flags = parse_move_flags(flags_text);

    for (var flag in flags) {
        if (flags.hasOwnProperty(flag)) {
            for (var j = 0; j < rel_moves.length; j += 1) {
                rel_moves[j][2][flag] = flags[flag];
            }
        }
    }

    return rel_moves;
}

// Decodes an explicit relative move that was in square brackets: [0,2;initial_only]
function decode_explicit_move(text_move, existing_flags)
{
    var xy_text_flags, xy_text, xy, x, y, flags;
    
    xy_text_flags = text_move.split(";");
    xy_text = xy_text_flags.shift();

    if (xy_text.indexOf(",") !== 0) {
        // Relative x,y
        xy = xy_text.split(",");
        x = parseInt(xy[0], 10);
        y = parseInt(xy[1], 10);
    } else {
        // TODO: call decode_one_parlett, to allow
        // [oi2>;flags] or oi[2>;flags], etc.
        assert(false, "decode_explicit_move(" + text_move + ", " + existing_flags + "): not [x,y;flags], missing comma");
    }

    flags = parse_move_flags(xy_text_flags, existing_flags);

    return [x, y, flags];
}

// Decode a Parlett notation into a list of [x,y,flags], where
// x and y are destinations relative to the piece origin, and flags describes
// under what conditions the move can be made. + is forward, - is backwards,
// from the perspective of the active color. Has no knowledge of board state.
// The moves must be filtered to determine their validity.
// TODO: Other notations?
function decode_one_parlett(parlett)
{
    var distances, directions, flags, movement, rel_moves, limit, inner_moves, rotates;
    var hippogonal = false, hopper = false;

    flags = {};
    distances = [];
    rotates = [];
    rel_moves = [];
    movement = "rider";

    // Hippogonal riders, like the nightrider, can be specified as 
    // either ~1/2& or n(~1/2). The first notation, due to David Parlett's
    // _The Oxford History of Board Games_, is less flexible but more compact.
    if (parlett.substr(parlett.length - 1) === "&") {
        parlett = "n(" + parlett.substr(0, parlett.length - 1) + ")";
    }

    for (var i = 0; i < parlett.length; i += 1) {
        var ch = parlett.substr(i, 1);

        if (ch === "~") {
            movement = "leaper";
            // TODO: "darters", blockable 'leapers' - 1//2, elban knight, mao (0,1 then 1,1), moa (1,1 then 0,1)
            // http://www.mayhematics.com/v/v_gm.htm

        // Flags, documented on http://en.wikipedia.org/wiki/Fairy_chess_piece#Additions_to_Parlett.27s
        } else if (ch === "i") { 
            // Initial move: Can only if the piece is in its original position
            // (pawn's 2 move forward)
            flags.initial_only = true;
        } else if (ch === "c") {
            // Capture only: may only be used if destination is occupied by enemy piece
            // (pawn's diagnal capture)
            flags.capture_only = true;
        } else if (ch === "o") {
            // Can not capture: destination square must be unoccupied; since by default, piece
            // can move to enemy square in order to capture it
            // (pawn's forward move)
            flags.no_capture = true;
        
        // Hopping rider
        } else if (ch === "^") {
            hopper = true;

        // Grouping
        } else if (ch === "(") {
            var inner_move_text = "";
            var nest_level = 1;
            while(i < parlett.length)
            {
                i += 1;
                var chi = parlett.substr(i, 1);
                if (chi === ")") { nest_level -= 1; }
                if (chi === "(") { nest_level += 1; }
                if (nest_level === 0) { break; } 

                inner_move_text += chi;
            }

            inner_moves = unfiltered_moves(inner_move_text);

        // Extended Parlett
        
        // Include an existing piece movement, possibly with flags
        } else if (ch === "#") {
            var type = parlett.substr(i + 1);
            assert(PIECE_TYPES[type], "in Parlett #include, piece name not found: " + type);
            var included = dojo.clone(unfiltered_moves(PIECE_TYPES[type].parlett));

            for (i = 0; i < included.length; i += 1) {
                dojo.mixin(included[i][2], flags);
            }

            return included;

        // Direct move text: [rel_x,rel_y;flag1;flag2;...] 
        } else if (ch === "[") {
            var text_move = "";
            var nest_level = 1;
            while(i < parlett.length)
            {
                i += 1;
                var chi = parlett.substr(i, 1);
                if (chi === "]") { nest_level -= 1; }
                if (chi === "[") { nest_level += 1; }
                if (nest_level === 0) { break; } 

                text_move += chi;
            }
            rel_moves.push(decode_explicit_move(text_move, flags));

        // Nested flags: {oi2>, asdf.. ;flag1;flag2;flag3...}
        } else if (ch === "{") {
            var inner, nest;
            
            inner = "";
            nest = 1;
            while(i < parlett.length)
            {
                i += 1;
                var cho = parlett.substr(i, 1);
                if (cho === "}") { nest -= 1; }
                if (cho === "{") { nest += 1; }
                if (nest === 0) { break; } 

                inner += cho;
            }

            return nested_flags(inner);

        // Limit on distances, for diminished pieces
        } else if (ch === ".") {
            // Only one digit for now
            limit = parseInt(parlett.substr(i + 1, 1), 10);
            i += 1;

        // Rotating riders
        } else if (ch === "\\") {
            var inner, ary;
            
            inner = "";
            while(i < parlett.length)
            {
                i += 1;
                var cho = parlett.substr(i, 1);
                if (cho === "\\") { break; }

                inner += cho;
            }

            // List of rotations in degrees, like \\45,-45\\
            ary = inner.split(",");
            for (var k = 0; k < ary.length; k += 1) {
                rotates.push(parseInt(ary[k], 10));
            }

        // Standard Parlett
        } else if (/[0-9]/.test(ch)) {
            distances.push(parseInt(ch, 10));
        } else if (ch === "n" || ch === "m") {
            distances.push(Infinity);
        } else if (ch === "/") {
            hippogonal = true;
        } else if (ch === " ") {
            assert(false, "decode_one_parlett(" + parlett + "): whitespace encountered, did you forget a comma?");
        } else {
            var maybe_directions = relative_decode_direction(ch, parlett.substr(i + 1, 1));

            if (maybe_directions) {
                directions = maybe_directions.vectors;
                if (maybe_directions.consumed > 1) {
                    i += maybe_directions.consumed - 1; // two-character (or more) direction
                }
            } else {
                assert(false, "decode_one_parlett(" + parlett + "): unsupported: '" + ch + "'");
            }
        }
    }

    if (hippogonal) {
        assert(!hopper, "decode_one_parlett(" + parlett + "): sorry, hippogonal hoppers are not supported");
        assert(distances.length === 2, "decode_one_parlett(" + parlett + "): for hippogonal, expected exactly two distances");
        var a = distances[0], b = distances[1];

        if (a !== Infinity && b !== Infinity) {
            // Hippogonals in all directions
            // TODO: support direction modifiers, vector
            rel_moves.push.apply(rel_moves, without_dupes([
                [-a, -b, flags],
                [-a, +b, flags],
                [+a, -b, flags],
                [+a, +b, flags],

                [-b, -a, flags],
                [-b, +a, flags],
                [+b, -a, flags],
                [+b, +a, flags]
                ]));
        } else {
            // ~n/m, any square on board. Remember, these are relative moves.
            for (var x = -GAME_STATE.files; x <= +GAME_STATE.files; x += 1) {
                for (var y = -GAME_STATE.ranks; y <= +GAME_STATE.ranks; y += 1) {
                    rel_moves.push([x, y, flags]);
                }
            }
        }

        // Hippogonal can be optionally bounds by direction
        if (directions) {
            var keep_relmoves = [];

            for (i = 0; i < directions.length; i += 1) {
                var dir = directions[i];

                for (var j = 0; j < rel_moves.length; j += 1) {
                    var move = rel_moves[j];

                    if ((!dir[0] || signum(move[0]) === signum(dir[0])) &&
                        (!dir[1] || signum(move[1]) === signum(dir[1]))) {
                        keep_relmoves.push(move);
                    }
                }
            }

            rel_moves = keep_relmoves;
        }

    } else if (directions) {
        expand_directions(directions, distances, limit, flags, movement, rel_moves, rotates, hopper);
    }


    // Expand grouping
    if (inner_moves) {
        var outer_moves = rel_moves;
        rel_moves = [];

        if (distances[0]) {
            if (distances[0] === Infinity || !distances[0]) {
                // Close enough
                distances[0] = 5;
            }

            // Nightrider-like piece (hippogonal rider)
            expand_directions(inner_moves, [], distances[0], flags, movement, rel_moves, rotates, hopper);
        }

        // Add inner and outer moves, if both were given, for gryphon, slip pieces
        for (i = 0; i < outer_moves.length; i += 1) {
            var outer = outer_moves[i];

            for (var j = 0; j < inner_moves.length; j += 1) {
                var inner = inner_moves[j];

                var flags = {};
                dojo.mixin(flags, inner[2]);
                dojo.mixin(flags, outer[2]);

                rel_moves.push([outer[0] + inner[0], outer[1] + inner[1], flags]);
            }
        }
    }

    return rel_moves;
}

// Expand a piece in the given directions, distances, up to
// an optional limit, pushing the moves to rel_moves.
// directions: array of direction vectors
// distances: length from origin in direction, often an Infinity
// limit: maximum distance to go in direction, or Infinity
// flags: move flags to add
// movement: "rider" or "leaper"
// rotates: array of degrees to rotate moves after each step
// TODO: hopper: whether a intervening piece (hurdle) is required in the direction to be able to move
function expand_directions(directions, distances, limit, flags, movement, rel_moves, rotates, hopper)
{
    for (i = 0; i < directions.length; i += 1) {
        var dir = directions[i];

        var rel_x, rel_y, prev_rel_x, prev_rel_y, distance;

        // Optional explicit distance instead of all in between (n)
        // Example: 2X, can only move two diagonally, unblocked
        if (distances.length !== 0) {
            distance = distances[0];

            assert(distances.length === 1, "expand_directions(" + distances + "): multiple distances given for rider, expected one or none");
        } else {
            distance = Infinity;
        }

        rel_x = rel_y = 0;
        prev_rel_x = null;
        prev_rel_y = null;

        // Iterate to either given limit or maximum
        var max = limit || Math.max(GAME_STATE.ranks, GAME_STATE.files);

        var count = 0;

        for (var j = 1; j <= max; j += 1) {
            var these_flags = {};

            if (rotates) {
                dir = rotate_direction(dir, rotates[j % rotates.length]);
            }

            // Riders get blocked. Note that you can have a non-hippogonal leaper.
            // ~n* for example, is like a queen, but not blocked by intervening pieces.

            // Blocked on a square which you CANNOT move to - riders w/ distance limits
            if (prev_rel_x !== null && prev_rel_y !== null && 
                    movement === "rider" && distance !== Infinity) { 
                // TODO: Support multiple squares. This only works for one square, for
                // pawn's double-moves. 2> means two forward, unblocked, and it works,
                // but 3> for three forward, unblocked, won't work yet.
                assert(distance === 2,
                        "expand_directions: sorry, only a fixed distance of 2 is " + 
                        "currently supported for riders");

                these_flags.if_unblocked_dx = prev_rel_x;
                these_flags.if_unblocked_dy = prev_rel_y;

            }

 
           // Directions - these were either specified by direction vector code
            // as in n* or hippogonally using ~1/2& (both these expand to >1 direction)
            rel_x += dir[0];
            rel_y += dir[1];

            if (hopper) {
                // Hoppers require a blocking piece (hurdle)
                if (prev_rel_x !== null) {
                    these_flags.if_blocked_dx = prev_rel_x;
                    these_flags.if_blocked_dy = prev_rel_y;

                    // TODO: only allow hopping over one piece (not an overhopper)
                    //these_flags.if_blocked_skip = max - count - 1;
                }  else {
                    // This is one square away from the moving piece.
                    // Skip this move, since no hurdle can fit within in here.
                    // But, set previous x and y since they won't be set at the end
                    // of the loop since we're continue'ing out of it.
                    prev_rel_x = rel_x;
                    prev_rel_y = rel_y;
                    continue;
                }
            }


            dojo.mixin(these_flags, flags);

            // Blocked by a square which you CAN move to - riders w/ no limits except board dimensions
            if (distance === Infinity && movement === "rider" && !hopper) {
                these_flags.if_blocked_skip = max - count - 1;
            }

            if (distance === Infinity || j === distance) {
                rel_moves.push([rel_x, rel_y, these_flags]);
                count += 1;

                if (j === distance) { 
                    break;
                }
            }

            prev_rel_x = rel_x;
            prev_rel_y = rel_y;
        }
    }
}

// Return an array of objects without any duplicate entries, where
// duplicity is determined by string equality. This is ugly, but
//    [1,2] in [[1,2], [3,4]]
// is false, since 
//    [1,2] === [1,2]
// is false, so its not easy (as far as I could tell) to check if
// a complex element is already in an array before adding it. Worse yet,
// hash keys can't be complex, so for example the set implementation at
// http://laurens.vd.oever.nl/weblog/items2005/setsinjavascript/ , even
// modified to use Prototype's Hash, won't do because the keys will be 
// converted to strings. But at least the ugliness is confined to this function.
// Note: flags also differentiate a move.
function without_dupes(a)
{
    var hash = {};
    var result = [];

    for (var i = 0; i < a.length; i += 1) {
        // Add if not a dupe
        if (!hash[dojo.toJson(a[i])]) {
            result.push(a[i]);
        }

        // Record that this element was added. Converts to a string,
        // unfortunately, so can't just use own_properties() after filling 
        // in the hash.
        hash[dojo.toJson(a[i])] = true;
    }

    return result;
}

//// TURN FUNCTIONS

function opposite_color(color)
{
    return {white: "black", black: "white"}[color];
}

function update_check()
{
}

// Set the active color to white or black, or go to the next color (toggling).
// Returns a character for algebraic notation, + = check, etc., if applicable
// If historical, do not check for threefold repetition.
function set_turn(color, historical)
{
    var new_color, checked, no_moves, text_move, text_end, old_color, old_fullmove, repeats;

    old_color = GAME_STATE.active_color;

    if (color === "next") {
        new_color = opposite_color(GAME_STATE.active_color);
    } else if (color === "black" || color === "white") {
        new_color = color;
    } else if (color === "ask") {
        new_color = confirm("Do you want black to start first?") ? "black" : "white";
    } else {
        assert(false, "set_turn(" + color + "): invalid color");
    }

    dojo.byId("status").innerHTML = ucfirst(new_color) + "'s Turn";

    // Move number is incremented after black moves, according to rules.
    old_fullmove = GAME_STATE.fmvn;
    if (color === "next" && GAME_STATE.active_color === "black") {
        GAME_STATE.fmvn += 1;
    }

    GAME_STATE.active_color = new_color;
   
    // Active player in check?
    var all_opp = calculate_moves(opposite_color(new_color), true);
    VALID_MOVES_OPP = all_opp.moves;
    BLOCKED_MOVES_OPP = all_opp.blocked;
    checked = GAME_STATE.active_in_check = in_check(GAME_STATE.active_color, VALID_MOVES_OPP);

    // Note: this takes some time... is there any way to run it right AFTER the piece has
    // gone through the endeffect? This is called in onDrop.
    // TODO: find out how to run something *after* the endeffect, for smoother UI.
    calculate_moves(GAME_STATE.active_color);

    // Zero mobility? For detecting stalemate, checkmate.
    no_moves = own_property_count(VALID_MOVES) === 0;

    // Results. 
    if (checked && !no_moves) {
        set_check_message("Check!");
        text_move = "+";
        // TODO: detect double-check, allow ++ for descriptive/algebraic descriptive, but not algebraic
    } else if (!checked && no_moves) {
        if (GAME_STATE.stalemate === undefined) {
            // Usual rules: stalemate is a draw
            set_check_message("Draw (stalemate)");
            text_end = "&frac12;-&frac12;";

        // Other rules for stalemate for variants, see:
        // http://en.wikipedia.org/wiki/Stalemate#History_of_the_stalemate_rule
        } else if (GAME_STATE.stalemate === "win") {
            // Win for player administering the stalemate (Shatranj, medieval Europe)
            set_check_message(ucfirst(old_color) + " wins (stalemate)");
            text_end = old_color === "white" ? "1-0" : "0-1";
        } else if (GAME_STATE.stalemate === "halfwin") {
            set_check_message(ucfirst(old_color) + " half-wins (stalemate)");
            text_end = old_color === "white" ? "&frac12;-0" : "0-&frac12;";
        } else if (GAME_STATE.stalemate === "loss") { 
            // Win for player being stalemated (9th century India)
            set_check_message(ucfirst(new_color) + " wins (stalemate)");
            text_end = new_color === "white" ? "1-0" : "0-1";
        } else {
            assert(false, "set_turn: invalid stalemate rule: " + GAME_STATE.stalemate);
        }
    } else if (checked && no_moves) {
        set_check_message("Checkmate.");
        if (new_color === "white") { 
            text_move = "#";
            text_end = "0-1";  // white lost
        } else {
            text_move = "#";
            text_end = "1-0";
        }
    } else if (check_insufficient_material()) {
        set_check_message("Draw (material)");
        text_end = "&frac12;-&frac12;";
    } else if (GAME_STATE.hmvc >= 50) {
        set_check_message("Draw (fifty move) claimable");
    } else {
        set_check_message("");
    }

    if (text_end) {
        // So can programmatically tell the game is finished.
        GAME_STATE.ended = text_end;
    }

    var new_state = save_fen();

    var ply = encode_ply(old_color, old_fullmove);

    if (!old_color) {
        // If no one has moved yet, ply is 0 for initial board position.
        ply = 0;
    }

    if (!historical) {
        repeats = check_repetition(ply);
    }
    
    if (color === "next") { 
        GAME_STATE.position_after[ply] = new_state;
    }
    
    set_copyable_link();

    return {text_move: text_move, text_end: text_end, repeats: repeats};
}

// Update the copyable link that goes to the board state
// If this_position, then exports the current board state, otherwise,
// exports the previous board state plus the last move.
function set_copyable_link(this_position)
{
    var fen, captured, last, prior, perspective, url;

    if (this_position) {
        fen = save_fen();
        captured = export_captured();
        perspective = GAME_STATE.flipped;
    } else {
        last = GAME_STATE.position_after.slice(-1)[0];
        prior = GAME_STATE.position_after.slice(-2)[0];

        // TODO: up to N last moves
        var last_move = GAME_STATE.made_moves.slice(-1)[0];

        if (last_move) {
            // Store the previous move and the board state _before_ the move,
            // so it can be made.
            last_move = ";m=" + last_move.notations[form_value("output_notation")];
            if (!prior) {
                // No move has been made yet
                dojo.byId("copyable_link").href = document.URL;
                return;
            }

            fen = prior;
        } else {
            last_move = "";
            fen = last;
        }

        captured = GAME_STATE.last_captured;

        // Flipped if black's turn
        perspective = GAME_STATE.active_color === "black" ? ";f=1" : "";
    }

    if (captured) {
        captured = ";c=" + captured;
    } else {
        captured = "";
    }

    url = make_copyable_link(fen) + captured + last_move + perspective;
    dojo.byId("copyable_link").href = url;

    if (document.URL.indexOf("file:") === 0 || !CLIPBOARD) {
        dojo.byId("copy_link").onclick = function() {
            prompt("Manually copy this:", email_board(true));
        };
    } else {
        CLIPBOARD.setText(email_board(true));
    }

}

// Make a URL that can be clicked to go to this board state
function make_copyable_link(fen)
{
    var base, base_split, query, href;

    assert(fen, "make_copyable_link(" + fen + "): board is required");

    // Get current URL without query string
    base_split = document.URL.split("?");
    base = base_split[0];

    // Replace with characters that do not need to be encoded
    fen = fen.replace(/ /g, "~").replace(/\//g, "|");
    query = "?b=" + encodeURIComponent(fen);

    href = base + query;

    return href;
}

// Set the game check status (or draw, checkmate) message.
function set_check_message(msg)
{
    dojo.byId("check").innerHTML = msg;
    dojo.byId("dash").style.display = msg ? "" : "none";
}

// Return whether there is insufficient material to mate
function check_insufficient_material()
{
    var counts = {}, total = 0, total_bishops = 0;
    var bishops = {white:{white:0, black:0}, black:{white:0, black:0}};
   
    // Count how many of each piece type are on the board
    // TODO: piece lists?
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var square = VBOARD[x][y];

            if (square.piece) {
                // Count all pieces
                if (counts[square.piece.type] === undefined) {
                    counts[square.piece.type] = 1;
                } else {
                    counts[square.piece.type] += 1;
                }
                total += 1;

                // Count color of bishops and squares they are bound to
                if (square.piece.type === "bishop") {
                    bishops[square.color][square.piece.color] += 1;
                    total_bishops += 1;
                }
            }
        }
    }

    // FIDE rules 
    if (total === 2 && counts.king === 2) {
        // king v. king
        return true;
    } else if (total === 3 && counts.king === 2) {
        // king v. king + bishop
        // king v. king + knight
        return counts.bishop === 1 || counts.knight === 1;
    } else if (total === total_bishops + 2 && counts.king === 2 && 
            (bishops.black.black === bishops.black.white ||
             bishops.white.black === bishops.white.white)) {
        // king and bishop(s) versus king and bishop(s) all on same color
        return true;
    }

    return false;
}

// Check for three-move repetition, which allows a draw to be claimed (not compulsory)
function check_repetition(ply)
{
    var new_state = active_fen(true);
    var reps;

    // Save new board state for three-move repetition
    if (GAME_STATE.position_moves[new_state] === undefined) {
        GAME_STATE.position_moves[new_state] = [ply];
    } else {

        reps = GAME_STATE.position_moves[new_state].slice();

        // This occurred here, too.
        GAME_STATE.position_moves[new_state].push(ply);

        if (GAME_STATE.position_moves[new_state].length >= 3) {
            // Player can claim a draw, but its not required (you might have a better position)
            // See http://en.wikipedia.org/wiki/Threefold_repetition
            set_check_message("Draw (repetition) claimable");

            // Return moves for highlighting, except this move (it is too early
            // for mark_repeated_moves to highlight, so move_piece_to_square will
            // add the current move, if we return something).
            return reps;
        }
    }

    return null;
}

//// REMOTE SAVED GAME FUNCTIONS
//
// TODO: parse games in PGNs, offer to load
function game_file_list()
{
    dojo.xhrGet({url: PREFS.saved_games_path + "index",
        load:function(text) {
            var array = text.split("\n");

            for (var i = 0; i < array.length; i += 1) {
                var filename = array[i];

                dojo.xhrGet({url: PREFS.saved_games_path + filename,
                    load:function(pgn_text) {
                        var games;
                       
                        // Large files take too long to parse. TODO: web worker?
                        if (pgn_text.length < 1000)
                            games = parse_pgn(pgn_text);

                        console.log(games);

                        var browser = dojo.byId("game-browser");

                        browser.style.display = "";
                        browser.innerHTML += pgn_text.length + "<br>";
                }});
            }
        }});
}

//// DISPLAY FUNCTIONS

// Initially draw a board, saving the image data so it can be quickly redrawn 
function create_board()
{
    var canvas, ctx, board_width, board_height, start_x, start_y, max_x, max_y;
    
    canvas = document.getElementById("canvas-board");
    DISPLAY.canvas = canvas;

    if (!canvas.getContext) {
        alert("Sorry, your browser does not support the HTML5 canvas element.");
        return;
    }

    ctx = canvas.getContext("2d");
    DISPLAY.context = ctx;

    canvas.width = GAME_STATE.files * DISPLAY.square_width + DISPLAY.board_left + DISPLAY.board_border*2;
    canvas.height= GAME_STATE.ranks * DISPLAY.square_height + DISPLAY.board_top + DISPLAY.board_border*2;

    // Border
    ctx.strokeStyle = "#000";
    ctx.lineWidth = DISPLAY.board_border;
    board_width = GAME_STATE.files * DISPLAY.square_width;
    board_height = GAME_STATE.ranks * DISPLAY.square_height;
    ctx.strokeRect(DISPLAY.board_left, 
            DISPLAY.board_top, 
            board_width + DISPLAY.board_border, 
            board_height + DISPLAY.board_border);

    ctx.font = DISPLAY.label_font;

    // Draw features below
    draw_features(false);

    ctx.strokeStyle = "#000";
    ctx.lineWidth = DISPLAY.board_border;

    start_x = 0;
    start_y = 0;
    max_x = GAME_STATE.files;
    max_y = GAME_STATE.ranks;

    if (GAME_STATE.on_intersections) {
        // Fewer lines are needed if the pieces are placed on the line intersections.
        start_y = 1;
        max_x -= 1;
    }
    
    for (var x = 0; x < GAME_STATE.files; x += 1) {
        // File labels
        var file = String.fromCharCode("a".charCodeAt(0) + x);
        ctx.fillStyle = DISPLAY.text_color;
        ctx.fillText(file, 
                DISPLAY.board_left + DISPLAY.file_labels_left + x * DISPLAY.square_width,
                DISPLAY.file_labels_top);
    }

    for (var x = start_x; x < max_x; x += 1) {
        // Squares
        ctx.fillStyle = DISPLAY.white;
        for (var y = start_y; y < max_y; y += 1) {
            var rx, ry, rw, rh;

            if (!GAME_STATE.uncheckered) {
                // TODO: look at VBOARD[x][y].color
                ctx.fillStyle = (x + y % 2) % 2 ? DISPLAY.white : DISPLAY.black;
            }
            rx = get_square_x(x + 1);
            ry = get_square_y(y + 1);
            rw = DISPLAY.square_width;
            rh = DISPLAY.square_height;

            if (GAME_STATE.on_intersections) {
                // Pieces on intersections of lines, instead of squares formed by those lines.
                rx += DISPLAY.square_width / 2;
                ry += DISPLAY.square_height / 2;
            }

            if (!GAME_STATE.transparent) {
                ctx.fillRect(rx, ry, rw, rh);
            }

            if (GAME_STATE.ruled) {
                ctx.strokeRect(rx, ry, rw, rh);
            }
        }
    }

    // Rank labels
    ctx.fillStyle = DISPLAY.text_color;
    ctx.textAlign = "center";
    for (var y = 0; y < GAME_STATE.ranks; y += 1) {
        var rank = GAME_STATE.ranks - y;

        ctx.fillText(rank, DISPLAY.rank_labels_left, 
                DISPLAY.rank_labels_top + DISPLAY.square_height * (y + 1), DISPLAY.board_left);
    }

    ctx.lineWidth = DISPLAY.feature_border_width;

    // Draw features on top
    draw_features(true);

    DISPLAY.clean_board = ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// Board "features": cosmetic embellishments that indicate something
// draw_over determines whether to draw features to be drawn after the board, or before
function draw_features(draw_over)
{
    var ctx = DISPLAY.context;

    if (!GAME_STATE.features) {
        return;
    }

    for (var i = 0; i < GAME_STATE.features.length; i += 1) {
        var feature = GAME_STATE.features[i];
        var rx, ry, rw, rh, color;

        if (!!feature.over !== !!draw_over) {
            continue;
        }

        // White's side first
        if (feature.color === "same") {
            color = DISPLAY.white;
        } else if (feature.color === "opposite") { 
            color = DISPLAY.black;
        } else {
            color = feature.color;
        }

        ctx.strokeStyle = color;
        ctx.fillStyle = color;

        rx = get_square_x(feature.file), 
        ry = get_square_y(feature.rank), 
        rw = feature.width * DISPLAY.square_width, 
        rh = feature.height * DISPLAY.square_height;

        // Shift by half of square, for drawing in between squares.
        // Most useful with on_intersections.
        if (feature.shift_x) {
            rx += DISPLAY.square_width / 2;
        }
        if (feature.shift_y) {
            ry += DISPLAY.square_height / 2;
        }

        draw_feature(ctx, feature, rx, ry, rw, rh);

        // Mirror to black's side of board
        if (feature.color === "same") {
            color = DISPLAY.black;
        } else if (feature.color === "opposite") { 
            color = DISPLAY.white;
        } else {
            color = feature.color;
        }
        ctx.strokeStyle = color;
        ctx.fillStyle = color;

        ry = get_square_y(feature.rank + (GAME_STATE.ranks - feature.height));
        if (feature.shift_y) {
            ry += DISPLAY.square_height / 2;
            // Ugly hack to get black aligned right.
            ry += DISPLAY.square_height;
        }

        draw_feature(ctx, feature, rx, ry, rw, rh);
    }
}

// Draw an individual feature on the board.
function draw_feature(ctx, feature, rx, ry, rw, rh)
{
    if (feature.fill) {
        ctx.fillRect(rx, ry, rw, rh);
    } else if (feature.cross) {
        // Draw an X cross in this area
        ctx.beginPath();

        // \
        ctx.moveTo(rx, ry);
        ctx.lineTo(rx + rw, ry + rh);

        // /
        ctx.moveTo(rx, ry + rh);
        ctx.lineTo(rx + rw, ry);

        ctx.stroke();

    } else {
        ctx.strokeRect(rx, ry, rw, rh);
    }
}


// Restore the board to the clean state, unhighlighting all highlighted black/white squares.
function unhighlight_all()
{
    DISPLAY.highlights = {};
    DISPLAY.context.putImageData(DISPLAY.clean_board, 0, 0);
}

// Get the upper-left x coordinate of a square given file
function get_square_x(file)
{
    return DISPLAY.board_left + DISPLAY.board_border/2 + (file - 1) * DISPLAY.square_width;
}

// Get the upper-left y coordinate of a square given rank
function get_square_y(rank)
{
    return DISPLAY.board_top + DISPLAY.board_border/2 + (GAME_STATE.ranks - rank) * DISPLAY.square_height;
}

// Highlight a square with a given color, or unhighlight it if color is false
function highlight_square(square, color)
{
    var ctx;

    file = square.x;
    rank = square.y;

    ctx = DISPLAY.context;

    if (!color) {
        color = DISPLAY[square.color];
    }

    ctx.fillStyle = color;
    ctx.fillRect(get_square_x(file), get_square_y(rank), DISPLAY.square_width, DISPLAY.square_height);
}

// Push a layer of a highlight color to a square, coloring the square that color.
function push_highlight(square, color)
{
    if (!DISPLAY.highlights[square.filerank] || DISPLAY.highlights[square.filerank].length === 0) {

        var sx = get_square_x(square.x);
        var sy = get_square_y(square.y);
        var sw = DISPLAY.square_width;
        var sh = DISPLAY.square_height;

        DISPLAY.highlights[square.filerank] = [];
        DISPLAY.native_square_images[square.filerank] = DISPLAY.context.getImageData(sx, sy, sw, sh);
    }


    DISPLAY.highlights[square.filerank].push(color);

    highlight_square(square, color);

    return DISPLAY.highlights[square.filerank];
}

// Peel off a highlighted color and reveal the color underneath.
function pop_highlight(square)
{
    var stack, color, old_color;

    stack = DISPLAY.highlights[square.filerank];

    if (!stack || stack.length === 0) {
        // Nothing to pop
        return;
    }

    // Remove current color
    old_color = stack.pop();

    if (!stack || stack.length === 0) {
        // Native square color
        var native_image = DISPLAY.native_square_images[square.filerank];

        assert(native_image, "pop_highlight(" + square.filerank + "): no native image");

        DISPLAY.context.putImageData(native_image, get_square_x(square.x), get_square_y(square.y));

        return native_image;
    } else {
        // Color underneath is now top of stack
        color = stack[stack.length - 1];
        
        highlight_square(square, color);

        return color;
    }
}

//// BOARD FUNCTIONS

// Load the virtual board into the displayed board. Any number of operations
// can be conducted on the virtual in-memory board, then when it is finished,
// only then does the board need to be rendered in HTML. 
function realize_vboard()
{
    var time_started = new Date().getTime();

    // Delete all prior onboard pieces
    dojo.query(".piece").forEach(function(piece) {
            if (!dojo.hasClass(piece, "tear-off")) {
                piece.parentNode.removeChild(piece);
            }
    });

    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            var v = VBOARD[x][y];
            var piece;

            if (v.piece) {
                piece = create_piece(v.piece.color, v.piece.type);
                piece.square = VBOARD[x][y];
                // TODO: what about descriptive_name, adescriptive_name?? It is important.
                piece.unique_id = v.piece.unique_id;

                piece.style.position = "absolute";
                // TODO: get_square_x/get_square_y
                //piece.style.left = 55 * (x - 1) + 20 + "px";
                //piece.style.top = 55 * (GAME_STATE.ranks - y) + 30 + "px";

                piece.style.left = DISPLAY.square_width * (x - 1) + 25 + "px";
                piece.style.top = DISPLAY.square_height * (GAME_STATE.ranks - y) + 30 + "px";


                // TODO: find out why this is off
                //piece.style.left = get_square_x(x) + "px";
                //piece.style.top = get_square_y(y) + "px";
                dojo.body().appendChild(piece);
            }
        }
    }

    // On my machine:
    // Safari 4: 5 ms
    // Firefox 3.0.10: 21 ms
    // MSIE7: 100+ ms, noticeably slower piece dropping
    var time_took = new Date().getTime() - time_started;
    //alert("realize_vboard took " + time_took + " ms");
}

// Toggle perspective of board
function flip()
{
    // TODO: actually relabel canvas!!
    label_board(!PREFS.flipped);
    load_fen(save_fen(), true);
    // BUG: if edit board, then flip it, lose changes. TODO: fix
}

// Internally name the square cells with their (x,y) coordinates
// and filerank notation, once when the page loads. This is only code so I
// don't have to manually type <td x=0 y=0 filerank=a8> etc. in all the cells.
// Also populates SQUARES for fast lookup, and VBOARD virtual board.
// If flipped is true, then the board is from black's perspective, instead of white's.
function label_board(flipped)
{
    SQUARES = [];
    VBOARD = [];
    for (var x = 1; x <= GAME_STATE.files; x += 1) {
        SQUARES[x] = [];
        VBOARD[x] = [];
        for (var y = 1; y <= GAME_STATE.ranks; y += 1) {
            VBOARD[x][y] = {virtual:true};
            var square = VBOARD[x][y];

            square.x = x;
            square.y = y;
            square.filerank = xy2filerank(x, y);
            // Store the square color here once, so can always lookup .color, 
            // never have to check the white/black class name again.
            square.color = (x + y % 2) % 2 ? "white" : "black";

            square.descriptive = {};
            square.descriptive.white = xy2descriptive("white", [x, y]);
            square.descriptive.black = xy2descriptive("black", [x, y]);
        }
    }

    PREFS.flipped = flipped;
    dojo.byId("enable_flip").checked = flipped;
}

// Initialize the board - menu, load from query string if present.
// Only needs to be performed once per page load.
function init_board()
{
    GAME_STATE = dojo.clone(GAME_STATE_DEFAULT);

    var board_menu = dojo.byId("saved_board_menu");

    // Create saved boards for openings, since they are stored by
    // board position rather than name.
    SAVED_BOARDS["Chess Openings"] = {};
    for (var opening_board in OPENINGS) {
        if (OPENINGS.hasOwnProperty(opening_board)) {
            var opening_name = OPENINGS[opening_board];

            SAVED_BOARDS["Chess Openings"][opening_name] = opening_board;
        }
    }

    document.onkeydown = function(event) {
            event = event || window.event;

            if (!event.keyCode) { 
                return;
            }
            // TODO: type move to do it

            // Shift opens piece inspector. Usually it is invoked on mouse
            // over if shiftKey is held down; this case catches if shift is
            // pressed while the mouse is /already/ over the piece.
            if (event.keyCode === 16) {
                GAME_STATE.shift = true;
                if (GAME_STATE.piece_under) {
                    show_piece_inspector(GAME_STATE.piece_under);
                    over_piece(GAME_STATE.piece_under, {});
                }
            }

        };

    document.onkeyup = function(event) {
        event = event || window.event;

        if (!event.keyCode) {
            return;
        }

        // Releasing shift closes piece inspector
        if (event.keyCode === 16) {
            if (GAME_STATE.shift === 1) {
                // When releasing shift, unhighlight opponent's moves, if any
                var save = GAME_STATE.piece_under;
                out_piece(GAME_STATE.piece_under, {});
                GAME_STATE.piece_under = save;
            } else if (GAME_STATE.shift && GAME_STATE.piece_under) {
                // When releasing shift, unhighlight our own blocked moves.
                highlight_moves(GAME_STATE.piece_under, false, false);

                // TODO: fix highlights when mousing over w/ shift
                pop_highlight(GAME_STATE.piece_under.square);
            }

            GAME_STATE.shift = false;
            hide_piece_inspector();
        }

        // If typing in custom movement field, update it
        if (GAME_STATE.update_custom) {
            var control = dojo.byId("custom-movement");
            var custom_pieces = dojo.query(".custom.piece");
            var should_alert = GAME_STATE.alert_assert;

            unhighlight_all();

            PIECE_TYPES.custom.parlett = control.value;
            GAME_STATE.alert_assert = false;
            try {
                calculate_moves(GAME_STATE.active_color);
                control.style.backgroundColor = "";
                dojo.attr(control, "title", "");
            } catch(err) {
                control.style.backgroundColor = "red";
                dojo.attr(control, "title", "Error: " + err);
            }
            for (var i = 0; i < custom_pieces.length; i += 1) {
                highlight_moves(custom_pieces[i], true);
            }

            GAME_STATE.alert_assert = should_alert;
        }

    }

    if (document.URL.indexOf("file:") === 0) {
        // For some reason, copying with ZeroClipboard doesn't work with local files
        ;
    } else {
        if (window.ZeroClipboard) {
            CLIPBOARD = new ZeroClipboard.Client();
            CLIPBOARD.glue(dojo.byId("copy_link"));
        }
    }

    // Get board name in cookie, if any. This lets the user select
    // their favorite board, and revisit the page, and it will
    // automatically load, instead of standard chess.
    var selected_board_group = dojo.cookie("board_group");
    var selected_board_name = dojo.cookie("board_name");
    if (!selected_board_name) {
        selected_board_group = DEFAULT_BOARD_GROUP;
        selected_board_name = DEFAULT_BOARD_NAME;
    }

    // Saved boards by group
    var index = 0, sel_index;
    for (var group_name in SAVED_BOARDS) {
        if (SAVED_BOARDS.hasOwnProperty(group_name)) {
            var members = SAVED_BOARDS[group_name];

            var group = dojo.create("optgroup", {label:group_name});
            board_menu.appendChild(group);

            for (var board_name in members) {
                if (members.hasOwnProperty(board_name)) {
                    var fen = members[board_name];
                    if (group_name === selected_board_group && board_name === selected_board_name) {
                        sel_index = index;
                    }
                    group.appendChild(dojo.create("option", 
                                {value: fen, innerHTML:board_name}));
                    index += 1;
                }
            }
        }
    }

    // Select loaded board. Could use selected attribute, but Firefox selects last item,
    // unless we set selectedIndex, so just do that.
    board_menu.selectedIndex = sel_index;

    var fen = SAVED_BOARDS[selected_board_group] && SAVED_BOARDS[selected_board_group][selected_board_name];
    if (!fen) {
        // Cookie corrupted? Load default.
        fen = SAVED_BOARDS[DEFAULT_BOARD_GROUP][DEFAULT_BOARD_NAME];
        board_menu.selectedIndex = 0;
    }

    if (!load_from_query_string()) {
        load_fen(fen);
    }

}

// Load board from URL query string, if any
function load_from_query_string()
{
    var query = query_string();
    if (!query.b) {
        // No board given
        return false;
    }

    // Flip/unflip board as needed. Avoid doing this unless
    // there is a change in the flip state, as it is expensive.
    // Needs to be done before loading.
    if (!!query.f !== !!PREFS.flipped) {
        label_board(query.f);
    }


    // TODO: convert query to PGN, then load that

    query.b = query.b.replace(/~/g, " ").replace(/\|/g, "/");
    load_fen(query.b);

    if (query.m) {
        dojo.forEach(query.m.split(","), function(move_text) {
                mv(move_text);
            });
    }

    if (query.c) {
        import_captured(query.c);
        update_captured_piece_images();
    }

    // Succeeded
    return true;
}



// Load a board from the drop down menu of SAVED_BOARDS.
function change_loaded_board(menu)
{
    var fen;

    if (!menu.value) {
        return;
    }

    var option = menu.options[menu.selectedIndex];
    var group = option.parentNode.label;        // optgroup 
    var name = option.innerHTML;
    dojo.cookie("board_group", group);
    dojo.cookie("board_name", name);

    fen = SAVED_BOARDS[group][name];

    dojo.byId("variant_code").style.display = "none";

    load_fen(fen);
}

// Acknowledge that a piece was captured. Called by move_piece_to_square(), which
// does all the board manipulation. 
function piece_was_captured(piece, square)
{
    // If rook captured, remove castling privileges
    if (PIECE_TYPES[piece.type].castle) {
        // Note that this is the first rank of the *other* player
        var opponent = opposite_color(GAME_STATE.active_color);
        var first_rank = opponent === "white" ? 1 : GAME_STATE.ranks;
       
        var castles_at = castles_come_from();

        // TODO: really would like to not have to hardcode this
        if (square.y === first_rank) {
            if (square.x === castles_at.long_x) {
                GAME_STATE.can_castle[opponent][castles_at.long_file] = false;
                //console.log("no more long");
            } else if (square.x === castles_at.short_x) {
                GAME_STATE.can_castle[opponent][castles_at.short_file] = false;
                //console.log("no more short");
            }
        }
    }

    GAME_STATE.captured[piece.color].push(piece);
    update_captured_piece_images();
}

// Show captured with icons from GAME_STATE.captured
function update_captured_piece_images(piece)
{
    var captured = dojo.byId("captured_piece_images");

    captured.innerHTML = "";

    // Make miniature images. In this case it is better to specify the full
    // image size and have the browser scale it, instead of having it reference
    // a pre-scaled image, because of the higher latency involved in another request.
    var html = "";
    for (var i = 0; i < GAME_STATE.captured.white.length; i += 1) {
        var p = GAME_STATE.captured.white[i];
        // TODO: Allow in some games for these pieces to be dragged back to board.
        // Currently you can't really, even in setup mode.
        // For Shogi (but captured pieces would need to change colors), where can drop
        // captured pieces back onto the board. create_piece() then add captured class.
        html += '<img src="' + image_path_for(p.type, p.color) + '" class="captured"> ';

        var piece = create_piece(p.color, p.type);
        dojo.addClass(piece, "captured");
        piece.style.position = "static";

        captured.appendChild(piece);
    }
    for (var i = 0; i < GAME_STATE.captured.black.length; i += 1) {
        var p = GAME_STATE.captured.black[i];

        var piece = create_piece(p.color, p.type);
        piece.style.position = "static";
        dojo.addClass(piece, "captured");

        captured.appendChild(piece);
    }
}

// Get all the move notation texts and moves for a given piece and destination
// square combination. Returns an object structured by a property for each
// promotion piece type (queen, knight, etc.) or undefined if not a promotion,
// then with keys: move, piece, square, and notations. The notations
// object has properties for each notation type, with strings as values.
// promote_to optionally narrows down the move to a specific promotion, otherwise,
// all promotion moves are returned (if it is a promotion).
function get_notations(piece, square, promote_to)
{
    var finds = {};
    var last_key;

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            var texts = VALID_MOVE_NOTATIONS[notation];

            for (var text in texts) {
                if (texts.hasOwnProperty(text)) {
                    var this_square = texts[text].square;
                    var this_piece = texts[text].piece;
                    var this_move = texts[text].move;

                    if (this_square.x === square.x && this_square.y === square.y && 
                        this_piece.unique_id === piece.unique_id &&
                        (!promote_to || this_move.promote_to === promote_to)) {

                        // Key by final piece type. Promotion type, if any.
                        var key = this_move.promote_to || "undefined";
                        last_key = key;

                        if (!finds[key]) {
                            finds[key] = {
                                move: this_move, 
                                square: this_square,
                                from_square: this_piece.square,
                                piece: this_piece,
                                notations: {}};
                        }

                        finds[key].notations[notation] = text;
                    }
                }
            }
        }
    }
  
    // Ensure that the 'undefined' key is always defined, so that for
    // promotions, the first half of the move can still be completed
    // without having a chosen promotion piece.
    // TODO
    /*if (!finds.undefined) {
        finds.undefined = finds[last_key];
    }*/

    return finds;
}

// Get the move(s) for the given piece moving to the given square, in all of the
// available move notations.
// TODO: kill XXX
function all_notations_from_piece_square(piece, square, text_input)
{
    var notation, results = {};

    for (var notation in AVAILABLE_NOTATIONS) {
        if (AVAILABLE_NOTATIONS.hasOwnProperty(notation)) {
            results[notation] = notation_from_piece_square(piece, square, text_input, notation);
        }
    }

    return results;
}

// Find precomputed algebraic notation for this move. Called when
// user drags a piece to a square and we don't know what move it is.
function notation_from_piece_square(piece, square, text_input, notation_type)
{
    notation_type = notation_type || form_value("output_notation");
    var notations = VALID_MOVE_NOTATIONS[notation_type];
    var finds = {}, find_count = 0, one;

    // TODO: better data structure, inverted hash table lookup
    for (var notation in notations) {
        if (notations.hasOwnProperty(notation)) {
            var this_piece = notations[notation].piece;
            var this_square = notations[notation].square;
            var this_move = notations[notation].move;

            if (this_square.x === square.x && this_square.y === square.y && 
                this_piece.unique_id === piece.unique_id &&
                // TODO: if given text_input, lookup more directly
                (!text_input || text_input === notation)) {

                notation.move = this_move;

                one = {notation:notation, move:this_move};
                finds[notation] = one;
                find_count += 1;

                if (!this_move.promote_to) {
                    // Speed hack: no-promotion moves are unique by pc+sq
                    return one;
                }
            }
        }
    }

    if (find_count === 0) {
        return null;
    } else if (find_count === 1) {
        return one;
    } else {
        // When player drags a pawn to the last rank to be promoted,
        // four moves will be found, and they'll have to choose. Make this appear
        // to be the last found promotion option, since they all have the same
        // location, and the piece will be able to move into place before the 
        // user piece selection is made.
        return dojo.mixin(one, {multiple:true, choices:finds});
    }
}

// Get the direction vector (y component only) that is "forward" for the given color
function forwards_vector(color)
{
    if (color === "white") {
        return 1;
    } else { 
        return -1;
    } 
}



// Make a ply or half-ply move (promotion) on the virtual board given piece + square.
// If is_hypothetical is true, this is an internal move part of another move
// (castling) so it shouldn't be logged.
// If is_immediate, then finish_up_move() will realize the virtual board.
// If piece_square.promote_to is given, it is the name of the piece type to promote to - along with
// piece and square, this uniquely identifies a move (a1Q, a1N, etc.) whereas if only
// piece + square are given, the promotion piece type will have to be queried.
function move_piece_to_square(piece, square, is_hypothetical, is_immediate)
{
    var choices, surrogate;

    // Get all possible moves for this piece+square combination, keyed
    // by promotion type (or undefined). A move like c8 as invoked by drag
    // and drop expands here to c8Q, c8N, c8R, c8B.
    choices = get_notations(piece, square);
    assert(choices, "move_piece_to_square(" + piece + ", " + square + "): could not find notation");

    execute_move(undefined, choices, is_hypothetical, is_immediate);
}

// Get the file numbers of where the castles are originally, or where they were.
// For chess1, this is {clong:1,cshort:8}, but in Chess960 it can be different.
function castles_come_from()
{
    var cs = GAME_STATE.can_castle.white;  // same existance for black and white
    var files = [], ret = {};

    for (var i = 0; i < GAME_STATE.files; i += 1) {
        var file = String.fromCharCode("a".charCodeAt(0) + i);
        var file_no = i + 1;

        if (cs[file] !== undefined) {
            files.push(file_no);
        }
    }

    ret.long_x = files[0];
    ret.short_x = files[1];

    ret.long_file = String.fromCharCode("a".charCodeAt(0) + files[0] - 1);
    ret.short_file = String.fromCharCode("a".charCodeAt(0) + files[1] - 1);

    return ret;
}

// Highlight the squares a piece recently moved from and to
function highlight_recent_move(from_square, to_square)
{
    push_highlight(from_square, DISPLAY["recent_move_" + from_square.color]);
    push_highlight(to_square, DISPLAY["recent_move_" + to_square.color]);
}

// Make a move, or half-move, given choices.
function execute_move(promote_to, choices, is_hypothetical, is_immediate, is_raw) 
{
    var piece, square, promote_to;
    var from_square, move_text, filerank, only_move, move, choices, did, one;

    unhighlight_all();
  
    if (choices[promote_to]) {
        one = choices[promote_to];
    } else {
        // Surrogate move, for location only
        for (var any in choices) {
            if (choices.hasOwnProperty(any)) {
                one = choices[any];
                break;
            }
        }
    }

    assert(one, "execute_move(" + promote_to + ", " + choices[promote_to] + "): move not found!");

    move = one.move;
    piece = one.piece;
    square = one.square;
    from_square = piece.square;
    one.from_square = one.piece.square;

    // If castling, move the rook in place. 
    // Note: if pass this in abs_move/choices, need to save in raw move notation, too.
    if (PIECE_TYPES[piece.type].castles_with) {
        var come_from = castles_come_from();

        // We rely on can_castle to indicate whether the king/rook have moved.
        if (GAME_STATE.can_castle[GAME_STATE.active_color][come_from.short_file] && 
                    (square.x === GAME_STATE.castle_moves.cshort.king_to    // king moves two spaces (Chess1)
                     || square.x === come_from.short_x)                     // king captures rook (Chess960)
                    ) {

            // Move rook. Use do_virtual_move instead of move_piece_to_square, since 
            // this rook move may not be valid otherwise. 
            do_virtual_move(pc(come_from.short_x, square.y), {x:GAME_STATE.castle_moves.cshort.castle_to, y:square.y, ignore_self_capture:true});

            // Move king to destination square, instead of over rook.
            move = {x:GAME_STATE.castle_moves.cshort.king_to, y:square.y, ignore_self_capture:true};

            if (!is_hypothetical) {
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.short_file] = false;
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.long_file] = false;
            }

        } else if (GAME_STATE.can_castle[GAME_STATE.active_color][come_from.long_file] && 
                    (square.x === GAME_STATE.castle_moves.clong.king_to
                     || square.x === come_from.long_x) 
                    ) {

            do_virtual_move(pc(come_from.long_x, square.y), {x:GAME_STATE.castle_moves.clong.castle_to, y:square.y, ignore_self_capture:true});

            move = {x:GAME_STATE.castle_moves.clong.king_to, y:square.y, ignore_self_capture:true};

            if (!is_hypothetical) {
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.short_file] = false;
                GAME_STATE.can_castle[GAME_STATE.active_color][come_from.long_file] = false;
            }
        }
    }


    if (!is_hypothetical) {
        // Pieces captured /before/ this move
        GAME_STATE.last_captured = export_captured();

        // If moved either rook, can't castle on that side.
        if (PIECE_TYPES[piece.type].castle) {
            var castles_at = castles_come_from();

            if (from_square.x === castles_at.short_x) {
                GAME_STATE.can_castle[GAME_STATE.active_color][castles_at.short_file] = false;
            } else if (from_square.x === castles_at.long_x) {
                GAME_STATE.can_castle[GAME_STATE.active_color][castles_at.long_file] = false;
            }
        }

        // If moved pawn, or was a capture, reset fifty move rule counter
        if (move.capture || PIECE_TYPES[piece.type].resets_50move) {
            GAME_STATE.hmvc = 0;
        } else {
            GAME_STATE.hmvc += 1;
        }

        highlight_recent_move(from_square, square);
    }

    did = do_virtual_move(piece, move);
    if (did.captured) {
        piece_was_captured(did.captured, did.capture_square);
    }
    if (did.self_destructed) {
        piece_was_captured(did.piece, did.to_square);
    }

    if (!is_hypothetical) {
        // If double pawn move, this creates an en passant target square
        filerank = xy2filerank([square.x, square.y]);
        if (move.create_ep_target) {
            GAME_STATE.ep_target = move.create_ep_target;
        } else {
            // En passant possibility disappears immediately after any other move
            GAME_STATE.ep_target = null;
        }
    }

    if (should_promote(piece)) {
        if (own_property_count(choices) > 1) {
            // Piece+square move, need input from user: what piece 
            ask_to_promote(piece, choices, is_immediate);
        } else {
            for (var a in choices) {
                if (choices.hasOwnProperty(a)) {
                    promote_to = a;
                }
            }
            // Piece+square+piece to promote has been given (probably from mv())
            promote(piece, square, promote_to, choices.notation, is_immediate);
        }
    } else {
        // If not a multi-move (moving rook in castling), log and go to next turn
        if (!is_hypothetical) {
            finish_up_move(choices, is_immediate, undefined, is_raw);
        }
    }


    // TODO: return from finish_up_move, deferred? promotions..
    // To allow undo_virtual_move
    //return did;
}

// Perform bookkeeping on the move after it has been actually made, 
// in move_piece_to_square().
// promote_to is the type for promotions, or undefined otherwise.
function finish_up_move(tieback, is_immediate, promote_to, is_raw)
{
    var alg_move, ply, turn_info, move_text, info;

    if (is_immediate) {
        // Display the new board state
        realize_vboard();
    }

    info = tieback[promote_to];

    ply = encode_ply(GAME_STATE.active_color, GAME_STATE.fmvn);
  
    info.only_move = own_property_count(VALID_MOVE_NOTATIONS.SAN) === 1;
    // TODO: skip move calculation if is_raw
    turn_info = set_turn("next", false);

    if (turn_info.text_move) { info.add_text = turn_info.text_move; }
    if (turn_info.text_end) { info.text_end = turn_info.text_end; } 
    // If there was a repetition, it occurred on this move. Indicate the moves.
    if (turn_info.repeats) { 
        turn_info.repeats.push(ply);
        info.repeats = turn_info.repeats;
    }

    // Save for history
    GAME_STATE.made_moves[ply] = info;

    var opening = OPENINGS[active_fen(true)];
    if (opening) {
        dojo.byId("opening_name").innerHTML = opening;
    }
    // If not recognized, do not clear it -- keep up opening during the game

    if (is_immediate) {
        set_copyable_link();

        show_move_history();
        populate_make_a_move_list();
        computer_move_if_applicable();
    }
}

// Fill in move_history with the move history
function show_move_history()
{
    var htmls = [], repeats = [];
    var first = true;

    for (var ply = 1; ply < GAME_STATE.made_moves.length; ply += 1) {
        var color_fullmove, color, fmvn, move_text, move_info, only_move;

        color_fullmove = decode_ply(ply);
        color = color_fullmove.color;
        fmvn = color_fullmove.fmvn;

        move_info = GAME_STATE.made_moves[ply];
        if (!move_info) {
            continue;
        }

        move_text = move_info.notations[form_value("output_notation")];
        
        if (color === "white") {
            htmls.push('<span class="fmvn">' + fmvn + '<\/span>');
            // Period goes to initial position, kind of strange, but its uninstrusive
            htmls.push(first ? move_link(0, ".") : ".");
        } else {
            // Ellipsis if black is first recorded move,
            // TODO: or intervening commentary
            if (first) {
                htmls.push('<span class="fmvn">' + fmvn + '<\/span>');
                htmls.push(first ? move_link(0, ".") : ".");
                htmls.push("&hellip; ");
            }
        }

        htmls.push(" " + move_link(ply, move_text));

        if (move_info.only_move) {
            // NAG for "only move", see http://www.markalowery.net/Chess/Notation/NAG.html
            htmls.push("$7 ");
        }

        if (move_info.add_text) {
            htmls.push(move_info.add_text);
        }

        if (move_info.repeats) {
            repeats.push(move_info.repeats);
        }

        // End-text, not a move. Terminates the game.
        if (move_info.text_end) {
            htmls.push("\n" + move_info.text_end);
        }

        htmls.push(" ");

        first = false;
    }

    var last_ply = GAME_STATE.made_moves.length - 1;

    dojo.byId("move_history").innerHTML = htmls.join("");

    // Mark repeated moves for threefold repetition, after showing this move.
    dojo.forEach(repeats, function(peat) {
            mark_repeated_moves(peat);
        });

    // Last ply
    dojo.query("a.active_move").forEach(function(m) {
            dojo.removeClass(m, "active_move");
        });

    set_next_back_accesskeys(last_ply);
}

// Visually indicate the moves which after threefold repetition
// Unfortunately, we highlight the move *after* the board state was repeated. This is
// because the first clickable link, say 1. Nf3, loads the move after
// Nf3 was made, not before (the initial board position). But you can
// repeat the initial board position:
// 1. Nf3 Nf6 2. Ng1 Ng8 3. Nf3 Nf6 4. Ng1 Ng8
var HIGHLIGHT_COLORS = ["yellow", "aquamarine", "lime", "khaki", "aqua"];
var REPEAT_COLOR_COUNT = 0;
function mark_repeated_moves(reps)
{
    var color = HIGHLIGHT_COLORS[REPEAT_COLOR_COUNT];

    REPEAT_COLOR_COUNT += 1;
   
    for (var i = 0; i < reps.length; i += 1) {
        var ply = reps[i];
        var link = dojo.byId("ply_" + ply);

        // TODO: fix
        assert(link, "mark_repeated_moves(" + reps + "): no such ply " + ply);

        dojo.style(link, "background-color", color);
    }
}

// Handle graphically moving of a piece, dropping it to its new location
function move_dropped_piece(piece, square, event)
{
    if (PREFS.setup_mode) {
        var from_square = piece.square;

        do_virtual_move(piece, {x:square.x, y:square.y});
        unhighlight_all();

        realize_vboard();
        set_copyable_link(true);    // this board state
        return;
    }


    var virtual_square = VBOARD[square.x][square.y];
    var virtual_piece = VBOARD[piece.square.x][piece.square.y].piece;

    // Move the piece in the virtual board and realize it.
    setTimeout(function() { 
            move_piece_to_square(virtual_piece, virtual_square, false, true) 
        }, 0);
}

// Get the representation of the active board state in FEN.
// If strip_moves, return time-independent representation.
function active_fen(strip_moves)
{
    var fen = GAME_STATE.position_after.slice(-1)[0];

    if (strip_moves) {
        // Remove last two fields, move counts.
        fen = fen.split(" ").slice(0, -2).join(" ");
    } 

    return fen;
}

// Generate FEN from board state. Use active_fen() to get
// this if it already been calculated.
function save_fen()
{
    var fens = [], castles;

    // Board position
    for (var y = GAME_STATE.ranks; y > 0; y -= 1) {
        var blanks = 0;
        for (var x = 1; x <= GAME_STATE.files; x += 1) {
            var piece = VBOARD[x][y].piece;
            var letter;

            if (piece) {
                if (blanks) {
                    fens.push(blanks.toString());
                    blanks = 0;
                }
                letter = full_piece_prefix(piece);

                // Uppercase = white, lowercase = black
                if (piece.color === "black") {
                    letter = letter.toLowerCase();
                }

                fens.push(letter);
            } else {
                blanks += 1;
            }
        }
        if (blanks) {
            fens.push(blanks.toString());
        }
        if (y !== 1) {
            fens.push("/");
        }
    }

    // Active color
    fens.push(" ");
    if (GAME_STATE.active_color === "white") {
        fens.push("w");
    } else {
        fens.push("b");
    }

    // Castling availability
    fens.push(" ");
    castles = false;
    if (GAME_STATE.can_castle.white.h) { fens.push("K"); castles = true; }
    if (GAME_STATE.can_castle.white.a)  { fens.push("Q"); castles = true; }
    if (GAME_STATE.can_castle.black.h) { fens.push("k"); castles = true; }
    if (GAME_STATE.can_castle.black.a)  { fens.push("q"); castles = true; }
    if (!castles) { fens.push("-"); }

    // En passant target square
    fens.push(" ");
    if (GAME_STATE.ep_target) {
        fens.push(xy2filerank(GAME_STATE.ep_target));
    } else {
        fens.push("-");
    }

    // TODO: EPD tags
    /*for (var i = 0; i < GAME_STATE.tags.length; i += 1) {
        var tag = GAME_STATE.tags[i];
        fens.push(" " + tag);
        if (tag */
    fens.push(" " + GAME_STATE.hmvc);
    fens.push(" " + GAME_STATE.fmvn);

    return fens.join("");
}

// Fields to be parsed as integers instead of strings
var EPD_INTEGER_FIELDS = {acn:1, acs:1, ce:1, dm:1, fmvn:1, hmvc:1, rc:1};

// Parse the Extended Position Description (EPD) codes from the 
// end of a pre-split EPD field, returning a dictionary.
function parse_epd_opcodes(parts)
{
    var dict = {};

    for (var i = 4; i < parts.length; i += 1) {
        var part = parts[i];
        var a = part.split("=");
        var key, value;
        if (a.length === 1) {
            // Booleans: draw_accept, draw_claim, etc.
            key = a[0];
            value = true;
        } else {
            key = a.shift();
            value = a.join("=");
        }

        if (EPD_INTEGER_FIELDS[key]) {
            value = parseInt(value, 10);
        }

        dict[key] = value;
    }
    
    return dict;
}


// Load board state in Forsyth-Edwards Notation (FEN) or Extended Position Description (EPD).
// The fen can either be a string of EPD/FEN, or a function that returns the string.
// If replay is true, this is reloading an existing position, not loading a new game.
// TODO: support any base 10 number (10 for skip ten spaces), and asterisks for filling remainder of rank with empty
// spaces, and {} for labels, see http://play.chessvariants.org/pbm/devguide.html
// TODO: Shogi variants http://www.mafiascum.net/wiki/index.php?title=Shogi_variant
function load_fen(fen, replay)
{
    var parts, castling, color;

    if (dojo.isFunction(fen)) {
        fen = fen();
    }

    parts = fen.split(" ");


    castling = parts[2]; // parsed below, after know dimensions

    if (parts[3] === "-") {
        GAME_STATE.ep_target = null;
    } else {
        GAME_STATE.ep_target = filerank2xy(parts[3]);
    }

    color = {w:"white", b:"black", "?":"ask"}[parts[1]];
    assert(color, "load_fen(" + fen + "): bad active color: " + parts[1]);

    if (!replay) {
        GAME_STATE = dojo.clone(GAME_STATE_DEFAULT);
    }

    if (!isNaN(parseInt(parts[4], 10))) {
        // FEN has halfmove clock and fullmove number in 5th and 6th fields
        GAME_STATE.hmvc = parseInt(parts[4], 10);
        GAME_STATE.fmvn = parseInt(parts[5], 10);
    } else {
        // EPD (Extended Position Description), has opcodes instead

        // defaults
        GAME_STATE.hmvc = 0;
        GAME_STATE.fmvn = 1;

        dojo.mixin(GAME_STATE, parse_epd_opcodes(parts));
    }

    if (GAME_STATE.rs) {
        // Game "rule set"
        dojo.mixin(GAME_STATE, RULE_SETS[GAME_STATE.rs]);
    }

    // Now that know rank & file count, parse castling eligibilities
    for (var i = 0; i < castling.length; i += 1) {
        var ch = castling.charAt(i);
        var castle_color, file;

        if (ch === "-") { 
            continue;
        } else if (/[A-Z]/.test(ch)) {
            castle_color = "white";
        } else if (/[a-z]/.test(ch)) {
            castle_color = "black";
        } else {
            assert(false, "load_fen(" + fen + "): invalid castling code: " + castling);
        }
        file = ch.toLowerCase();

        // X-FEN / FEN compatibility, KQkq for corner rooks. Allowed by default,
        // but for larger boards, K and Q are valid file names, so shredder_castle 
        // disables this support.
        if (!GAME_STATE.shredder_castle) {
            if (file === "k") {
                // "kingside" (a-side)
                file = "a";
            } else if (file === "q") {
                // "queenside", furthest file from a-side (h-side on orthodox board)
                file = String.fromCharCode("a".charCodeAt(0) - 1 + GAME_STATE.files);
            }
        }

        GAME_STATE.can_castle[castle_color][file] = true;
    }
   
    load_starting_position(parts[0], replay);

    if (replay) { 
        // TODO: clear recent move, XYZ
        GAME_STATE.recent_piece = null;
    } else {
        // Game loading initialization
        GAME_STATE.position_moves = {}; 
        GAME_STATE.position_after = [fen];  // 0th ply = initial state

        var ply = encode_ply(color, GAME_STATE.fmvn);
        GAME_STATE.position_after[ply] = fen;

        GAME_STATE.ended = null; 
        GAME_STATE.captured = {white:[], black:[]};
        GAME_STATE.made_moves = [null];
        GAME_STATE.made_moves[ply] = null;

        dojo.query(".recent-move-black").removeClass("recent-move-black");
        dojo.query(".recent-move-white").removeClass("recent-move-white");
        dojo.query(".dropped-square").removeClass("dropped-square");

        update_captured_piece_images();

        // Piece movement restrictions
        if (GAME_STATE.bounds1) {
            set_board_boundary(GAME_STATE.bounds1);
        }

        if (GAME_STATE.bounds2) {
            set_board_boundary(GAME_STATE.bounds2);
        }

        // Graphics
        create_board();
    }
   
    // Now that everything is loaded, set the turn.
    set_turn(color, replay);
    populate_make_a_move_list();
}

// Create a palace or river feature
function set_board_boundary(str)
{
    var ary = str.split(",");
    var bounds_name = ary.shift();
    var x1 = parseInt(ary.shift(), 10);
    var y1 = parseInt(ary.shift(), 10);
    var x2 = parseInt(ary.shift(), 10);
    var y2 = parseInt(ary.shift(), 10);
    var bounds_types = ary;

    // TODO: Replace with assertions, instead of clamping
    if (x1 < 1) { x1 = 1; }
    if (y1 < 1) { y1 = 1; }
    if (x2 > GAME_STATE.files) { x2 = GAME_STATE.files; }
    if (y2 > GAME_STATE.ranks) { y2 = GAME_STATE.ranks; }

    var white_area = [x1, y1, x2, y2];
    var black_area = [x1, (GAME_STATE.ranks + 1) - y2, x2, (GAME_STATE.ranks + 1) - y1];

    // Set boundaries for each piece type given, for quick lookup
    for (var i = 0; i < bounds_types.length; i += 1) {
        var type = bounds_types[i];
        // Note: ranks are from each player's perspective
        GAME_STATE.boundaries[type] = {name: bounds_name, 
            white:white_area, 
            black:black_area, 
            types:bounds_types};
    }
}

// Remove all pieces from the virtual board.
function clear_board()
{
    // Initializes VBOARD
    label_board(GAME_STATE.flipped);
}


 
// Load starting position in FEN. Example, at beginning of game:
// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR.
// If !replay, name pieces.
// TODO: Support FFEN http://www.mafiascum.net/wiki/index.php?title=Faerie_Forsythe-Edwards_Notation 
function load_starting_position(fen, replay)
{
    var i, x, y, code;

    clear_board();

    // Note that ranks and files internally are represented here by
    // x,y coordinates, so a8 = 1,8. That is where FEN starts.
    x = 1;
    y = GAME_STATE.ranks;
    for (i = 0; i < fen.length; i += 1) {
        code = fen.charAt(i);

        if (/[a-zA-Z]/.test(code)) {
            // Read possibly multi-letter piece code
            var length = piece_code_length(fen.substr(i));
            var letter = fen.substr(i, length);
            i += length - 1;

            var piece = decode_piece_letter(letter);
            piece.virtual = true;
            piece.square = VBOARD[x][y];
            //piece.unique_id = letter + "," + x + "," + y;   // TODO: from name_pieces instead?

            VBOARD[x][y].piece = piece;

            x += 1;
        } else if (code === "/") {
            x = 1;
            y -= 1;
        } else if (code === ".") {
            // One empty square, from FFEN
            x += 1;
        } else if (/[0-9]/.test(code)) {
            x += code.charCodeAt(0) - "0".charCodeAt(0);
        } else if (code === " ") {
            break;
        } else {
            assert(false, "load_starting_position(" + fen + "): unknown code: " + code);
        }
    }

    // Re-init drag & drop since board size may have changed
    init_dnd();

    realize_vboard();

    if (!replay) {
        name_pieces();
        // Clear move history. TODO: Better way.
        dojo.byId("move_history").innerHTML = "";
    }
}

//// PIECE LIBRARY / INFO FUNCTIONS (War and Pieces)

// Show all available images, even those without movement
function show_library_images()
{
    var root = "images/" + PREFS.image_set + "/";
    var used_paths = {}, count;

    count = 0;
    // Map path of used image to piece type it is used for
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            // Mark all images used, including alternates
            var paths = image_path_for(type, "white", true);

            for (var i = 0; i < paths.length; i += 1) {
                used_paths[paths[i]] = type + (i === 0 ? "" : " (alternate image)");
                count += 1;
            }
        }
    }

    // Get list of all images, even those not being used in a piece
    dojo.xhrGet({url:root + "list.txt", load:function(text) {
        var images = text.split("\n");

        document.write("<html><head><title>All piece images</title></head><body>");
        document.write("<h1>All piece images</h1>");
        document.write("<h2>" + count + " of " + images.length + " (" + 
            Math.round(count / images.length * 100) + "%) defined" + "</h2>");
        document.write("<p>This is a list of all blue and white piece images available in the <b>" + PREFS.image_set + "</b> image set, including those that are not assigned to a piece. See also: <ul>");
        document.write("<li><a href=\"images/" + PREFS.image_set + "\">Directory listing</a>");
        document.write("<li><a href=\"images/" + PREFS.image_set + "/README.html\">README</a>");
        document.write("</ul>");

        document.write("<table>");
        for (var i = 0; i < images.length; i += 1) {
            var image = images[i];

            if (!image) {
                continue;
            }

            var wpath = root + "w" + image + ".gif";
            var bpath = root + "b" + image + ".gif";

            document.write('<tr>');
            document.write('<td>' + i + '.</td>');
            document.write('<td><img src="' + wpath + '"></td>');
            document.write('<td><img src="' + bpath + '"></td>');
            document.write('<td>' + image + '</td>');
            document.write('<td>' + (used_paths[wpath] || "") + '</td>');
            document.write('</tr>');
        }
        document.write('</table></body></html>');
    }});
}

// Disable or enable game setup mode
function set_setup_mode(on)
{
    // Set setup mode as opening/closing piece library, since that is what it is for
    dojo.byId("enable_setup_mode").checked = on;
    PREFS.setup_mode = on;

    if (!on) {
        // Exited setup mode, so calculate moves with new setup
        calculate_moves(GAME_STATE.active_color);
    }
}

// Show the piece library, of readily usable pieces with defined movement
function toggle_piece_library()
{
    var table, lib, want_setup_mode, parent, i, wp, bp;

    parent = dojo.byId("piece-library-parent");
    want_setup_mode = parent.style.display === "none";
    toggle(dojo.byId(parent));

    // Set setup mode as opening/closing piece library, since that is what it is for
    set_setup_mode(want_setup_mode);

    // Lazily generate the table. 
    lib = dojo.byId("piece-library");
    if (dojo.byId("piece-library-table")) {
        return;
    }

    enable_document_selection(false, lib);

    // TODO: sortable columns, searchable table, so can list by symbol, alphabetically,
    // royal pieces first, pieces that promote, and find what you want.
    // IE7 chokes due to the fix for http://dev.rubyonrails.org/ticket/2707
    // TODO: Find out why this table doesn't display in IE7
    table = dojo.create("table", {id:"piece-library-table"});
    tbody = dojo.create("tbody");
    table.appendChild(tbody);

    i = 0;
    for (var type in PIECE_TYPES) {
        if (PIECE_TYPES.hasOwnProperty(type)) {
            wp = create_piece("white", type);
            bp = create_piece("black", type);

            // Not directly draggable, since these elements are absolutely 
            // positioned inside a relatively positioned element. But keep
            // them as pieces so you can shift-hover to open the piece
            // inspector.
            dojo.addClass(wp, "tear-off");
            dojo.addClass(bp, "tear-off");

            var row = dojo.create("tr");
            var white_cell = dojo.create("td", {"class": "square"}, row);
            white_cell.appendChild(wp);
            var black_cell = dojo.create("td", {"class": "square"}, row);
            black_cell.appendChild(bp);

            dojo.create("td", {innerHTML:PIECE_TYPES[type].letter || ""}, row);

            if (type === "custom") {
                dojo.create("td", {innerHTML:"custom: <input id='custom-movement' onfocus='GAME_STATE.update_custom = true;' onblur='GAME_STATE.update_custom = false'> <a href='newchess.html#ep' target='_new'>help</a>"}, row);
            } else {
                dojo.create("td", {innerHTML:type}, row);
            }

    
            tbody.appendChild(row);
            i += 1;
        }
    }

    lib.appendChild(table);
    lib.appendChild(dojo.create("p", {innerHTML: i + " pieces available"}));
    lib.appendChild(dojo.create("a", {href: "#", onclick:"show_library_images()", 
                innerHTML:"show all images (clears page)"}));
}

// Show information on a piece
function show_piece_inspector(piece)
{
    var symbols, type_info, misc, images, paths, diagram, alt_names, alt_names_string;
    var inspector = dojo.byId("piece-inspector");

    type_info = PIECE_TYPES[piece.type];

    // Also known as...
    alt_names = [];
    if (dojo.isArray(type_info.image)) {
        alt_names = dojo.clone(type_info.image);
    } 
    if (type_info.aka) {
        alt_names = alt_names.concat(type_info.aka);
    }
    // Remove dupes and canonical name
    alt_names = uniq(alt_names);
    alt_names = dojo.filter(alt_names, function(x) { return x !== piece.type; });

    if (alt_names.length) {
        alt_names_string = " (" + alt_names.join(", ") + ")";
    } else {
        alt_names_string = "";
    }

    dojo.byId("inspector-type").innerHTML = piece.type + alt_names_string;

    // Show all the images, in order of preference.
    image_htmls = [];
    paths = image_path_for(piece.type, piece.color, true);
    for (var i = 0; i < paths.length; i += 1) {
        image_htmls.push("<img src=\"" + paths[i] + "\">");
    }

    dojo.byId("inspector-image").innerHTML = image_htmls.join(" ");
    dojo.byId("inspector-movement").innerHTML = escape_html(type_info.parlett);

    dojo.byId("inspector-diagram").innerHTML = movement_diagram(unfiltered_moves(type_info.parlett));

    // Symbols (letter, figurine, number) for notations
    symbols = [];
    if (type_info.letter) {
        symbols.push(type_info.letter);
    } else {
        symbols.push("X(" + piece.type + ")");
    }
    if (type_info.alg_letter) {
        symbols.push(" (algebraic: " + type_info.alg_letter + ")");
    }
    if (type_info.figurines) {
        symbols.push(", " + type_info.figurines.join(", "));
    }
    if (type_info.iccf_number) {
        symbols.push(", " + type_info.iccf_number);
    }
    dojo.byId("inspector-symbols").innerHTML = symbols.join("");

    // Other settings
    misc = [];
    if (type_info.promote) {
        // TODO: links to view other pieces?
        misc.push("Promotes to " + type_info.promote.join(", ") + 
                " on rank #" + (type_info.promotion_rank || GAME_STATE.ranks) + "<br>");
    }
    if (type_info.royal) {
        misc.push("Royal (can be checked/checkmated)<br>");
    }
    if (type_info.resets_50move) {
        misc.push("Resets 50-move counter<br>");
    }
    if (type_info.castles_with) {
        misc.push("Castles with " + type_info.castles_with + "<br>");
    }
    if (type_info.castle) {
        misc.push("Is a castle<br>");
    }
    if (type_info.invincible) {
        misc.push("Invincible (cannot be captured)<br>");
    }
    if (type_info.url) {
        misc.push("<em>Additional information is available by shift-clicking the piece</em>");
    }

    dojo.byId("inspector-info").innerHTML = misc.join("");

    inspector.style.display = "";
}

// Open an external website with more information on a piece, if any
function open_piece_url(piece)
{
    var type_info = PIECE_TYPES[piece.type];

    if (type_info.url) {
        var url = type_info.url;
        if (url === "akm") { 
            url = "http://www.mayhematics.com/v/v_gm.htm";
        } else if (url.substr(0, 3) === "pc:") {
            url = "http://www.chessvariants.org/piececlopedia.dir/" + url.substr(3) + ".html";
        }
        window.open(url);
    } else {
        //alert("No additional information is available for " + piece.type);
    }
}


// Hide information on the piece shown, if any
function hide_piece_inspector()
{
    var inspector = dojo.byId("piece-inspector");

    if (inspector) {
        inspector.style.display = "none";
    }
}

//// PIECE FUNCTIONS

// Name each piece, in standard chess1 locations, using English descriptive notation.
function name_pieces()
{
    var piece, descriptive_name;

    for (var file_number = 1; file_number <= GAME_STATE.files; file_number += 1) {
        // English descriptive notation (only really applicable to chess1)
        var file = xy2descriptive("white", file_number);

        // White's pieces and pawns
        piece = pc(file_number, 1); if (piece) { piece.descriptive_name = file; }
        piece = pc(file_number, 2); if (piece) { descriptive_name = file + "P"; }

        // Black's pieces and pawns
        piece = pc(file_number, GAME_STATE.ranks); if (piece) { descriptive_name = file; }
        piece = pc(file_number, GAME_STATE.ranks - 1); if (piece) { descriptive_name = file + "P"; }


        // Algebraic descriptive notation
        var afile = xy2filerank(file_number, "");
        for (var white_rank = 1; white_rank <= GAME_STATE.ranks; white_rank += 1) {
            var black_rank = (GAME_STATE.ranks + 1) - white_rank;
            piece = pc(file_number, white_rank);
            var rank, piece_letter;

            if (!piece) {
                continue;
            }

            if (piece.color === "white") {
                rank = white_rank;
            } else {
                rank = black_rank;
            }

            piece_letter = full_piece_prefix(piece);
            // aP, bP, etc.. TODO: use rank, if needed to disambiguate (two
            // pieces of same type on same file). Use file, rank, or filerank
            // like disambiguating moves.
            piece.adescriptive_name = afile + piece_letter;

            // Unique identifier of piece. TODO: Use adescriptive_name, make it disambiguated
            // so it will be always unique and descriptive.
            piece.unique_id = afile + "" + white_rank + piece_letter;
        }
    }
}

/// TODO: a "piece lab", where can dynamically create new pieces,
// browse existing pieces. Show piece on board by itself, highlighting 
// valid moves, update when change Parlett movement types, allow to operate
// the piece and see how it behaves. Then return to the main board.

// Return the letter, if any, used for representing the piece type (name)
// in algebraic notation.
function algebraic_letter(type)
{
    if (PIECE_TYPES[type].alg_letter !== undefined) {
        return PIECE_TYPES[type].alg_letter;
    } else {
        return PIECE_TYPES[type].letter;
    }
}

// Given a letter, find the name of the piece (R = rook, etc.). The letter
// can either be for FEN (P = pawn), or algebraic notation (blank = pawn);
// both are recognized.
var cache_letter2name;
function piece_letter2name(letter)
{
    // If given a name, return what we were given.
    if (PIECE_TYPES[letter]) {
        return letter;
    }

    letter = letter.toUpperCase();

    if (!cache_letter2name) {
        cache_letter2name = {};

        for (var name in PIECE_TYPES) {
            if (PIECE_TYPES.hasOwnProperty(name)) {
                var info = PIECE_TYPES[name];

                if (info.letter !== undefined) {
                    cache_letter2name[info.letter] = name;
                } else if (info.alg_letter !== undefined) {
                    cache_letter2name[info.alg_letter] = name;
                }
            }
        }
    }

    return cache_letter2name[letter.toUpperCase()];
}

// Return the full piece prefix, succiently indicating the piece type.
// Will not return an empty string but may return E-FEN piece codes. 
function full_piece_prefix(piece)
{
    assert(PIECE_TYPES[piece.type], "full_piece_prefix(" + piece + "): no such type " + piece.type);
    var letter = PIECE_TYPES[piece.type].letter;

    if (letter !== undefined) {
        return letter;
    } else {
        return "X(" + piece.type + ")";
    }
}

// Return the full piece prefix using lowercase for black, uppercase for white.
// The resulting code can be decoded with decode_piece_letter().
function color_piece_prefix(piece)
{
    var letter = full_piece_prefix(piece);
    var first = letter.substr(0, 1);
    var rest = letter.substr(1);

    if (piece.color === "white") {
        return first.toUpperCase() + rest;
    } else {
        return first.toLowerCase() + rest;
    }
}

// Return algebraic prefix for a piece. May return an empty 
// string (for pawns, for example): prefers alg_letter over letter.
// To always get a non-empty string, use full_piece_prefix() instead.
function algebraic_piece_prefix(piece)
{
    if (PIECE_TYPES[piece.type].alg_letter !== undefined) {
        return PIECE_TYPES[piece.type].alg_letter;
    } else {
        return full_piece_prefix(piece);
    }
}

// Get the Unicode figurine for a piece of a given color, or fall back on 
// algebraic_piece_prefix if there isn't one.
function figurine_piece_prefix(color, piece)
{
    if (PIECE_TYPES[piece.type].figurines) {
        return PIECE_TYPES[piece.type].figurines[color === "white" ? 0 : 1];
    } else {
        return algebraic_piece_prefix(piece);
    }
}

// Return a piece at (x,y), or "offboard" if the coordinates are out of range.
function pc_or_offboard(x, y)
{
    if (x < 1 || y < 1 || x > GAME_STATE.files || y > GAME_STATE.ranks) {
        return "offboard";
    }

    // Virtual board only
    return pc(x, y);
}

// Return an existing piece on the virtual board, or a false, given:
// - (x,y) coordinates, like (8,1)
// - location in filerank notation, like "a8"
// To get piece from a square, use .piece if virtual, or .firstChild if not
function pc(x, y, virtual)
{
    if (x.charAt) {
        var xy = filerank2xy(x);
        x = xy[0];
        y = xy[1];
    }

    //assert(x >= 1 && x <= GAME_STATE.files, "pc(" + x + ", " + y + "): bad x: " + x);
    //assert(y >= 1 && y <= GAME_STATE.ranks, "pc(" + x + ", " + y + "): bad y: " + y);

    return VBOARD[x][y].piece;
}

// Return the path to an image for the piece of that color.
// If all, then returns an array of all images including alternates,
// otherwise returns preferred.
function image_path_for(type, color, all)
{
    var bases, image_list, paths;

    assert(PIECE_TYPES[type], "image_path_for(" + type + ", " + color + "): no such piece type");

    // Override image name
    image_list = PIECE_TYPES[type].image;
    if (image_list) {
        // Choose first from array if is an array
        bases = dojo.isArray(image_list) ? image_list : [image_list];
    } else {
        bases = [type];
    }

    // TODO: Use .style.webkitTransform="rotate(45deg)" etc. to get rotated pieces,
    // instead of having rotated images saved! Would allow anything to be rotated.

    // Rejected TODOs, lack support:
    // - pngs
    // - use Unicode characters in a span!! How cool would that be? Infinite resolution.
    //   See for example http://en.wikipedia.org/wiki/Knight_(chess)
    //   Unfortunately, MSIE doesn't seem to support it, though it should..different font?
    // - Web fonts! Supported on Firefox 3.1+, Opera 10+, Safari 3.1+, IE4+
    //   See http://fonts.philip.html5.org/
    
    paths = [];
    for (var i = 0; i < bases.length; i += 1) {
        paths.push(["images/", PREFS.image_set, "/", {white:"w", black:"b"}[color], bases[i], ".gif"].join(""));
    }

    return all ? paths : paths[0];
}

// Get the length of the first piece code (letter) in a string. The
// substring of the length returned can be decoded with decode_piece_letter.
//
// Examples: 
// piece_code_length("RNBQKBNR") === 1 (for "R")
// piece_code_length("XRPPXA") === 2 (for "XR")
// piece_code_length("X(bede)RRR") === 7 (for "X(bede)")
function piece_code_length(code)
{
    var i;

    if (code.charAt(0) === "X" || code.charAt(0) === "x") {
        i = 1;

        // Expanded FEN codes
        if (code.substr(0, 2) === "X(" || code.substr(0, 2) === "x(") {
            // Read until closing paren
            var ch;
            i += 1;
            while(i < code.length) {
                ch = code.charAt(i);
                if (ch === ")") { break; }
                i += 1;
            }
            i += 1;
        } else {
            i = 2; // XR, etc.
        }
    } else {
        i = 1;
    }

    return i;
}
// Decode Forsyth-Edwards Notation piece code, for example:
//  r = black rook, R = white rook, N = white knight
// Also allows extended names, X(elephant), x(elephant), etc.
// To encode, use color_piece_prefix().
function decode_piece_letter(name)
{
    var color, type;

    // In FEN, uppercase=white, lower=black
    if (/^[A-Z]/.test(name)) {
        color = "white";
    } else if (/^[a-z]/.test(name)) {
        color = "black";
    } else {
        assert(false, "create_piece_by_letter(" + name + "): not a letter");
    }
    name = name.toLowerCase();

    // x(name) or X(name) is explicit name, otherwise, is a letter
    if (/\(/.test(name)) {
        var ary = /^[xX]\(([^)]+)/.exec(name);
        type = ary[1];
    } else {
        type = piece_letter2name(name);
    }

    return {color: color, type: type};
}

// Create a new piece or pawn, given the letter.
function create_piece_by_letter(name)
{
    var decoded = decode_piece_letter(name);

    return create_piece(decoded.color, decoded.type);
}

// Called when mouse is over a piece
function over_piece(piece, event) 
{
    event = event || window.event;
    
    var square = highlight_moves(piece, true);
    if (square) {
        push_highlight(square, DISPLAY["recent_move_" + square.color]);
    }
 
    if (event.shiftKey) {
        show_piece_inspector(piece);
    }
    GAME_STATE.piece_under = piece;
}

// Called when mouse is no longer over a piece
function out_piece(piece, event)
{
    event = event || window.event;

    var square = highlight_moves(piece, false);
    if (square) {
        pop_highlight(square);
    }
   
    if (!event.shiftKey) {
        hide_piece_inspector();
    }

    GAME_STATE.piece_under = null;
}


// Create a new piece by color and type (full name).
// TODO: make this a constructor so you can do new Piece().
function create_piece(color, type)
{
    var filename, piece, classes;

    assert(type, "create_piece(" + type+ "): unrecognized piece type: " + type);

    filename = image_path_for(type, color);

    // CSS classes, can use with dojo.query and also shown in toString (useful 
    // for debugging), however, note that code should not use this, because
    // all the classes are in a space-separated string, .className, according to
    // the DOM, and Prototype's hasClassName uses a slow RegExp to parse it,
    // and dojo's hasClass uses indexOf so its faster, but it still involves
    // parsing, and it is ugly. Probably a design flaw, oh well.
    // Use .type and .piece (set below) instead of classes for speed.
    classes = ["draggable", "piece", color, type];

    // Royal class is very important.
    if (PIECE_TYPES[type].royal) {
        classes.push("royal");
    }

    // Create the node
    // TODO Use a div with background-image instead, then can have arbitrary
    // characters, instead of just images, more flexible, maybe transition too.
    piece = dojo.create("img", {src:filename, "class":classes.join(" "), 
            className:classes.join(" ")});

    // Property will tell name of piece. To tell what color, or if it is
    // a piece in the first place, check the class names.
    piece.type = type;
    piece.color = color;

    // Highlight/unhighlight legal moves on mouse over, like Chess with Friends.
    // Yahoo Games does this too, but uses a yellow outline.
    piece.onmouseover = function(event) { over_piece(piece, event); };
    piece.onmouseout = function(event) { out_piece(piece, event); };

    // Make all new pieces draggable. I tried only making the active color's
    // pieces draggable, but then in Safari they can still be selected like text,
    // even with enable_document_selection(false), maybe I need to enable it on the
    // images too, but it wasn't appealing. In Firefox, the images can be dragged
    // as ghosts, which is cool, but instead: now pieces can only be dropped anywhere
    // if they are the active colors move. The player can drag the opponent's pieces
    // around but not drop anywhere.

    return piece;
}

// Highlight/unhighlight moves for a given piece, unless dragging.
// Return the from square, if anything was highlighted.
// If skip_legal, skip legal move highlighting, but continue to enable/disable blocked 
// move highlighting.
function highlight_moves(piece, enable, skip_legal)
{
    var from_square, moves, blocked_moves;

    // If player is dragging a piece over another piece, don't show
    // legal moves for the piece under it.
    if (!piece || DRAG.dragging) {
        return null;
    }

    from_square = piece.square;

    if (!from_square) {
        // Could not find a square for the piece, it no longer exists,
        // so no need to concern ourselves with highlighting its moves.
        return null;
    }
   
    if (piece.color === GAME_STATE.active_color) {
        // Active player's pieces
        moves = VALID_MOVES[from_square.filerank];
        blocked_moves = BLOCKED_MOVES[from_square.filerank];
    } else {
        // Opponent's pieces -- allow seeing valid moves if it was
        // their turn, if holding down shift.
        if (GAME_STATE.shift) {
            moves = VALID_MOVES_OPP[from_square.filerank];
            blocked_moves = BLOCKED_MOVES_OPP[from_square.filerank];
            GAME_STATE.shift = 1;    // showing other player's moves
        } else {
            return null;
        }
    }

    if (!skip_legal) {
        dojo.forEach(moves, function(move) {
            var x, y, flags, to_square;

            x = move.x;
            y = move.y;
            flags = move;

            to_square = VBOARD[x][y];
            if (enable) {
                push_highlight(to_square, DISPLAY["legal_move_" + to_square.color]);
            } else {
                pop_highlight(to_square);
            }
        });
    }

    // If shifted, show blocked moves, too.
    dojo.forEach(blocked_moves, function(move) {
        var x, y, flags, to_square;
        
        x = move.x;
        y = move.y;
        flags = move;

        to_square = VBOARD[x][y];
        if (GAME_STATE.shift) {
            if (enable) {
                push_highlight(to_square, DISPLAY["blocked_move_" + to_square.color]);
            } else {
                pop_highlight(to_square);
            }
        }
    });

    return from_square;
}

//// SQUARE FUNCTIONS / FILE-RANK NOTATION

// Convert filerank f8 to the x,y coordinate [8,6], etc. These coordinates
// are used internally, but filerank notation is useful for human consumption
// (though I actually think better in descriptive notation, but maybe I'm in the minority there)
// Note: does not accept piece name as initial character, yet.
// Also note: the returned coordinate is useful for looking up in a
// one-based table cell with (8,1) at the top-left. In filerank notation, this
// square is labeled a8. The bottom-right square (8,1) is filerank's h1.
function filerank2xy(code)
{
    var x = code.charCodeAt(0) - "a".charCodeAt(0) + 1; // corresponds to file (horizontal)
    var y = code.charCodeAt(1) - "1".charCodeAt(0) + 1; // corresponds to rank (vertical)

    //assert(x >= 1 && x <= GAME_STATE.files, "filerank2xy(" + code + "): bad x: " + x);
    //assert(y >= 1 && y <= GAME_STATE.ranks, "filerank2xy(" + code + "): bad y: " + y);

    return [x, y];
}

// Return an object with x and y from a filerank
// TODO: Replace filerank2xy with this
function filerank2obj(code)
{
    var xy = filerank2xy(code);

    return {x:xy[0], y:xy[1]};
}

// Convert from x,y coordinates to filerank notation for human consumption. Can either pass
// xy2filerank(1, 8) === "a8"
// xy2filerank([1, 8]) === "a8"
// xy2filerank(1, "") === "a"
function xy2filerank(x, y)
{
    var filerank;

    if (y === undefined) {
        // Passed array
        y = x[1];
        x = x[0];
    }

    //assert(x >= 1 && x <= GAME_STATE.files, "xy2filerank(" + x + ", " + y + "): bad x: " + x);
    //assert(y === "" || (y >= 1 && y <= GAME_STATE.ranks), "xy2filerank(" + x + ", " + y + "): bad y: " + y);

    filerank = String.fromCharCode(x + "a".charCodeAt(0) - 1);
    if (y !== "") {
        filerank += String.fromCharCode(y + "1".charCodeAt(0) - 1);
    }

    return filerank;
}


// Return name of square from color's perspective in English descriptive notation
// Accepts an array of two numbers, for file and rank, or just a file
// Only works for chess1, not any variants where the pieces are arranged differently.
function xy2descriptive(color, xy)
{
    var x, y;
    if (dojo.isArray(xy)) {
        x = xy[0];
        y = xy[1];
    } else if (xy.x && xy.y) {
        x = xy.x;
        y = xy.y;
    } else {
        x = xy;
        y = "";
    }

    assert(x >= 1 && x <= GAME_STATE.files, "xy2descriptive(" + x + ", " + y + "): bad x: " + x);
    assert(y === "" || (y >= 1 && y <= GAME_STATE.ranks), "xy2descriptive(" + x + ", " + y + "): bad y: " + y);

    return [null, "QR", "QN", "QB", "Q", "K", "KB", "KN", "KR"][x] + (color === "white" ? y : (GAME_STATE.ranks + 1) - y);
}

// Return name of square from color's perspective in "algebraic descriptive notation".
// Same file as xy2algebraic, but rank is from symmetric, not always white's perspective.
function xy2adescriptive(color, xy)
{
    var x, y;
 
    if (dojo.isArray(xy)) {
        x = xy[0];
        y = xy[1];
    } else if (xy.x && xy.y) {
        x = xy.x;
        y = xy.y;
    } else {
        x = xy;
        y = "";
    }

    assert(x >= 1 && x <= GAME_STATE.files, "xy2adescriptive(" + x + ", " + y + "): bad x: " + x);
    assert(y >= 1 && y <= GAME_STATE.ranks, "xy2adescriptive(" + x + ", " + y + "): bad y: " + y);

    return xy2filerank(x, "") + (color === "white" ? y : (GAME_STATE.ranks + 1) - y);
}

// Shorten a file name, in descriptive notation, to a possibly-ambiguous name.
// QR for queen's rook file is shortened to R, and so is KR for king's rook. 
function short_descriptive(descriptive_file)
{
    return {
        QR:"R", QN:"N", QB:"B", KB:"B", KN:"N", KR:"R", K:"K", Q:"Q",
        QRP:"RP", QNP:"NP", QBP:"BP", KBP:"BP", KNP:"NP", KRP:"RP", KP:"KP", QP:"QP" 
    }[descriptive_file];
}

// Get a square cell, given location in either
// - filerank notation (example: "a8", one argument), or
// - x,y coordinates, (equivalent example: 1,8)
// To get the square of a piece, use .square
// Note: code should use VBOARD[x][y] or .square. This is 
// only for user convenience (console) and debugging.
function sq(code, extra)
{
    var x, y, xy;

    //assert(code !== undefined, "sq(" + code + ", " + extra + "): code is undefined");
    //assert(code !== null, "sq(" + code + ", " + extra + "): code is null");

    // Is it x,y passed as separate parameters?
    if (extra !== undefined) {
        x = code;
        y = extra;
    // Is it a string in algebraic notation that can be converted?
    } else if (code.charCodeAt) {
        xy = filerank2xy(code);

        // Note JavaScript 1.8 can do var [x,y] = ...
        x = xy[0];
        y = xy[1];
    } else {
        assert(false, "sq(" + code + ", " + extra + "): couldn't find out what I was given");
    }

    /*assert(x >= 1 && x <= GAME_STATE.files && y >= 1 && y <= GAME_STATE.ranks, "sq(" + code + ", " + extra + 
        "): out of range (" + x + ", " + y + ")");*/

    return VBOARD[x][y];
}

//// CHESS960(FRC)/256/RANDOMIZED CHESS SETUP FUNCTIONS

// Set the variant and variant generator, updating the code in the process.
function set_variant_code(code, generator)
{
    var vc = dojo.byId("variant_code");
    
    vc.value = code;
    vc.style.display = code === null ? "none" : "";

    assert(generator, "set_variant_code(" + code + ", " + generator + "): requires generator");

    PREFS.variant_generator = generator;
}

// Load a new game when a new variant code is entered.
function update_variant_code(code) 
{
    assert(PREFS.variant_generator, "update_variant_code(" + code + "): called before set_variant_code, missing variant_generator");

    if (code.indexOf && code.indexOf("0x") === 0) {
        code = parseInt(code, 16);
    } else {
        code = parseInt(code, 10);
    }

    if (isNaN(code)) {
        code = undefined;
    }

    load_fen(PREFS.variant_generator(code));
}

// Decode the Chess960 S# (Scharnagl) code to a piece array
// Algorithm from _Play Stronger Chess by Examining Chess960_ by Gene Milener, pg. 82
function decode_chess960_s(number)
{
    var array = new Array(8);
    var light_bishop, dark_bishop, queen, krn_code, krn_array, available, i, j;


    assert(number >= 0 && number <= 959, "decode_chess960_s(" + number + "): out of range 0-959");

    // Bishops are placed on light and dark squares directly
    
    light_bishop = number % 4;
    array[light_bishop * 2 + 1]  = "B";
    // To do integer divison, reduce by remainder before dividing
    number -= light_bishop;
    number /= 4;

    dark_bishop = number % 4;
    array[dark_bishop * 2] = "B"; 
    number -= dark_bishop;
    number /= 4;

    // Queen is placed on Nth available square
    queen = number % 6;
    available = 0;
    for (i = 0; i < array.length; i += 1) {
        if (array[i]) {
            continue;
        }

        if (available === queen) {
            array[i] = "Q";
            break;
        }
        available += 1;
    }
    number -= queen;
    number /= 6;

    // Encodes king, knight, and rook
    knr_code = number;
    knr_array = [
        "NNRKR",    // S#000-095
        "NRNKR",    // S#096-191
        "NRKNR",    // S#192-287

        "NRKRN",    // S#288-383
        "RNNKR",    // S#384-479
        "RNKNR",    // S#480-575
        "RNKRN",    // S#576-671
        
        "RKNNR",    // S#672-767
        "RKNRN",    // S#768-863
        "RKRNN"     // S#864-959
            ][knr_code];

    j = 0;
    for (i = 0; i < array.length; i += 1) {
        if (array[i]) {
            continue;
        }

        array[i] = knr_array.charAt(j);
        j += 1;
    }

    // Divide into two groups for readability
    // Removed, since this is more annoying when manipulating. Should use it for display, though.
    //array.splice(4, 0, "-");

    return array.join("");
}

// Encode a Chess960 opening setup to an S# code.
function encode_chess960_s(string)
{
    var bishop, light_bishop, dark_bishop, queen, krn_code, i, number;

    string = string.replace("-", "");

    // Find light and dark bishops first
    bishop = string.indexOf("B");
    string = string.replace("B", "x");  // to avoid finding again, but not change offset
    if (bishop % 2) {
        light_bishop = (bishop - 1) / 2;
        dark_bishop = string.indexOf("B") / 2;
    } else {
        dark_bishop = bishop / 2;
        light_bishop = (string.indexOf("B") - 1) / 2;
    }

    // Queen is encoded as Nth available space, so exclude the two bishops before finding it
    string = string.replace("x", "");
    string = string.replace("B", "");
    queen = string.indexOf("Q");

    // Reverse lookup KNR code
    string = string.replace("Q", "");
    knr_code = {
        "NNRKR":0,    // S#000-095
        "NRNKR":1,    // S#096-191
        "NRKNR":2,    // S#192-287

        "NRKRN":3,    // S#288-383
        "RNNKR":4,    // S#384-479
        "RNKNR":5,    // S#480-575
        "RNKRN":6,    // S#576-671
        
        "RKNNR":7,    // S#672-767
        "RKNRN":8,    // S#768-863
        "RKRNN":9     // S#864-959
            }[string];

    number = light_bishop + 4 * dark_bishop + 16 * queen + 96 * knr_code;

    return number;
}

// TODO: Add F# (Fritz9) and R# (Milener's reciprocal) Chess960 starting position codes, enc/dec

// Generate the castling string in Shredder-FEN, from a Chess960 setup 
function generate_castling_eligibility(setup_string)
{
    var rook1, rook2, file1, file2, castling;

    rook1 = setup_string.indexOf("R");
    setup_string = setup_string.replace("R", "-");
    rook2 = setup_string.indexOf("R");

    file1 = String.fromCharCode("a".charCodeAt(0) + rook1);
    file2 = String.fromCharCode("a".charCodeAt(0) + rook2);

    // AHha, for example
    castling = file1 + file2;
    castling = castling.toUpperCase() + castling;

    return castling;
}

// Return the FEN for a Chess960/Fischerrandom game, either of the given S# code, or random if undefined
function setup_chess960(code)
{
    var setup_string, castling;

    if (code === undefined) {
        code = Math.floor(Math.random() * 960);
    }

    setup_string = decode_chess960_s(code);
    castling = generate_castling_eligibility(setup_string);

    set_variant_code(code, setup_chess960);
    return setup_string.toLowerCase() + "/pppppppp/8/8/8/8/PPPPPPPP/" + setup_string + " w " + castling + " -";
}

// Decode a Chess256 setup position code
function decode_chess256(code)
{
    var ret, i, bit;

    assert(code >= 0 && code <= 255, "decode_chess256(" + code + "): out of range 0-255, inclusive");

    // Code is an 8-bit binary number, where 1=pawn on 3rd rank, 2=on 2nd rank
    // reading left-to-right, from white's perspective. (This is my invention.)
    var rank2 = [".", ".", ".", ".", ".", ".", ".", "."];
    var rank3 = [".", ".", ".", ".", ".", ".", ".", "."];

    for (var i = 7; i != -1; i -= 1) {
        bit = code % 2;

        if (bit) {
            rank3[i] = "p";
        } else {
            rank2[i] = "p";
        }

        code /= 2;
        code = Math.floor(code);
    }

    ret = {rank2: rank2.join(""), rank3: rank3.join("")};

    return ret;
}

// Return the FEN for a Chess256/Randompawns game, http://hem.passagen.se/melki9/randompawn.htm
function setup_chess256(code)
{
    var fen, setup;

    if (code === undefined) {
        code = Math.floor(Math.random() * 255);
    }

    setup = decode_chess256(code);

    set_variant_code(code, setup_chess256);

    return "rnbqkbnr/" + setup.rank2 + "/" + setup.rank3 + "/8/8/" + 
        setup.rank3.toUpperCase() + "/" + setup.rank2.toUpperCase() + "/RNBQKBNR w KQkq -";
}

// Decode a D-Chess setup position. This is another custom encoding.
function decode_dchess(code)
{
    var black_setup, white_setup, white_code, black_code;

    // Synder says there are 8,299,400 positions, which is (4*6!)^2, 
    // but I get 132,710,400 = (4*4*6!)^2. Dark bishop can be on 4 different
    // squares, dark bishop the 4 other squares, and 6 other squares to fill.
    assert(code >= 0 && code <= 132710400, "setup_dchess(" + code + "): out of range 0-132710400, inclusive");

    // Lower half is for white (11520 = sqrt(13710400) - 1)
    white_code = code % 11520;
    white_setup = decode_one_dchess(white_code);

    // Upper is black.
    black_code = (code - white_code) / 11520;
    black_setup = decode_one_dchess(black_code).toLowerCase();

    return {white:white_setup, black:black_setup};
}

// Decode the D-Chess setup position for one side only. Since it encodes both
// black and white, this should be called twice to get the full position.
function decode_one_dchess(code)
{
    var dark_bishop, light_bishop, piece, array, pieces, spaces;
    
    assert(code >= 0 && code <= 11519, "decode_one_dchess(" + code + "): out of range 0-11519, inclusive");

    array = ["-", "-", "-", "-", "-", "-", "-", "-"];

    // First dark and light bishop, on dark and light squares only.
    dark_bishop = code % 4;
    code -= dark_bishop;
    code /= 4;
    array[dark_bishop * 2] = "B";

    light_bishop = code % 4;
    code -= light_bishop;
    code /= 4;
    array[light_bishop * 2 + 1] = "B";

    // Place knight, knight, rook, rook, queen, and king on first
    // available Nth square as stored.
    pieces = ["N", "N", "R", "R", "Q", "K"];
    spaces = 6;

    do
    {
        piece = code % spaces;
        code -= piece;
        code /= spaces;

        array[nth_index_of(array, "-", piece)] = pieces[6 - spaces];

        //console.log("place",pieces[6-spaces]," at ",piece,"nth = ",array.join(""));

    } while (spaces -= 1);

    return array.join("");
}

// D-Chess http://www.d-chess.com/
function setup_dchess(code)
{
    var setup, fen;

    if (code === undefined) {
        code = Math.floor(Math.random() * 132710400);
    }

    setup = decode_dchess(code);

    set_variant_code(code, setup_dchess);

    fen = setup.black + "/pppppppp/8/8/8/8/PPPPPPPP/" + setup.white + " ? - -";

    return fen;
}

//// DRAG-AND-DROP FUNCTIONS

// Initiate drag-and-drop on mouse down, if over a draggable element
function mousedown(event)
{
    var target;

    event = event || window.event;

    target = event.target !== undefined ? event.target : event.srcElement;

    if (target.className.indexOf("draggable") === -1) {
        return;
    }

    if (event.shiftKey) {
        open_piece_url(target);
    }

    if (target.className.indexOf("tear-off") !== -1) {
        // This is from the piece library, so allow a new copy
        // of the piece to be torn off.
        var tear = create_piece(target.color, target.type);

        tear.style.left = dojo._abs(target, true).x + "px";
        tear.style.top = dojo._abs(target, true).y + "px";

        dojo.body().appendChild(tear);

        target = tear;
    }

    DRAG.initial_x = event.clientX;
    DRAG.initial_y = event.clientY;

    DRAG.start_x = target.offsetLeft;
    DRAG.start_y = target.offsetTop;

    DRAG.initial_left = dojo._abs(target, true).x;
    DRAG.initial_top = dojo._abs(target, true).y;

    // Bring to front
    DRAG.old_zindex = target.style.zIndex;
    target.style.zIndex = 10000;

    // Capture mouse
    DRAG.element_m = target;
    document.onmousemove = mousemove;
    document.onmouseup = mouseup;

    // Prevent text selection
    document.body.focus();
    document.onselectstart = function() { return false; };
    target.ondragstart = function() { return false; };

    DRAG.dragging = true;

    return false;
}

// Initiate dragging if touching a draggable element
function touch(evt)
{
    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i]; 

        var color, border;
        var target = e.target;

        if (target && target.className &&
                target.className.indexOf("draggable") !== -1 && !DRAG.touching) {

            // Save the offset of the touch within the current note
            DRAG.initial_left = dojo._abs(target, true).x;
            DRAG.initial_top = dojo._abs(target, true).y;
            DRAG.touching = [e.pageX - DRAG.initial_left, e.pageY - DRAG.initial_top];

            over_piece(target, {});
        }
    }

    DRAG.dragging = true;
}

// Continue dragging with the mouse
function mousemove(event)
{
    var element, new_x, new_y;
        
    event = event || window.event;

    element = DRAG.element_m;

    // Must have draggable class
    if (!element || element.className.indexOf("draggable") === -1) {
        return;
    }

    new_x = event.clientX - DRAG.initial_x + DRAG.start_x;
    new_y = event.clientY - DRAG.initial_y + DRAG.start_y;

    // Drag
    element.style.webkitTransition = "";
    element.style.left = new_x + "px";
    element.style.top = new_y + "px";
    dragging_over(element, new_x, new_y);

    return false;
}

// Continue dragging with touch events
function touchmove(evt) 
{
    evt.preventDefault();
    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i];

        if (DRAG.touching && e.target.className.indexOf("draggable") !== -1) {
                // Move the node if we're in a state of dragging, but not resizing
                var new_x = e.pageX - DRAG.touching[0];
                var new_y = e.pageY - DRAG.touching[1];

                e.target.style.webkitTransition = "";
                e.target.style.left = new_x + "px";
                e.target.style.top = new_y + "px";

                dragging_over(e.target, new_x, new_y);
                DRAG.element_t = e.target;
        }
    }
}

// Detect if over droppable area and act as needed.
// element: the element that is /being dragged/
function dragging_over(element, left, top)
{
    // Position from center
    var x = left + (DISPLAY.square_width / 2);
    var y = top + (DISPLAY.square_height / 2);

    // Inside board?
    if (x > DROP.area.left && y > DROP.area.top &&
        x < DROP.area.right && y < DROP.area.bottom) {

        DROP.offboard = false;

        // Find cell mathematically
        var cell_x = Math.ceil((x - DROP.area.left) / DISPLAY.square_width);
        var cell_y = Math.ceil((DROP.area.bottom - y) / DISPLAY.square_height);
        if (cell_y === 0) {
            cell_y = 1;
        }

        // Highlight droppable square
        var flipped = PREFS.flipped;
        if (!VBOARD[flipped ? (GAME_STATE.files + 1) - cell_x : cell_x]) {
            DROP.square = null;
            return;
        }
        var square = VBOARD[flipped ? (GAME_STATE.files + 1) - cell_x : cell_x][flipped ? (GAME_STATE.ranks + 1) - cell_y : cell_y];
        
        if (DROP.square) {
            pop_highlight(DROP.square);
        }

        if (accepts(element, square)) {
            DROP.square = square;

            push_highlight(square, DISPLAY["recent_move_" + square.color]);
        } else {
            DROP.square = null;
        }

    } else {
        // Outside droppable area
        DROP.offboard = true;
        
        if (DROP.square) {
            dojo.removeClass(DROP.square, "dropping-square");
            DROP.square = null;
        }

        // TODO: change icon to show out of range, if was from within range
    }
}

// Drop or revert on mouse up
function mouseup()
{
    if (DRAG.element_m === null) {
        return;
    }

    DRAG.element_m.style.zIndex = DRAG.old_zindex;
    document.onmousemove = null;
    document.onselectstart = null;
    DRAG.element_m.ondragstart = null;

    drop_or_revert();

    DRAG.element_m = null;
    DROP.square = null;
}


// Drop or revert on touch end
function touchend(evt)
{
    drop_or_revert();

    for (var i = 0; i < evt.changedTouches.length; ++i) {
        var e = evt.changedTouches[i];

        // Check to see if we've gone from a gesture back down to a touch
        if (e.target && e.target.className && e.target.className.indexOf("draggable") !== -1) {

            out_piece(e.target, {});

            if (evt.targetTouches.length == 1) {
                // If there was rotation, this number needs to be reset
                DRAG.touching = [evt.targetTouches[0].pageX - dojo.style(e.target, "left"), evt.targetTouches[0].pageY - dojo.style(e.target, "top")];
            } else if(!evt.targetTouches.length) {
                // Great use of e.targeTouches, since releasing on finger that's part
                // of a gesture over this node would trigger a touchend even though
                // it could keep going
                DRAG.touching = false;
            }
        }
    }
}

// Return whether square should accept dropping a piece on it
function accepts(piece, square)
{
    // Can never move to source square (not even for null moves).
    if (piece.square && piece.square.x === square.x &&
        piece.square.y === square.y) {
        return false;
    }

    // Can drop anywhere
    if (PREFS.setup_mode) {
        return true;
    }

    if (!piece.square) {
        // If not in setup mode, needs a source square
        return false;
    }

    var outer = IS_VALID_MOVE[piece.square.filerank];
    return outer && outer[square.filerank];
}

// Drop the dragging object (wherever it is), or move it back if it is not over a droppable area
function drop_or_revert()
{
    var piece, square;

    DRAG.dragging = false;

    piece = (DRAG.touching && DRAG.element_t) || DRAG.element_m;
    if (!piece) {
        // Nothing was being dragged
        return;
    }

    square = DROP.square;

    // Dragging offboard: delete in setup mode
    if (DROP.offboard && PREFS.setup_mode) {
        var new_top = dojo.style(piece, "top") + dojo.style(piece, "height") / 2;
        var new_left = dojo.style(piece, "left") + dojo.style(piece, "width") / 2;
        // Shrink off into the distance
        dojo.anim(piece, {width:0, height:0, top:new_top, left:new_left}, PREFS.revert_time, undefined, function() {
                // It was on board, move piece over itself to kill it
                if (piece.square) {
                    do_virtual_move(piece, {x:piece.square.x, y:piece.square.y});
                }
                // Remove node, so leftover torn-off pieces from library
                // that were not dragged anywhere do not accumulate.
                if (piece.parentNode) {
                    piece.parentNode.removeChild(piece);
                }
               
            });
        return;
    }

    // Not valid drop square: revert
    if (!square || !accepts(piece, square)) {
        if (!piece.style.left && !piece.style.top) {
            // Dropped where picked it up - no movement.
            // Do not revert, since would then pop out to (0,0)
            // and revert it back.
            // TODO: tap-to-move, as an alternative to dragging
            return;
        }

        // Revert
        if (typeof WebKitCSSMatrix === "object") {
            // Use webkit transforms if available; faster
            // Feature detection from http://iui.googlecode.com/svn/trunk/test/features.html
            // (detects for css transforms, hopefully close enough)
            piece.style.webkitTransition = "left " + PREFS.revert_time + "ms linear, " + 
                "top " + PREFS.revert_time + "ms linear";
            piece.style.left = DRAG.initial_left + "px";
            piece.style.top  = DRAG.initial_top + "px";
        } else {
            dojo.anim(piece, { left: DRAG.initial_left, top: DRAG.initial_top }, PREFS.revert_time);
        }
        return;
    }

    //console.log("drop",piece,square);
    move_dropped_piece(piece, square, null);
}

// Initialize drag and drop system
function init_dnd() 
{
    document.onmousedown = mousedown;
    document.ontouchmove = touchmove;//mousemove

    document.ontouchstart = touch;
    dojo.query(".draggable").forEach(function(e) {
            e.ontouchmove = touchmove;
        });
    document.ontouchend = touchend;

    DROP.area.left = DISPLAY.board_left;
    DROP.area.top = DISPLAY.board_top;
    DROP.area.width = GAME_STATE.files * DISPLAY.square_width;
    DROP.area.height = GAME_STATE.ranks * DISPLAY.square_height;


    DROP.area.right = DROP.area.left + DROP.area.width;
    DROP.area.bottom = DROP.area.top + DROP.area.height;
}

//// LOW-LEVEL FUNCTIONS

// Get the index of the nth needle in the array. Like Array.indexOf(),
// when nth = 0. If nth = 1, the index of the 2nd occurrence is returned,
// and so on.
function nth_index_of(array, needle, nth)
{
    var hits = 0;

    if (!nth) {
        nth = 0;
    }

    for (var i = 0; i < array.length; i += 1) {
        if (array[i] === needle) {
            if (hits === nth) {
                return i;
            }

            hits += 1;
        }
    }

    return -1;
}

// Return an array including integers between a and b, inclusive.
// inclusive_range(0, 5) and inclusive_range(5, 0) both return
// [0, 1, 2, 3, 4, 5], so you don't have to think about what argument
// goes first.
function inclusive_range(a, b) 
{
    var start = Math.min(a, b);
    var count = Math.abs(a - b);
    var a = []; 
   
    for (var i = start; i <= start + count; i += 1) {
        a.push(i);
    }

    return a;
}


// Escape a plaintext string for displaying in HTML
function escape_html(s)
{
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// Unique an array. Based on http://blog.archive.jpsykes.com/212/unique-array-filter-in-dojo/index.html
function uniq(arr)
{
    var test = {};
    var result = [];

    for (var i = 0, len = arr.length; i < len; i += 1) {
        if (!test[arr[i]]) {
            test[arr[i]] = true;
            result.push(arr[i]);
        }
    }
    return result;
}

// Modify the existing stylesheet, returning the value. If value is
// undefined, get the old value instead of changing it.
function change_css(ordinal, property, value)
{
    var rules = document.styleSheets[0].cssRules || document.styleSheets[0].rules;

    if (value === undefined) {
        return rules[ordinal].style[property];
    } else {
        return rules[ordinal].style[property] = value;
    }
}

// Toggle display of an element
function toggle(element)
{
    // Used to use Scriptaculous Effect.toggle here

    var old = element.style.display;

    element.style.display = old === "none" ? "" : "none";
}



// Return sign of number as {-1,0,1}
function signum(n)
{
    return n > 0 ? 1 : (n < 0 ? -1 : 0);
}

// Get the value of a form element
function form_value(e)
{
    e = dojo.byId(e);

    if (e.checked !== undefined) {
    return e.checked;
    }

    return dojo.byId(e).value;
}

// Get URL query string as an object
// Based on http://www.dojotoolkit.org/book/dojo-porting-guide-0-4-x-0-9/dojo-uri-changes
function query_string()
{
    var parts, dict = {};
    var query;

    if (location.search) {
        query = location.search;
    } else if (location.hash) {
        query = location.hash;
    }
    if (!query) {
        return {};
    }

    parts = query.split(/[&;]/);
    dojo.forEach(parts, function(pair) {
            var part = pair.match(/([a-zA-Z0-9]*)=(.*)/);
            if (part) { 
                dict[part[1]] = decodeURIComponent(part[2]); 
            }
         }, this);

    return dict;
}

// Random integer within range
function randint(minimum, maximum)
{
    return Math.floor(Math.random() * (maximum - minimum + 1)) + minimum;
}

// Uppercase first character, like in Perl
function ucfirst(s)
{
    assert(s.substring, "ucfirst(" + s + "): no substring method, not a string? callee=" + 
            arguments.callee);
    return s.substring(0, 1).toUpperCase() + s.substring(1);
}

// Based on http://aymanh.com/9-javascript-tips-you-may-not-know
function AssertException(message) { this.message = message; }
AssertException.prototype.toString = function() {
    return 'AssertException: ' + this.message;
};

function assert(expression, message)
{
    if (!expression) {
        if (GAME_STATE.alert_assert) {
            alert(message);
        }

        if (window.console && console.trace) {
            // Give a stack trace for Firebug
            console.trace();
        }

        throw new AssertException(message);
    }
}

// Based on http://tech.hickorywind.org/articles/2008/10/24/turning-off-text-selection-in-javascript
var ORIGINAL_ONSELECTSTART;
function enable_document_selection(enable, element) 
{
    var element = element || document;

    if (enable) {
        element.onselectstart = ORIGINAL_ONSELECTSTART;
    } else {
        ORIGINAL_ONSELECTSTART = element.onselectstart;
        element.onselectstart = function() { return false; };
    }
}

</script>
</head>
<body onload="main()">
<table id="outer">
<tr>
<td style="vertical-align: top">

<canvas id="canvas-board">Sorry, you are using a browser that does not support HTML5. Time to upgrade. Or you can use the <a href="oldtableboard.html">old HTML-table-based</a> version, but it is no longer maintained.</canvas>

</td><td style="vertical-align: top">
<noscript><p>JavaScript is disabled, nothing will work!</p></noscript>

<div id="game_ui">

<!-- Header elements, game metadata. Hidden/shown as needed. -->
<p id="header" style="display: none; text-align: center" 
onclick="edit_pgn()" class="show_White">
<span class="players">
<span id="PGN_White" class="player_name" style="display: none">White</span>
<span class="player_elo"><span style="display: none" class="show_WhiteElo">(</span><span id="PGN_WhiteElo" style="display: none">1500</span><span class="show_WhiteElo" style="display: none">)</span></span>
<span id="vs" style="display: none" class="show_White">vs.</span>
<span id="PGN_Black" class="player_name" style="display: none">Black</span>
<span class="player_elo"><span style="display: none" class="show_BlackElo">(</span><span id="PGN_BlackElo" style="display: none">1500</span><span class="show_BlackElo" style="display: none">)</span></span>
</span>
<br class="show_White" style="display: none">

<span id="PGN_Event" style="display: none">Event</span>
<span style="display: none" class="show_Round">(</span><span id="PGN_Round" style="display: none">Round</span><span style="display: none" class="show_Round">)</span>
<span id="PGN_Site" style="display: none">Site</span><br class="show_Event" style="display: none">

<span id="PGN_Date" style="display: none">Date</span>
<span id="PGN_Time" style="display: none">Time</span>
</p> 

<p onclick="edit_pgn()">
<span id="status"></span> 
<span id="dash" style="display: none">&mdash;</span>
<span id="check"></span>
</p>

<p>
<span id="promote_container"></span>
</p>

<p><a id="copyable_link">link</a> (<span onclick="alert('You need to click higher up (the cursor should turn to a hand).')" id="copy_link" style="color: blue">copy</span>, <a href="#" onclick="email_board()">email</a>)
<p><span id="opening_name"></span>

<div id="piece-inspector" style="display: none; z-index: 2">
<p><span style="vertical-align: middle" id="inspector-image"></span> <span id="inspector-type" style="font-weight: bold">type</span>
<p>Movement: <span id="inspector-movement">movement</span>
<p>Symbols: <span id="inspector-symbols">symbols</span>
<p><span id="inspector-info">other info</span>
<p><div id="inspector-diagram"></div>
</div>

<!-- TODO: disclosure triangles -->
<p><a href="#" onclick="var _c=dojo.byId('controls');_c.style.display=_c.style.display==='none'?'':'none'">controls</a> | 
<a href="#" onclick="toggle_piece_library();">setup</a> |
<a href="#" onclick="game_file_list()">saved</a>

<div id="controls" style="display: none; border-left: 2px solid blue">
<div>

<p><select accesskey="m" id="make_move_menu" onchange="make_move_by_menu(this)"></select>

<!-- TODO: hide all this, since the purpose of this app is
not to implement chess AI. But having automatic moves is useful for testing. -->
<p>Engine: <label for="white_computer"><input accesskey="w" type="checkbox" id="white_computer" name="white_computer" onclick="computer_move_if_applicable(this)">White</label> 
<label for="black_computer"><input accesskey="b" type="checkbox" id="black_computer" name="black_computer" onclick="computer_move_if_applicable(this)">Black</label>

<span id="score"></span><br>

<div id="show_skill" style="display: none"><p>Skill Level: 
<input type="text" size="3" maxlength="3" id="skill_level" onchange="update_skill(this)"></div>

<p><select accesskey="o" id="output_notation" name="output_notation" onchange="show_move_history()"></select>

<p><a href="#" onclick="edit_pgn()">import/edit PGN</a>

 <p>
 <label for="enable_flip"><input accesskey="f" name="enable_flip" id="enable_flip" type="checkbox" onclick="flip()">Flip</label>

 <label for="enable_setup_mode"><input accesskey="e" name="enable_setup_mode" id="enable_setup_mode" type="checkbox" onclick="set_setup_mode(this.checked)">Setup</label>

 <p><select id="saved_board_menu" onchange="change_loaded_board(this)"></select>
     <button onclick="change_loaded_board(dojo.byId('saved_board_menu'))" accesskey="n">New Game</button>
 <p><input name="variant_code" id="variant_code" size="10" style="display: none" onchange="update_variant_code(this.value)">
 
 </div>
 </div>
 <!-- end controls-->

 <div id="piece-library-parent" style="display: none">
 <div id="piece-library" style="width: 600px; height: 325px; overflow: auto; position: relative"> </div>
 </div>
 <!-- end piece library -->

 <div id="game-browser" style="display: none"></div>

  <div id="captured_piece_images" style="width: 250px;"></div>
  <div id="moves_container" style="width: 500px; text-align: justify">
  <!-- TODO: scrollbar, http://livepipe.net/control/scrollbar -->
  <!-- TODO: use contenteditable=true for in-place editing in Safari -->
  <p id="move_history"></p>
  </div>
</div>

 </td>
</tr>
</table>

</body>
</html>
